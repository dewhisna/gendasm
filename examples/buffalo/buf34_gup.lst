buf34_gup.lst - generated by MGTEK Assembler ASM11 V1.17 Build 107 for Linux (x86) - Fri Sep  3 11:26:59 2021

    1:                                 * BUFFALO (Version 1.0 for GuP)
    2:                                 * "Bit User's Fast Friendly Aid to Logical Operation"
    3:                                 *
    4:                                 * Rev 1.0 - 9/26/08 - following changes made to convert from 68HC11 to GuP
    5:                                 *                   - modifications by Zach Peine
    6:                                 *                   - RAM location changed from 0000 to 0040
    7:                                 *                   - Registers location changed from 1000 to 0000
    8:                                 *                   - Buffalo memory space set to start at 0040
    9:                                 *                   - Added code to INIT routine for initializing the display
   10:                                 *                   - Removed COP code (there isn't currently a COP) from INPUT 
   11:                                 *                     method and added a check of the keyboard adapter
   12:                                 *                   - Added code to OUTPUT to write characters to the display
   13:                                 *                   - Changed ONSCI to use the new CPB register ($35) to set
   14:                                 *                     the baud rate. This allows easily setting the baud to
   15:                                 *                     anything between 300 and 115200.
   16:                                 *                   - Changed OUTCRLF to output to the display and wait until 
   17:                                 *                     the VGA adapter clears the rest of the line in memory
   18:                                 *                   - Removed EEPROM programming code. (There isn't one
   19:                                 *                     programmable by the CPU.)
   20:                                 *
   21:                                 * Origianl BUFFALO code for version 3.4 below
   22:                                 *
   23:                                 * Rev 2.0 - 4/23/85 - added disassembler.
   24:                                 *                   - variables now PTRn and TMPn.
   25:                                 * Rev 2.1 - 4/29/85 - added byte erase to chgbyt routine.
   26:                                 * Rev 2.2 - 5/16/85 - added hooks for evb board - acia
   27:                                 *                     drivers, init and host routines.
   28:                                 *           7/8/85  - fixed dump wraparound problem.
   29:                                 *           7/10/85 - added evm board commands.
   30:                                 *                   - added fill instruction.
   31:                                 *           7/18/85 - added jump to EEPROM.
   32:                                 * Rev 2.3 - 8/22/85 - call targco to disconnect sci from host
   33:                                 *                     in reset routine for evb board.
   34:                                 *           10/3/85 - modified load for download through terminal.
   35:                                 * Rev 2.4 - 7/1/86  - Changed DFLOP address to fix conflicts with
   36:                                 *                     EEPROM.  (was at A000)
   37:                                 * Rev 2.5 - 9/8/86  - Modified to provide additional protection from
   38:                                 *                     program run-away on power down.  Also fixed bugs
   39:                                 *                     in MM and MOVE.  Changed to 1 stop bit from 2.
   40:                                 * Rev 2.6 - 9/25/86 - Modified boot routine for variable length download
   41:                                 *                     for use with 'HC11E8.
   42:                                 * Rev 3.0   1/15/87 - EEPROM programming routines consolidated into WRITE.
   43:                                 *                     Fill, Assem, and breakpoints will now do EEPROM.
   44:                                 *                   - Added compare a to $0D to WSKIP routine.
   45:                                 *           2/11/87 - Set up load to detect receiver error.
   46:                                 * Rev 3.2   7/7/87  - Add disassembly to trace.
   47:                                 *                   - Add entries to jump table.
   48:                                 *           9/20/87 - Rewrote trace to use XIRQ, added STOPAT Command
   49:                                 *           11/24/87- Write block protect reg for 'E9 version
   50:                                 *                   - Modified variable length download for use
   51:                                 *                       with 'E9 bootloader (XBOOT command)
   52:                                 * Rev 3.3   3/17/88 - Set I bit to block interrupts on Warm Start and
   53:                                 *                       return from CALL command.
   54:                                 *                   - Added EEMOD Command.
   55:                                 *                   - Rearranged source so that HELP command overlaps
   56:                                 *                       EEPROM in test mode.
   57:                                 *           3/24/88 - Added '+', '-', '=', '.' to MEM and ASM commands.
   58:                                 *                   - Added check for 16 byte boundary to MEM
   59:                                 *                       space sub-command.
   60:                                 *                   - LOAD command now puts dummy (~) command into
   61:                                 *                       inbuff so that any stray cr's won`t hang.
   62:                                 * Rev 3.4   8/15/88 - Changed WRITE subroutine so that config register
   63:                                 *                       gets byte erased before programmed.  The original
   64:                                 *                       value of config is used for EEBYTE so that config
   65:                                 *                       RAM value doesn't get changed in test mode.
   66:                                 *           8/17/88 - Fixed MOVE command so that it doesn't hang when move
   67:                                 *                       is done to a ROM location.
   68:                                 *                   - Added OFFSET command for download offset capability.
   69:                                 *
   70:                                 ****************************************************
   71:                                 *    Although the information contained herein,    *
   72:                                 *    as well as any information provided relative  *
   73:                                 *    thereto, has been carefully reviewed and is   *
   74:                                 *    believed accurate, Motorola assumes no        *
   75:                                 *    liability arising out of its application or   *
   76:                                 *    use, neither does it convey any license under *
   77:                                 *    its patent rights nor the rights of others.   *
   78:                                 ****************************************************
   79:                                 
   80:                                 ***************
   81:                                 *   EQUATES   *
   82:                                 ***************
   83:                                 *Author EQU  Tony Fourcroy
   84:          =00000040              RAMBS   EQU  $0040      ;start of ram
   85:          =00000400              ramsize equ  $0400      ; 1k
   86:          =00000000              REGBS   EQU  $0000      ;start of registers
   87:          =0000E000              ROMBS   EQU  $E000      ;start of rom
   88:          =0000B600              DSTREE  EQU  $B600      ;start of eeprom
   89:          =0000B7FF              DENDEE  EQU  $B7FF      ;end of eeprom
   90:          =0000000A              PORTE   EQU  REGBS+$0A  ;port e
   91:          =0000000B              CFORC   EQU  REGBS+$0B  ;force output compare
   92:          =0000000E              TCNT    EQU  REGBS+$0E  ;timer count
   93:          =0000001E              TOC5    EQU  REGBS+$1E  ;oc5 reg
   94:          =00000020              TCTL1   EQU  REGBS+$20  ;timer control 1
   95:          =00000022              TMSK1   EQU  REGBS+$22  ;timer mask 1
   96:          =00000023              TFLG1   EQU  REGBS+$23  ;timer flag 1
   97:          =00000024              TMSK2   EQU  REGBS+$24  ;timer mask 2
   98:          =0000002B              BAUD    EQU  REGBS+$2B  ;sci baud reg
   99:          =0000002C              SCCR1   EQU  REGBS+$2C  ;sci control1 reg
  100:          =0000002D              SCCR2   EQU  REGBS+$2D  ;sci control2 reg
  101:          =0000002E              SCSR    EQU  REGBS+$2E  ;sci status reg
  102:          =0000002F              SCDAT   EQU  REGBS+$2F  ;sci data reg
  103:          =00000035              BPROT   EQU  REGBS+$35  ;block protect reg
  104:          =00000039              OPTION  EQU  REGBS+$39  ;option reg
  105:          =0000003A              COPRST  EQU  REGBS+$3A  ;cop reset reg
  106:          =0000003B              PPROG   EQU  REGBS+$3B  ;ee prog reg
  107:          =0000003C              HPRIO   EQU  REGBS+$3C  ;hprio reg
  108:          =0000003F              CONFIG  EQU  REGBS+$3F  ;config register
  109:          =00004000              DFLOP   EQU  $4000      ;evb d flip flop
  110:          =0000D000              DUART   EQU  $D000      ;duart address
  111:          =0000D000              PORTA   EQU  DUART
  112:          =0000D008              PORTB   EQU  DUART+8
  113:          =00009800              ACIA    EQU  $9800      ;acia address
  114:          =0000003E              PROMPT  EQU  '>'
  115:          =00000023              BUFFLNG EQU  35
  116:          =00000001              CTLA    EQU  $01        ;exit host or assembler
  117:          =00000002              CTLB    EQU  $02        ;send break to host
  118:          =00000017              CTLW    EQU  $17        ;wait
  119:          =00000018              CTLX    EQU  $18        ;abort
  120:          =0000007F              DEL     EQU  $7F        ;abort
  121:          =00000004              EOT     EQU  $04        ;end of text/table
  122:          =0000003F              SWI     EQU  $3F
  123:                                 
  124:                                 ***************
  125:                                 *     RAM     *
  126:                                 ***************
  127:          =00000040                      ORG  rambs
  128:                                 *** Buffalo ram space ***
  129:     0040 +0014                          RMB  20    ;user stack area
  130:     0054 +001E                  USTACK  RMB  30    ;monitor stack area
  131:     0072 +0001                  STACK   RMB  1  
  132:     0073 +0009                  REGS    RMB  9     ;user's pc,y,x,a,b,c
  133:     007C +0002                  SP      RMB  2     ;user's sp
  134:     007E +0023                  INBUFF  RMB  BUFFLNG    ;input buffer
  135:          =000000A1              ENDBUFF EQU  *
  136:     00A1 +0008                  COMBUFF RMB  8     ;command buffer
  137:     00A9 +0002                  SHFTREG RMB  2     ;input shift register
  138:     00AB +0002                  STREE   RMB  2     ;eeprom start address
  139:     00AD +0002                  ENDEE   RMB  2     ;eeprom end address
  140:     00AF +0008                  BRKTABL RMB  8     ;breakpoint table
  141:     00B7 +0001                  AUTOLF  RMB  1     ;auto lf flag for i/o
  142:     00B8 +0001                  IODEV   RMB  1     ;0=sci,  1=acia, 2=duartA, 3=duartB
  143:     00B9 +0001                  EXTDEV  RMB  1     ;0=none, 1=acia, 2=duart,
  144:     00BA +0001                  HOSTDEV RMB  1     ;0=sci,  1=acia,           3=duartB
  145:     00BB +0001                  COUNT   RMB  1     ;# characters read
  146:     00BC +0001                  CHRCNT  RMB  1     ;# characters output on current line
  147:     00BD +0002                  PTRMEM  RMB  2     ;current memory location
  148:     00BF +0002                  LDOFFST RMB  2     ;offset for download
  149:                                 
  150:                                 *** Buffalo variables - used by: ***
  151:     00C1 +0002                  PTR0    RMB  2     ;main,readbuff,incbuff,AS
  152:     00C3 +0002                  PTR1    RMB  2     ;main,BR,DU,MO,AS,EX
  153:     00C5 +0002                  PTR2    RMB  2     ;EX,DU,MO,AS
  154:     00C7 +0002                  PTR3    RMB  2     ;EX,HO,MO,AS
  155:     00C9 +0002                  PTR4    RMB  2     ;EX,AS
  156:     00CB +0002                  PTR5    RMB  2     ;EX,AS,BOOT
  157:     00CD +0002                  PTR6    RMB  2     ;EX,AS,BOOT
  158:     00CF +0002                  PTR7    RMB  2     ;EX,AS
  159:     00D1 +0002                  PTR8    RMB  2     ;AS
  160:     00D3 +0001                  TMP1    RMB  1     ;main,hexbin,buffarg,termarg
  161:     00D4 +0001                  TMP2    RMB  1     ;GO,HO,AS,LOAD
  162:     00D5 +0001                  TMP3    RMB  1     ;AS,LOAD
  163:     00D6 +0001                  TMP4    RMB  1     ;TR,HO,ME,AS,LOAD
  164:                                 *** Vector jump table ***
  165:     00D7 +0003                  JSCI    RMB   3
  166:     00DA +0003                  JSPI    RMB   3
  167:     00DD +0003                  JPAIE   RMB   3
  168:     00E0 +0003                  JPAO    RMB   3
  169:     00E3 +0003                  JTOF    RMB   3
  170:     00E6 +0003                  JTOC5   RMB   3
  171:     00E9 +0003                  JTOC4   RMB   3
  172:     00EC +0003                  JTOC3   RMB   3
  173:     00EF +0003                  JTOC2   RMB   3
  174:     00F2 +0003                  JTOC1   RMB   3
  175:     00F5 +0003                  JTIC3   RMB   3
  176:     00F8 +0003                  JTIC2   RMB   3
  177:     00FB +0003                  JTIC1   RMB   3
  178:     00FE +0003                  JRTI    RMB   3
  179:     0101 +0003                  JIRQ    RMB   3
  180:     0104 +0003                  JXIRQ   RMB   3
  181:     0107 +0003                  JSWI    RMB   3
  182:     010A +0003                  JILLOP  RMB   3
  183:     010D +0003                  JCOP    RMB   3
  184:     0110 +0003                  JCLM    RMB   3
  185:                                 
  186:                                 *****************
  187:                                 *
  188:                                 * ROM starts here *
  189:                                 *
  190:                                 *****************
  191:                                 
  192:          =0000E000                      ORG  ROMBS ;- $143
  193:                                 
  194:                                 *****************
  195:                                 **  BUFFALO - This is where Buffalo starts
  196:                                 ** out of reset.  All initialization is done
  197:                                 ** here including determination of where the
  198:                                 ** user terminal is (SCI,ACIA, or DUART).
  199:                                 *****************
  200:                                 
  201:     E000 CE 000A                BUFFALO  LDX  #PORTE
  202:     E003 1F 00 01 03                     BRCLR 0,X,#01,BUFISIT ;if bit 0 of port e is 1
  203:     E007 7E B600                         JMP  DSTREE      ;then jump to the start of EEPROM
  204:     E00A 86 93                  BUFISIT  LDAA #$93
  205:     E00C 97 39                           STAA OPTION      ;adpu, dly, irqe, cop
  206:     E00E 86 00                           LDAA #$00
  207:     E010 97 24                           STAA TMSK2       ;timer pre = %1 for trace
  208:     E012 86 00                           LDAA #$00
  209:     E014 97 35                           STAA BPROT       ;clear 'E9 eeprom block protect
  210:     E016 CE B600                         LDX  #DSTREE     ;set up default eeprom address range
  211:     E019 DF AB                           STX  STREE
  212:     E01B CE B7FF                         LDX  #DENDEE
  213:     E01E DF AD                           STX  ENDEE
  214:     E020 CE 0000                         LDX  #$0000      ;set up default download offset
  215:     E023 DF BF                           STX  LDOFFST
  216:     E025 8E 0072                         LDS  #STACK      ;monitor stack pointer
  217:     E028 BD E34D                         JSR  VECINIT
  218:     E02B CE 0054                         LDX  #USTACK
  219:     E02E DF 7C                           STX  SP          ;default user stack
  220:     E030 96 20                           LDAA TCTL1
  221:     E032 8A 03                           ORAA #$03
  222:     E034 97 20                           STAA TCTL1       ;force oc5 pin high for trace
  223:     E036 86 D0                           LDAA #$D0
  224:     E038 97 7B                           STAA REGS+8      ;default user ccr
  225:     E03A CC 3F0D                         LDD  #$3F0D      ;initial command is ?
  226:     E03D DD 7E                           STD  INBUFF
  227:     E03F BD E1B2                         JSR  BPCLR       ;clear breakpoints
  228:     E042 7F 00B7                         CLR  AUTOLF
  229:     E045 7C 00B7                         INC  AUTOLF      ;auto cr/lf = on
  230:                                 
  231:                                 * Determine type of external comm device - none, or acia *
  232:                                 
  233:     E048 7F 00B9                         CLR  EXTDEV      ;default is none
  234:     E04B 96 3C                           LDAA HPRIO
  235:     E04D 84 20                           ANDA #$20
  236:     E04F 27 35                           BEQ  BUFF2       ;jump if single chip mode
  237:     E051 86 03                           LDAA #$03        ;see if external acia exists
  238:     E053 B7 9800                         STAA ACIA        ;master reset
  239:     E056 B6 9800                         LDAA ACIA
  240:     E059 84 7F                           ANDA #$7F        ;mask irq bit from status register
  241:     E05B 26 12                           BNE  BUFF1       ;jump if status reg not 0
  242:     E05D 86 12                           LDAA #$12
  243:     E05F B7 9800                         STAA ACIA        ;turn on acia
  244:     E062 B6 9800                         LDAA ACIA
  245:     E065 84 02                           ANDA #$02
  246:     E067 27 06                           BEQ  BUFF1       ;jump if tdre not set
  247:     E069 86 01                           LDAA #$01
  248:     E06B 97 B9                           STAA EXTDEV      ;external device is acia
  249:     E06D 20 17                           BRA  BUFF2
  250:                                 
  251:          =0000E06F              BUFF1    EQU  *           ;see if duart exists
  252:     E06F B6 D00C                         LDAA  DUART+$0C  ;read IRQ vector register
  253:     E072 81 0F                           CMPA  #$0F       ;should be out of reset
  254:     E074 26 10                           BNE   BUFF2
  255:     E076 86 AA                           LDAA #$AA
  256:     E078 B7 D00C                         STAA DUART+$0C   ;write irq vector register
  257:     E07B B6 D00C                         LDAA DUART+$0C   ;read irq vector register
  258:     E07E 81 AA                           CMPA #$AA
  259:     E080 26 04                           BNE  BUFF2
  260:     E082 86 02                           LDAA #$02
  261:     E084 97 B9                           STAA EXTDEV      ;external device is duart A
  262:                                 
  263:                                 * Find terminal port - SCI or external. *
  264:                                 
  265:     E086 7F 00B8                BUFF2    CLR  IODEV
  266:     E089 BD E345                         JSR  TARGCO    ;disconnect sci for evb board
  267:     E08C BD E0B1                         JSR  SIGNON    ;initialize sci
  268:     E08F 96 B9                           LDAA EXTDEV
  269:     E091 27 05                           BEQ  BUFF3     ;jump if no external device
  270:     E093 97 B8                           STAA IODEV
  271:     E095 BD E0B1                         JSR  SIGNON    ;initialize external device
  272:     E098 7F 00B8                BUFF3    CLR  IODEV
  273:     E09B BD E3A0                         JSR  INPUT     ;get input from sci port
  274:     E09E 81 0D                           CMPA #$0D
  275:     E0A0 27 19                           BEQ  BUFF4     ;jump if cr - sci is terminal port
  276:     E0A2 96 B9                           LDAA EXTDEV
  277:     E0A4 27 F2                           BEQ  BUFF3     ;jump if no external device
  278:     E0A6 97 B8                           STAA IODEV
  279:     E0A8 BD E3A0                         JSR  INPUT     ;get input from external device
  280:     E0AB 81 0D                           CMPA #$0D
  281:     E0AD 27 0C                           BEQ  BUFF4     ;jump if cr - terminal found ext
  282:     E0AF 20 E7                           BRA  BUFF3
  283:                                 
  284:     E0B1 BD E36E                SIGNON   JSR  INIT        ;initialize device
  285:     E0B4 CE E660                         LDX  #MSG1       ;buffalo message
  286:     E0B7 BD E538                         JSR  OUTSTRG
  287:     E0BA 39                              RTS
  288:                                 
  289:                                 * Determine where host port should be. *
  290:                                 
  291:     E0BB 7F 00BA                BUFF4    CLR  HOSTDEV     ;default - host = sci port
  292:     E0BE 96 B8                           LDAA IODEV
  293:     E0C0 81 01                           CMPA #$01
  294:     E0C2 27 04                           BEQ  BUFF5       ;default host if term = acia
  295:     E0C4 86 03                           LDAA #$03
  296:     E0C6 97 BA                           STAA HOSTDEV     ;else host is duart port b
  297:          =0000E0C8              BUFF5    EQU  *
  298:                                 
  299:                                 *****************
  300:                                 **  MAIN - This module reads the user's input into
  301:                                 ** a buffer called INBUFF.  The first field (assumed
  302:                                 ** to be the command field) is then parsed into a
  303:                                 ** second buffer called COMBUFF.  The command table
  304:                                 ** is then searched for the contents of COMBUFF and
  305:                                 ** if found, the address of the corresponding task
  306:                                 ** routine is fetched from the command table.  The
  307:                                 ** task is then called as a subroutine so that
  308:                                 ** control returns back to here upon completion of
  309:                                 ** the task.  Buffalo expects the following format
  310:                                 ** for commands:
  311:                                 **     <cmd>[<wsp><arg><wsp><arg>...]<cr>
  312:                                 ** [] implies contents optional.
  313:                                 ** <wsp> means whitespace character (space,comma,tab).
  314:                                 ** <cmd> = command string of 1-8 characters.
  315:                                 ** <arg> = Argument particular to the command.
  316:                                 ** <cr> = Carriage return signifying end of input string.
  317:                                 *****************
  318:                                 * Prompt user
  319:                                 *do
  320:                                 *   a=input();
  321:                                 *   if(a==(cntlx or del)) continue;
  322:                                 *   elseif(a==backspace)
  323:                                 *      b--;
  324:                                 *      if(b<0) b=0;
  325:                                 *   else
  326:                                 *      if(a==cr && buffer empty)
  327:                                 *         repeat last command;
  328:                                 *      else put a into buffer;
  329:                                 *         check if buffer full;
  330:                                 *while(a != (cr or /)
  331:     E0C8 0F                     MAIN     SEI            ;block interrupts
  332:     E0C9 8E 0072                         LDS  #STACK    ;initialize sp every time
  333:     E0CC 7F 00B7                         CLR  AUTOLF
  334:     E0CF 7C 00B7                         INC  AUTOLF    ;auto cr/lf = on
  335:     E0D2 BD E531                         JSR  OUTCRLF
  336:     E0D5 86 3E                           LDAA #PROMPT   ;prompt user
  337:     E0D7 BD E3F0                         JSR  OUTPUT
  338:     E0DA 5F                              CLRB
  339:     E0DB BD E564                MAIN1    JSR  INCHAR    ;read terminal
  340:     E0DE CE 007E                         LDX  #INBUFF
  341:     E0E1 3A                              ABX            ;pointer into buffer
  342:     E0E2 81 18                           CMPA #CTLX
  343:     E0E4 27 E2                           BEQ  MAIN      ;jump if cntl X
  344:     E0E6 81 7F                           CMPA #DEL
  345:     E0E8 27 DE                           BEQ  MAIN      ;jump if del
  346:     E0EA 81 08                           CMPA #$08
  347:     E0EC 26 05                           BNE  MAIN2     ;jump if not bckspc
  348:     E0EE 5A                              DECB
  349:     E0EF 2D D7                           BLT  MAIN      ;jump if buffer empty
  350:     E0F1 20 E8                           BRA  MAIN1
  351:     E0F3 81 0D                  MAIN2    CMPA #$D
  352:     E0F5 26 07                           BNE  MAIN3     ;jump if not cr
  353:     E0F7 5D                              TSTB
  354:     E0F8 27 17                           BEQ  COMM0     ;jump if buffer empty
  355:     E0FA A7 00                           STAA ,X        ;put a in buffer
  356:     E0FC 20 13                           BRA  COMM0
  357:     E0FE A7 00                  MAIN3    STAA ,X        ;put a in buffer
  358:     E100 5C                              INCB
  359:     E101 C1 23                           CMPB #BUFFLNG
  360:     E103 2F 08                           BLE  MAIN4     ;jump if not long
  361:     E105 CE E6AA                         LDX  #MSG3     ;"long"
  362:     E108 BD E538                         JSR  OUTSTRG
  363:     E10B 20 BB                           BRA  MAIN
  364:     E10D 81 2F                  MAIN4    CMPA #'/'
  365:     E10F 26 CA                           BNE  MAIN1     ;jump if not "/"
  366:                                 *        *******************
  367:                                 
  368:                                 *****************
  369:                                 *  Parse out and evaluate the command field.
  370:                                 *****************
  371:                                 *Initialize
  372:                                 
  373:          =0000E111              COMM0    EQU  *
  374:     E111 7F 00D3                         CLR  TMP1        ;Enable "/" command
  375:     E114 7F 00A9                         CLR  SHFTREG
  376:     E117 7F 00AA                         CLR  SHFTREG+1
  377:     E11A 5F                              CLRB
  378:     E11B CE 007E                         LDX  #INBUFF     ;ptrbuff[] = inbuff[]
  379:     E11E DF C1                           STX  PTR0
  380:     E120 BD E2FC                         JSR  WSKIP       ;find first char
  381:                                 
  382:                                 *while((a=readbuff) != (cr or wspace))
  383:                                 *     upcase(a);
  384:                                 *     buffptr[b] = a
  385:                                 *     b++
  386:                                 *     if (b > 8) error(too long);
  387:                                 *     if(a == "/")
  388:                                 *          if(enabled) mslash();
  389:                                 *          else error(command?);
  390:                                 *     else hexbin(a);
  391:                                 
  392:          =0000E123              COMM1    EQU  *
  393:     E123 BD E2E7                         JSR  READBUFF  ;read from buffer
  394:     E126 CE 00A1                         LDX  #COMBUFF
  395:     E129 3A                              ABX
  396:     E12A BD E1A7                         JSR  UPCASE    ;convert to upper case
  397:     E12D A7 00                           STAA ,X        ;put in command buffer
  398:     E12F 81 0D                           CMPA #$0D
  399:     E131 27 36                           BEQ  SRCH      ;jump if cr
  400:     E133 BD E30C                         JSR  WCHEK
  401:     E136 27 31                           BEQ  SRCH      ;jump if wspac
  402:     E138 BD E2EE                         JSR  INCBUFF   ;move buffer pointer
  403:     E13B 5C                              INCB
  404:     E13C C1 08                           CMPB #$8
  405:     E13E 2F 09                           BLE  COMM2
  406:     E140 CE E6AA                         LDX  #MSG3     ;"long"
  407:     E143 BD E538                         JSR  OUTSTRG
  408:     E146 7E E0C8                         JMP  MAIN
  409:                                 
  410:          =0000E149              COMM2    EQU  *
  411:     E149 81 2F                           CMPA #'/'
  412:     E14B 26 17                           BNE  COMM4       ;jump if not "/"
  413:     E14D 7D 00D3                         TST  TMP1
  414:     E150 26 09                           BNE  COMM3       ;jump if not enabled
  415:     E152 5A                              DECB
  416:     E153 D7 BB                           STAB COUNT
  417:     E155 CE E8E8                         LDX  #MSLASH
  418:     E158 7E E1A2                         JMP  EXEC        ;execute "/"
  419:     E15B CE E6C2                COMM3    LDX  #MSG8       ;"command?"
  420:     E15E BD E538                         JSR  OUTSTRG
  421:     E161 7E E0C8                         JMP  MAIN
  422:          =0000E164              COMM4    EQU  *
  423:     E164 BD E201                         JSR  HEXBIN
  424:     E167 20 BA                           BRA  COMM1
  425:                                 
  426:                                 *****************
  427:                                 *   Search tables for command.  At this point,
  428:                                 * COMBUFF holds the command field to be executed,
  429:                                 * and B = # of characters in the command field.
  430:                                 * The command table holds the whole command name
  431:                                 * but only the first n characters of the command
  432:                                 * must match what is in COMBUFF where n is the
  433:                                 * number of characters entered by the user.
  434:                                 *****************
  435:                                 *count = b;
  436:                                 *ptr1 = comtabl;
  437:                                 *while(ptr1[0] != end of table)
  438:                                 *   ptr1 = next entry
  439:                                 *   for(b=1; b=count; b++)
  440:                                 *      if(ptr1[b] == combuff[b]) continue;
  441:                                 *      else error(not found);
  442:                                 *   execute task;
  443:                                 *  return();
  444:                                 *return(command not found);
  445:                                 
  446:     E169 D7 BB                  SRCH    STAB COUNT     ;size of command entered
  447:     E16B CE E56E                        LDX  #COMTABL  ;pointer to table
  448:     E16E DF C3                          STX  PTR1      ;pointer to next entry
  449:     E170 DE C3                  SRCH1   LDX  PTR1
  450:     E172 18CE 00A1                      LDY  #COMBUFF  ;pointer to command buffer
  451:     E176 E6 00                          LDAB 0,X
  452:     E178 C1 FF                          CMPB #$FF
  453:     E17A 26 09                          BNE  SRCH2
  454:     E17C CE E6A4                        LDX  #MSG2     ;"command not found"
  455:     E17F BD E538                        JSR  OUTSTRG
  456:     E182 7E E0C8                        JMP  MAIN
  457:     E185 3C                     SRCH2   PSHX            ;compute next table entry
  458:     E186 CB 03                          ADDB #$3
  459:     E188 3A                             ABX
  460:     E189 DF C3                          STX  PTR1
  461:     E18B 38                             PULX
  462:     E18C 5F                             CLRB
  463:     E18D 5C                     SRCHLP  INCB            ;match characters loop
  464:     E18E A6 01                          LDAA 1,X        ;read table
  465:     E190 18A1 00                        CMPA 0,Y        ;compare to combuff
  466:     E193 26 DB                          BNE  SRCH1      ;try next entry
  467:     E195 08                             INX             ;move pointers
  468:     E196 1808                           INY
  469:     E198 D1 BB                          CMPB COUNT
  470:     E19A 2D F1                          BLT  SRCHLP     ;loop countu1 times
  471:     E19C DE C3                          LDX  PTR1
  472:     E19E 09                             DEX
  473:     E19F 09                             DEX
  474:     E1A0 EE 00                          LDX  0,X     ;jump address from table
  475:     E1A2 AD 00                  EXEC    JSR  0,X     ;call task as subroutine
  476:     E1A4 7E E0C8                        JMP  MAIN
  477:                                 *
  478:                                 *****************
  479:                                 *   UTILITY SUBROUTINES - These routines
  480:                                 * are called by any of the task routines.
  481:                                 *****************
  482:                                 *****************
  483:                                 *  UPCASE(a) - If the contents of A is alpha,
  484:                                 * returns a converted to uppercase.
  485:                                 *****************
  486:     E1A7 81 61                  UPCASE   CMPA #'a'
  487:     E1A9 2D 06                           BLT  UPCASE1      ;jump if < a
  488:     E1AB 81 7A                           CMPA #'z'
  489:     E1AD 2E 02                           BGT  UPCASE1      ;jump if > z
  490:     E1AF 80 20                           SUBA #$20         ;convert
  491:     E1B1 39                     UPCASE1  RTS
  492:                                 
  493:                                 *****************
  494:                                 *  BPCLR() - Clear all entries in the
  495:                                 * table of breakpoints.
  496:                                 *****************
  497:     E1B2 CE 00AF                BPCLR    LDX  #BRKTABL
  498:     E1B5 C6 08                           LDAB #8
  499:     E1B7 6F 00                  BPCLR1   CLR  0,X
  500:     E1B9 08                              INX
  501:     E1BA 5A                              DECB
  502:     E1BB 2E FA                           BGT  BPCLR1      ;loop 8 times
  503:     E1BD 39                              RTS
  504:                                 
  505:                                 *****************
  506:                                 *  RPRNT1(x) - Prints name and contents of a single
  507:                                 * user register. On entry X points to name of register
  508:                                 * in reglist.  On exit, a=register name.
  509:                                 *****************
  510:     E1BE 50 59 58 41 42 43      REGLIST  FCC  'PYXABCS'       ;names
           E1C4 53 
  511:     E1C5 00 02 04 06 07 08               FCB  0,2,4,6,7,8,9   ;offset
           E1CB 09 
  512:     E1CC 01 01 01 00 00 00               FCB  1,1,1,0,0,0,1   ;size
           E1D2 01 
  513:     E1D3 A6 00                  RPRNT1   LDAA 0,X
  514:     E1D5 36                              PSHA
  515:     E1D6 3C                              PSHX
  516:     E1D7 BD E3F0                         JSR  OUTPUT      ;name
  517:     E1DA 86 2D                           LDAA #'-'
  518:     E1DC BD E3F0                         JSR  OUTPUT      ;dash
  519:     E1DF E6 07                           LDAB 7,X         ;contents offset
  520:     E1E1 A6 0E                           LDAA 14,X        ;bytesize
  521:     E1E3 CE 0073                         LDX  #REGS       ;address
  522:     E1E6 3A                              ABX
  523:     E1E7 4D                              TSTA
  524:     E1E8 27 03                           BEQ  RPRN2       ;jump if 1 byte
  525:     E1EA BD E50D                         JSR  OUT1BYT     ;2 bytes
  526:     E1ED BD E51C                RPRN2    JSR  OUT1BSP
  527:     E1F0 38                              PULX
  528:     E1F1 32                              PULA
  529:     E1F2 39                              RTS
  530:                                 
  531:                                 *****************
  532:                                 *  RPRINT() - Print the name and contents
  533:                                 * of all the user registers.
  534:                                 *****************
  535:     E1F3 3C                     RPRINT   PSHX
  536:     E1F4 CE E1BE                         LDX  #REGLIST
  537:     E1F7 BD E1D3                RPRI1    JSR  RPRNT1      ;print name
  538:     E1FA 08                              INX
  539:     E1FB 81 53                           CMPA #'S'        ;s is last register
  540:     E1FD 26 F8                           BNE  RPRI1       ;jump if not done
  541:     E1FF 38                              PULX
  542:     E200 39                              RTS
  543:                                 
  544:                                 *****************
  545:                                 *   HEXBIN(a) - Convert the ASCII character in a
  546:                                 * to binary and shift into shftreg.  Returns value
  547:                                 * in tmp1 incremented if a is not hex.
  548:                                 *****************
  549:     E201 36                     HEXBIN  PSHA
  550:     E202 37                             PSHB
  551:     E203 3C                             PSHX
  552:     E204 BD E1A7                        JSR  UPCASE     ;convert to upper case
  553:     E207 81 30                          CMPA #'0'
  554:     E209 2D 22                          BLT  HEXNOT     ;jump if a < $30
  555:     E20B 81 39                          CMPA #'9'
  556:     E20D 2F 0A                          BLE  HEXNMB     ;jump if 0-9
  557:     E20F 81 41                          CMPA #'A'
  558:     E211 2D 1A                          BLT  HEXNOT     ;jump if $39> a <$41
  559:     E213 81 46                          CMPA #'F'
  560:     E215 2E 16                          BGT  HEXNOT     ;jump if a > $46
  561:     E217 8B 09                          ADDA #$9        ;convert $A-$F
  562:     E219 84 0F                  HEXNMB  ANDA #$0F       ;convert to binary
  563:     E21B CE 00A9                        LDX  #SHFTREG
  564:     E21E C6 04                          LDAB #4
  565:     E220 68 01                  HEXSHFT ASL  1,X        ;2 byte shift through
  566:     E222 69 00                          ROL  0,X        ;       carry bit
  567:     E224 5A                             DECB
  568:     E225 2E F9                          BGT  HEXSHFT    ;shift 4 times
  569:     E227 AA 01                          ORAA 1,X
  570:     E229 A7 01                          STAA 1,X
  571:     E22B 20 03                          BRA  HEXRTS
  572:     E22D 7C 00D3                HEXNOT  INC  TMP1       ;indicate not hex
  573:     E230 38                     HEXRTS  PULX
  574:     E231 33                             PULB
  575:     E232 32                             PULA
  576:     E233 39                             RTS
  577:                                 
  578:                                 *****************
  579:                                 *  BUFFARG() - Build a hex argument from the
  580:                                 * contents of the input buffer. Characters are
  581:                                 * converted to binary and shifted into shftreg
  582:                                 * until a non-hex character is found.  On exit
  583:                                 * shftreg holds the last four digits read, count
  584:                                 * holds the number of digits read, ptrbuff points
  585:                                 * to the first non-hex character read, and A holds
  586:                                 * that first non-hex character.
  587:                                 *****************
  588:                                 *Initialize
  589:                                 *while((a=readbuff()) not hex)
  590:                                 *     hexbin(a);
  591:                                 *return();
  592:                                 
  593:     E234 7F 00D3                BUFFARG  CLR  TMP1        ;not hex indicator
  594:     E237 7F 00BB                         CLR  COUNT       ;# or digits
  595:     E23A 7F 00A9                         CLR  SHFTREG
  596:     E23D 7F 00AA                         CLR  SHFTREG+1
  597:     E240 BD E2FC                         JSR  WSKIP
  598:     E243 BD E2E7                BUFFLP   JSR  READBUFF    ;read char
  599:     E246 BD E201                         JSR  HEXBIN
  600:     E249 7D 00D3                         TST  TMP1
  601:     E24C 26 08                           BNE  BUFFRTS     ;jump if not hex
  602:     E24E 7C 00BB                         INC  COUNT
  603:     E251 BD E2EE                         JSR  INCBUFF     ;move buffer pointer
  604:     E254 20 ED                           BRA  BUFFLP
  605:     E256 39                     BUFFRTS  RTS
  606:                                 
  607:                                 *****************
  608:                                 *  TERMARG() - Build a hex argument from the
  609:                                 * terminal.  Characters are converted to binary
  610:                                 * and shifted into shftreg until a non-hex character
  611:                                 * is found.  On exit shftreg holds the last four
  612:                                 * digits read, count holds the number of digits
  613:                                 * read, and A holds the first non-hex character.
  614:                                 *****************
  615:                                 *initialize
  616:                                 *while((a=inchar()) == hex)
  617:                                 *     if(a = cntlx or del)
  618:                                 *          abort;
  619:                                 *     else
  620:                                 *          hexbin(a); countu1++;
  621:                                 *return();
  622:                                 
  623:     E257 7F 00BB                TERMARG  CLR  COUNT
  624:     E25A 7F 00A9                         CLR  SHFTREG
  625:     E25D 7F 00AA                         CLR  SHFTREG+1
  626:     E260 BD E564                TERM0    JSR  INCHAR
  627:     E263 81 18                           CMPA #CTLX
  628:     E265 27 04                           BEQ  TERM1     ;jump if controlx
  629:     E267 81 7F                           CMPA #DEL
  630:     E269 26 03                           BNE  TERM2     ;jump if not delete
  631:     E26B 7E E0C8                TERM1    JMP  MAIN      ;abort
  632:     E26E 7F 00D3                TERM2    CLR  TMP1      ;hex indicator
  633:     E271 BD E201                         JSR  HEXBIN
  634:     E274 7D 00D3                         TST  TMP1
  635:     E277 26 05                           BNE  TERM3     ;jump if not hex
  636:     E279 7C 00BB                         INC  COUNT
  637:     E27C 20 E2                           BRA  TERM0
  638:     E27E 39                     TERM3    RTS
  639:                                 
  640:                                 *****************
  641:                                 *   CHGBYT() - If shftreg is not empty, put
  642:                                 * contents of shftreg at address in X.  If X
  643:                                 * is an address in EEPROM then program it.
  644:                                 *****************
  645:                                 *if(count != 0)
  646:                                 *   (x) = a;
  647:     E27F 7D 00BB                CHGBYT   TST  COUNT
  648:     E282 27 05                           BEQ  CHGBYT4   ;quit if shftreg empty
  649:     E284 96 AA                           LDAA SHFTREG+1 ;get data into a
  650:     E286 BD E28A                         JSR  WRITE
  651:     E289 39                     CHGBYT4  RTS
  652:                                 
  653:                                 
  654:                                 *****************
  655:                                 * WRITE() - This routine is used to write the
  656:                                 *contents of A to the address of X.  If the
  657:                                 *address is in EEPROM, it will be programmed
  658:                                 *and if it is already programmed, it will be
  659:                                 *byte erased first.
  660:                                 ******************
  661:                                 *if(X == config) then
  662:                                 *   byte erase config;
  663:                                 *if(X is eeprom)then
  664:                                 *   if(not erased) then erase;
  665:                                 *   program (x) = A;
  666:                                 *write (x) = A;
  667:                                 *if((x) != A) error(rom);
  668:          =0000E28A              WRITE   EQU  *
  669:     E28A 8C 003F                        CPX  #CONFIG
  670:     E28D 27 10                          BEQ  WRITE0     ;jump if config
  671:     E28F 9C AB                          CPX  STREE      ;start of EE
  672:     E291 25 12                          BLO  WRITE2     ;jump if not EE
  673:     E293 9C AD                          CPX  ENDEE      ;end of EE
  674:     E295 22 0E                          BHI  WRITE2     ;jump if not EE
  675:     E297 37                     WRITEE  PSHB            ;check if byte erased
  676:     E298 E6 00                          LDAB 0,X
  677:     E29A C1 FF                          CMPB #$FF
  678:     E29C 33                             PULB
  679:     E29D 27 03                          BEQ  WRITE1     ;jump if erased
  680:     E29F BD E2BF                WRITE0  JSR  EEBYTE     ;byte erase
  681:     E2A2 BD E2B4                WRITE1  JSR  EEWRIT     ;byte program
  682:     E2A5 A7 00                  WRITE2  STAA 0,X        ;write for non EE
  683:     E2A7 A1 00                          CMPA 0,X
  684:     E2A9 27 08                          BEQ  WRITE3     ;jump if write ok
  685:     E2AB 3C                             PSHX
  686:     E2AC CE E6BD                        LDX  #MSG6      ;"rom"
  687:     E2AF BD E538                        JSR  OUTSTRG
  688:     E2B2 38                             PULX
  689:     E2B3 39                     WRITE3  RTS
  690:                                 
  691:                                 
  692:                                 *****************
  693:                                 *   EEWRIT(), EEBYTE(), EEBULK() -
  694:                                 * These routines are used to program and eeprom
  695:                                 *locations.  eewrite programs the address in X with
  696:                                 *the value in A, eebyte does a byte address at X,
  697:                                 *and eebulk does a bulk of eeprom.  Whether eebulk
  698:                                 *erases the config or not depends on the address it
  699:                                 *receives in X.
  700:                                 ****************
  701:          =0000E2B4              EEWRIT  EQU  *          ;program one byte at x
  702:     E2B4 37                             PSHB
  703:     E2B5 C6 02                          LDAB #$02
  704:     E2B7 D7 3B                          STAB PPROG
  705:     E2B9 A7 00                          STAA 0,X
  706:     E2BB C6 03                          LDAB #$03
  707:     E2BD 20 16                          BRA  EEPROG
  708:                                 ***
  709:          =0000E2BF              EEBYTE  EQU  *          ;byte erase address x
  710:     E2BF 37                             PSHB
  711:     E2C0 C6 16                          LDAB #$16
  712:     E2C2 D7 3B                          STAB PPROG
  713:     E2C4 C6 FF                          LDAB #$FF
  714:     E2C6 E7 00                          STAB 0,X
  715:     E2C8 C6 17                          LDAB #$17
  716:     E2CA 20 09                          BRA  EEPROG
  717:                                 ***
  718:          =0000E2CC              EEBULK  EQU  *          ;bulk erase eeprom
  719:     E2CC 37                             PSHB
  720:     E2CD C6 06                          LDAB #$06
  721:     E2CF D7 3B                          STAB PPROG
  722:     E2D1 A7 00                          STAA 0,X        ;erase config or not ...
  723:     E2D3 C6 07                          LDAB #$07       ;  ... depends on X addr
  724:     E2D5 26 01                  EEPROG  BNE  ACL1
  725:     E2D7 5F                             CLRB            ;fail safe
  726:     E2D8 D7 3B                  ACL1    STAB PPROG
  727:     E2DA 33                             PULB
  728:                                 ***
  729:          =0000E2DB              DLY10MS EQU  *          ;delay 10ms at E = 2MHz
  730:     E2DB 3C                             PSHX
  731:     E2DC CE 0D06                        LDX  #$0D06
  732:     E2DF 09                     DLYLP   DEX
  733:     E2E0 26 FD                          BNE  DLYLP
  734:     E2E2 38                             PULX
  735:     E2E3 7F 003B                        CLR  PPROG
  736:     E2E6 39                             RTS
  737:                                 
  738:                                 
  739:                                 *****************
  740:                                 *  READBUFF() -  Read the character in INBUFF
  741:                                 * pointed at by ptrbuff into A.  Returns ptrbuff
  742:                                 * unchanged.
  743:                                 *****************
  744:     E2E7 3C                     READBUFF PSHX
  745:     E2E8 DE C1                           LDX  PTR0
  746:     E2EA A6 00                           LDAA 0,X
  747:     E2EC 38                              PULX
  748:     E2ED 39                              RTS
  749:                                 
  750:                                 *****************
  751:                                 *  INCBUFF(), DECBUFF() - Increment or decrement
  752:                                 * ptrbuff.
  753:                                 *****************
  754:     E2EE 3C                     INCBUFF  PSHX
  755:     E2EF DE C1                           LDX  PTR0
  756:     E2F1 08                              INX
  757:     E2F2 20 04                           BRA  INCDEC
  758:     E2F4 3C                     DECBUFF  PSHX
  759:     E2F5 DE C1                           LDX  PTR0
  760:     E2F7 09                              DEX
  761:     E2F8 DF C1                  INCDEC   STX  PTR0
  762:     E2FA 38                              PULX
  763:     E2FB 39                              RTS
  764:                                 
  765:                                 *****************
  766:                                 *  WSKIP() - Read from the INBUFF until a
  767:                                 * non whitespace (space, comma, tab) character
  768:                                 * is found.  Returns ptrbuff pointing to the
  769:                                 * first non-whitespace character and a holds
  770:                                 * that character.  WSKIP also compares a to
  771:                                 * $0D (CR) and cond codes indicating the
  772:                                 * results of that compare.
  773:                                 *****************
  774:     E2FC BD E2E7                WSKIP    JSR  READBUFF  ;read character
  775:     E2FF BD E30C                         JSR  WCHEK
  776:     E302 26 05                           BNE  WSKIP1    ;jump if not wspc
  777:     E304 BD E2EE                         JSR  INCBUFF   ;move pointer
  778:     E307 20 F3                           BRA  WSKIP     ;loop
  779:     E309 81 0D                  WSKIP1   CMPA #$0D
  780:     E30B 39                              RTS
  781:                                 
  782:                                 *****************
  783:                                 *  WCHEK(a) - Returns z=1 if a holds a
  784:                                 * whitespace character, else z=0.
  785:                                 *****************
  786:     E30C 81 2C                  WCHEK    CMPA #$2C      ;comma
  787:     E30E 27 06                           BEQ  WCHEK1
  788:     E310 81 20                           CMPA #$20      ;space
  789:     E312 27 02                           BEQ  WCHEK1
  790:     E314 81 09                           CMPA #$09      ;tab
  791:     E316 39                     WCHEK1   RTS
  792:                                 
  793:                                 *****************
  794:                                 *   DCHEK(a) - Returns Z=1 if a = whitespace
  795:                                 * or carriage return.  Else returns z=0.
  796:                                 *****************
  797:     E317 BD E30C                DCHEK   JSR  WCHEK
  798:     E31A 27 02                          BEQ  DCHEK1     ;jump if whitespace
  799:     E31C 81 0D                          CMPA #$0D
  800:     E31E 39                     DCHEK1  RTS
  801:                                 
  802:                                 *****************
  803:                                 *  CHKABRT() - Checks for a control x or delete
  804:                                 * from the terminal.  If found, the stack is
  805:                                 * reset and the control is transferred to main.
  806:                                 * Note that this is an abnormal termination.
  807:                                 *   If the input from the terminal is a control W
  808:                                 * then this routine keeps waiting until any other
  809:                                 * character is read.
  810:                                 *****************
  811:                                 *a=input();
  812:                                 *if(a=cntl w) wait until any other key;
  813:                                 *if(a = cntl x or del) abort;
  814:                                 
  815:     E31F BD E3A0                CHKABRT  JSR  INPUT
  816:     E322 27 18                           BEQ  CHK4      ;jump if no input
  817:     E324 81 17                           CMPA #CTLW
  818:     E326 26 05                           BNE  CHK2      ;jump in not cntlw
  819:     E328 BD E3A0                CHKABRT1 JSR  INPUT
  820:     E32B 27 FB                           BEQ  CHKABRT1  ;jump if no input
  821:     E32D 81 7F                  CHK2     CMPA #DEL
  822:     E32F 27 08                           BEQ  CHK3      ;jump if delete
  823:     E331 81 18                           CMPA #CTLX
  824:     E333 27 04                           BEQ  CHK3      ;jump if control x
  825:     E335 81 01                           CMPA #CTLA
  826:     E337 26 03                           BNE  CHK4      ;jump not control a
  827:     E339 7E E0C8                CHK3     JMP  MAIN      ;abort
  828:     E33C 39                     CHK4     RTS            ;return
  829:                                 
  830:                                 ***********************
  831:                                 *  HOSTCO - connect sci to host for evb board.
  832:                                 *  TARGCO - connect sci to target for evb board.
  833:                                 ***********************
  834:     E33D 36                     HOSTCO   PSHA
  835:     E33E 86 01                           LDAA #$01
  836:     E340 B7 4000                         STAA DFLOP     ;send 1 to d-flop
  837:     E343 32                              PULA
  838:     E344 39                              RTS
  839:                                 
  840:     E345 36                     TARGCO   PSHA
  841:     E346 86 00                           LDAA #$00
  842:     E348 B7 4000                         STAA DFLOP     ;send 0 to d-flop
  843:     E34B 32                              PULA
  844:     E34C 39                              RTS
  845:                                 
  846:                                 *
  847:                                 **********
  848:                                 *
  849:                                 *     VECINIT - This routine checks for
  850:                                 *        vectors in the RAM table.  All
  851:                                 *        uninitialized vectors are programmed
  852:                                 *        to JMP STOPIT
  853:                                 *
  854:                                 **********
  855:                                 *
  856:     E34D CE 00D7                VECINIT  LDX  #JSCI     ;Point to First RAM Vector
  857:     E350 18CE E367                       LDY  #STOPIT   ;Pointer to STOPIT routine
  858:     E354 CC 7E03                         LDD  #$7E03    ;A=JMP opcode; B=offset
  859:     E357 A1 00                  VECLOOP  CMPA 0,X
  860:     E359 27 05                           BEQ  VECNEXT   ;If vector already in
  861:     E35B A7 00                           STAA 0,X       ;install JMP
  862:     E35D 1AEF 01                         STY  1,X       ;to STOPIT routine
  863:     E360 3A                     VECNEXT  ABX            ;Add 3 to point at next vector
  864:     E361 8C 0113                         CPX  #JCLM+3   ;Done?
  865:     E364 26 F1                           BNE  VECLOOP   ;If not, continue loop
  866:     E366 39                              RTS
  867:                                 *
  868:     E367 86 50                  STOPIT   LDAA #$50      ;Stop-enable; IRQ, XIRQ-Off
  869:     E369 06                              TAP
  870:     E36A CF                              STOP           ;You are lost!  Shut down
  871:     E36B 7E E367                         JMP  STOPIT    ;In case continue by XIRQ
  872:                                 
  873:                                 **********
  874:                                 *
  875:                                 *   I/O MODULE
  876:                                 *     Communications with the outside world.
  877:                                 * 3 I/O routines (INIT, INPUT, and OUTPUT) call
  878:                                 * drivers specified by IODEV (0=SCI, 1=ACIA,
  879:                                 * 2=DUARTA, 3=DUARTB).
  880:                                 *
  881:                                 **********
  882:                                 *   INIT() - Initialize device specified by iodev.
  883:                                 *********
  884:                                 *
  885:          =0000E36E              INIT     EQU  *
  886:     E36E 36                              PSHA        ;save registers
  887:     E36F 86 40                          ldaa #$40
  888:                                 ;       ldaa #(29 | $40)
  889:     E371 97 38                          staa $38
  890:     E373 86 80                          ldaa #$80
  891:     E375 97 38                          staa $38
  892:     E377 86 13                          ldaa #$13
  893:     E379 97 38                          staa $38         
  894:     E37B 3C                             PSHX
  895:     E37C 96 B8                           LDAA IODEV
  896:     E37E 81 00                           CMPA #$00
  897:     E380 26 05                           BNE  INIT1    ;jump not sci
  898:     E382 BD E46A                         JSR  ONSCI     ;initialize sci
  899:     E385 20 16                           BRA  INIT4
  900:     E387 81 01                  INIT1    CMPA #$01
  901:     E389 26 05                           BNE  INIT2     ;jump not acia
  902:     E38B BD E4A5                         JSR  ONACIA    ;initialize acia
  903:     E38E 20 0D                           BRA  INIT4
  904:     E390 CE D000                INIT2    LDX  #PORTA
  905:     E393 81 02                           CMPA #$02
  906:     E395 27 03                           BEQ  INIT3     ;jump duart a
  907:     E397 CE D008                         LDX  #PORTB
  908:     E39A BD E414                INIT3    JSR  ONUART    ;initialize duart
  909:     E39D 38                     INIT4    PULX         ;restore registers
  910:     E39E 32                              PULA
  911:     E39F 39                              RTS
  912:                                 
  913:                                 **********
  914:                                 *  INPUT() - Read device. Returns a=char or 0.
  915:                                 *    This routine also disarms the cop.
  916:                                 **********
  917:          =0000E3A0              INPUT    EQU  *
  918:     E3A0 3C                              PSHX
  919:                                 ;         LDAA #$55    ;reset cop
  920:                                 ;         STAA COPRST
  921:                                 ;         LDAA #$AA
  922:                                 ;         STAA COPRST
  923:     E3A1 96 38                          ldaa $38
  924:     E3A3 2A 04                          bpl input1x
  925:     E3A5 96 37                          ldaa $37
  926:     E3A7 20 1F                          bra input4
  927:     E3A9                        input1x
  928:     E3A9 96 B8                           LDAA IODEV
  929:     E3AB 26 05                           BNE  INPUT1    ;jump not sci
  930:     E3AD BD E47A                         JSR  INSCI     ;read sci
  931:     E3B0 20 16                           BRA  INPUT4
  932:     E3B2 81 01                  INPUT1   CMPA #$01
  933:     E3B4 26 05                           BNE  INPUT2    ;jump not acia
  934:     E3B6 BD E4B1                         JSR  INACIA    ;read acia
  935:     E3B9 20 0D                           BRA  INPUT4
  936:     E3BB CE D000                INPUT2   LDX  #PORTA
  937:     E3BE 81 02                           CMPA #$02
  938:     E3C0 27 03                           BEQ  INPUT3    ;jump if duart a
  939:     E3C2 CE D008                         LDX  #PORTB
  940:     E3C5 BD E43F                INPUT3   JSR  INUART    ;read uart
  941:     E3C8 38                     INPUT4   PULX
  942:     E3C9 39                              RTS
  943:                                 
  944:                                 **********
  945:                                 *   OUTPUT() - Output character in A.
  946:                                 * chrcnt indicates the current column on the
  947:                                 *output display.  It is incremented every time
  948:                                 *a character is outputted, and cleared whenever
  949:                                 *the subroutine outcrlf is called.
  950:                                 **********
  951:                                 
  952:          =0000E3CA              OUTPUT_v1   EQU  *
  953:     E3CA 36                              PSHA         ;save registers
  954:     E3CB 37                              PSHB
  955:     E3CC 3C                              PSHX
  956:     E3CD D6 B8                           LDAB IODEV
  957:     E3CF 26 05                           BNE  OUTPUT1   ;jump not sci
  958:     E3D1 BD E485                         JSR  OUTSCI    ;write sci
  959:     E3D4 20 16                           BRA  OUTPUT4
  960:     E3D6 C1 01                  OUTPUT1  CMPB #$01
  961:     E3D8 26 05                           BNE  OUTPUT2   ;jump not acia
  962:     E3DA BD E4CB                         JSR  OUTACIA   ;write acia
  963:     E3DD 20 0D                           BRA  OUTPUT4
  964:     E3DF CE D000                OUTPUT2  LDX  #PORTA
  965:     E3E2 C1 02                           CMPB #$02
  966:     E3E4 27 03                           BEQ  OUTPUT3   ;jump if duart a
  967:     E3E6 CE D008                         LDX  #PORTB
  968:     E3E9 BD E44A                OUTPUT3  JSR  OUTUART   ;write uart
  969:     E3EC 38                     OUTPUT4  PULX
  970:     E3ED 33                              PULB
  971:     E3EE 32                              PULA
  972:                                 ;         INC  CHRCNT    ;increment column count
  973:     E3EF 39                             rts
  974:          =0000E3F0              OUTPUT   EQU  *
  975:     E3F0 BD E3CA                        jsr output_v1
  976:     E3F3 36                             psha
  977:     E3F4 81 08                          cmpa #$08       ;backspace
  978:     E3F6 27 09                          beq outputx1    ;jump if backspace
  979:     E3F8 81 0D                          cmpa #$0d       ;newline
  980:     E3FA 26 11                          bne outputx2    ;jump if not newline
  981:     E3FC BD E525                        jsr outcrlfv2   ;newline
  982:     E3FF 32                             pula
  983:     E400 39                             rts
  984:     E401                        outputx1 ; backspace
  985:                                 ;       pshb
  986:     E401 7D 00BC                        tst chrcnt
  987:     E404 27 0C                          beq outputx3
  988:     E406 7A 00BC                        dec chrcnt
  989:                                 ;       ldaa chrcnt
  990:                                 ;       oraa #$80       ;column set mask
  991:                                 ;       staa $38
  992:     E409 97 37                          staa $37
  993:                                 ;       ldab #$11
  994:                                 ;       stab $38
  995:                                 ;       staa $37
  996:                                 ;       pulb
  997:     E40B 32                             pula
  998:     E40C 39                             rts
  999:     E40D                        outputx2
 1000:     E40D 97 37                          staa $37
 1001:     E40F 7C 00BC                        inc chrcnt
 1002:                                 ;       ldaa #80
 1003:                                 ;       cmpa chrcnt
 1004:                                 ;       bne outputx3
 1005:                                 ;       ldaa #$80
 1006:                                 ;       staa $38        ; column zero
 1007:                                 ;       ldaa #$10
 1008:                                 ;       staa $38        ; scroll one line
 1009:                                 ;       clr chrcnt
 1010:     E412                        outputx3
 1011:     E412 32                             pula
 1012:     E413 39                              RTS
 1013:                                 
 1014:                                 **********
 1015:                                 *   ONUART(port) - Initialize a duart port.
 1016:                                 * Sets duart to internal clock, divide by 16,
 1017:                                 * 8 data + 1 stop bits.
 1018:                                 **********
 1019:                                 
 1020:     E414 86 22                  ONUART   LDAA #$22
 1021:     E416 A7 02                           STAA 2,X         ;reset receiver
 1022:     E418 86 38                           LDAA #$38
 1023:     E41A A7 02                           STAA 2,X         ;reset transmitter
 1024:     E41C 86 40                           LDAA #$40
 1025:     E41E A7 02                           STAA 2,X         ;reset error status
 1026:     E420 86 10                           LDAA #$10
 1027:     E422 A7 02                           STAA 2,X         ;reset pointer
 1028:     E424 86 00                           LDAA #$00
 1029:     E426 B7 D004                         STAA DUART+4     ;clock source
 1030:     E429 86 00                           LDAA #$00
 1031:     E42B B7 D005                         STAA DUART+5     ;interrupt mask
 1032:     E42E 86 13                           LDAA #$13
 1033:     E430 A7 00                           STAA 0,X         ;8 data, no parity
 1034:     E432 86 07                           LDAA #$07
 1035:     E434 A7 00                           STAA 0,X         ;1 stop bits
 1036:     E436 86 BB                           LDAA #$BB        ;baud rate (9600)
 1037:     E438 A7 01                           STAA 1,X         ;tx and rcv baud rate
 1038:     E43A 86 05                           LDAA #$05
 1039:     E43C A7 02                           STAA 2,X         ;enable tx and rcv
 1040:     E43E 39                              RTS
 1041:                                 
 1042:                                 **********
 1043:                                 *   INUART(port) - Check duart for any input.
 1044:                                 **********
 1045:     E43F A6 01                  INUART   LDAA 1,X         ;read status
 1046:     E441 84 01                           ANDA #$01        ;check rxrdy
 1047:     E443 27 04                           BEQ  INUART1     ;jump if no data
 1048:     E445 A6 03                           LDAA 3,X         ;read data
 1049:     E447 84 7F                           ANDA #$7F        ;mask parity
 1050:     E449 39                     INUART1  RTS
 1051:                                 
 1052:                                 **********
 1053:                                 *   OUTUART(port) - Output the character in a.
 1054:                                 *        if autolf=1, transmits cr or lf as crlf.
 1055:                                 **********
 1056:     E44A 7D 00B7                OUTUART  TST  AUTOLF
 1057:     E44D 27 10                           BEQ  OUTUART2    ;jump if no autolf
 1058:     E44F 8D 0E                           BSR  OUTUART2
 1059:     E451 81 0D                           CMPA #$0D
 1060:     E453 26 04                           BNE  OUTUART1
 1061:     E455 86 0A                           LDAA #$0A        ;if cr, output lf
 1062:     E457 20 06                           BRA  OUTUART2
 1063:     E459 81 0A                  OUTUART1 CMPA #$0A
 1064:     E45B 26 0C                           BNE  OUTUART3
 1065:     E45D 86 0D                           LDAA #$0D        ;if lf, output cr
 1066:     E45F E6 01                  OUTUART2 LDAB 1,X         ;check status
 1067:     E461 C4 04                           ANDB #$4
 1068:     E463 27 FA                           BEQ  OUTUART2    ;loop until tdre=1
 1069:     E465 84 7F                           ANDA #$7F        ;mask parity
 1070:     E467 A7 03                           STAA 3,X         ;send character
 1071:     E469 39                     OUTUART3 RTS
 1072:                                 
 1073:                                 **********
 1074:                                 *   ONSCI() - Initialize the SCI for 9600
 1075:                                 *                 baud at 8 MHz Extal.
 1076:                                 **********
 1077:     E46A                        ONSCI
 1078:                                 ;         LDAA #$30
 1079:                                 ;         STAA BAUD        ;baud register
 1080:     E46A 3C                             pshx
 1081:     E46B CE 051F                        ldx #1311 ; 25.175 MHz / 9600 baud / 2 = 1311
 1082:     E46E DF 35                          stx $35   ; new CPB register
 1083:     E470 38                             pulx
 1084:     E471 86 00                           LDAA #$00
 1085:     E473 97 2C                           STAA SCCR1
 1086:     E475 86 0C                           LDAA #$0C
 1087:     E477 97 2D                           STAA SCCR2       ;enable
 1088:     E479 39                              RTS
 1089:                                 
 1090:                                 **********
 1091:                                 *   INSCI() - Read from SCI.  Return a=char or 0.
 1092:                                 **********
 1093:     E47A 96 2E                  INSCI    LDAA SCSR      ;read status reg
 1094:     E47C 84 20                           ANDA #$20      ;check rdrf
 1095:     E47E 27 04                           BEQ  INSCI1    ;jump if no data
 1096:     E480 96 2F                           LDAA SCDAT     ;read data
 1097:     E482 84 7F                           ANDA #$7F      ;mask parity
 1098:     E484 39                     INSCI1   RTS
 1099:                                 
 1100:                                 **********
 1101:                                 *  OUTSCI() - Output A to sci. IF autolf = 1,
 1102:                                 *               cr and lf sent as crlf.
 1103:                                 **********
 1104:     E485 7D 00B7                OUTSCI   TST  AUTOLF
 1105:     E488 27 10                           BEQ  OUTSCI2     ;jump if autolf=0
 1106:     E48A 8D 0E                           BSR  OUTSCI2
 1107:     E48C 81 0D                           CMPA #$0D
 1108:     E48E 26 04                           BNE  OUTSCI1
 1109:     E490 86 0A                           LDAA #$0A        ;if cr, send lf
 1110:     E492 20 06                           BRA  OUTSCI2
 1111:     E494 81 0A                  OUTSCI1  CMPA #$0A
 1112:     E496 26 0C                           BNE  OUTSCI3
 1113:     E498 86 0D                           LDAA #$0D        ;if lf, send cr
 1114:     E49A D6 2E                  OUTSCI2  LDAB SCSR        ;read status
 1115:     E49C C5 80                           BITB #$80
 1116:     E49E 27 FA                           BEQ  OUTSCI2     ;loop until tdre=1
 1117:     E4A0 84 7F                           ANDA #$7F        ;mask parity
 1118:     E4A2 97 2F                           STAA SCDAT       ;send character
 1119:     E4A4 39                     OUTSCI3  RTS
 1120:                                 
 1121:                                 **********
 1122:                                 *   ONACIA - Initialize the ACIA for
 1123:                                 * 8 data bits, 1 stop bit, divide by 64 clock.
 1124:                                 **********
 1125:     E4A5 CE 9800                ONACIA   LDX  #ACIA
 1126:     E4A8 86 03                           LDAA #$03
 1127:     E4AA A7 00                           STAA 0,X       ;master reset
 1128:     E4AC 86 16                           LDAA #$16
 1129:     E4AE A7 00                           STAA 0,X       ;setup
 1130:     E4B0 39                              RTS
 1131:                                 
 1132:                                 **********
 1133:                                 *   INACIA - Read from the ACIA, Return a=char or 0.
 1134:                                 * Tmp3 is used to flag overrun or framing error.
 1135:                                 **********
 1136:     E4B1 CE 9800                INACIA   LDX  #ACIA
 1137:     E4B4 A6 00                           LDAA 0,X       ;read status register
 1138:     E4B6 36                              PSHA
 1139:     E4B7 84 30                           ANDA #$30      ;check ov, fe
 1140:     E4B9 32                              PULA
 1141:     E4BA 27 06                           BEQ  INACIA1   ;jump - no error
 1142:     E4BC 86 01                           LDAA #$01
 1143:     E4BE 97 D5                           STAA TMP3      ;flag reciever error
 1144:     E4C0 20 04                           BRA  INACIA2   ;read data to clear status
 1145:     E4C2 84 01                  INACIA1  ANDA #$01      ;check rdrf
 1146:     E4C4 27 04                           BEQ  INACIA3   ;jump if no data
 1147:     E4C6 A6 01                  INACIA2  LDAA 1,X       ;read data
 1148:     E4C8 84 7F                           ANDA #$7F      ;mask parity
 1149:     E4CA 39                     INACIA3  RTS
 1150:                                 
 1151:                                 **********
 1152:                                 *  OUTACIA - Output A to acia. IF autolf = 1,
 1153:                                 *               cr or lf sent as crlf.
 1154:                                 **********
 1155:     E4CB 8D 18                  OUTACIA  BSR  OUTACIA3  ;output char
 1156:     E4CD 7D 00B7                         TST  AUTOLF
 1157:     E4D0 27 12                           BEQ  OUTACIA2  ;jump no autolf
 1158:     E4D2 81 0D                           CMPA #$0D
 1159:     E4D4 26 06                           BNE  OUTACIA1
 1160:     E4D6 86 0A                           LDAA #$0A
 1161:     E4D8 8D 0B                           BSR  OUTACIA3  ;if cr, output lf
 1162:     E4DA 20 08                           BRA  OUTACIA2
 1163:     E4DC 81 0A                  OUTACIA1 CMPA #$0A
 1164:     E4DE 26 04                           BNE  OUTACIA2
 1165:     E4E0 86 0D                           LDAA #$0D
 1166:     E4E2 8D 01                           BSR  OUTACIA3  ;if lf, output cr
 1167:     E4E4 39                     OUTACIA2 RTS
 1168:                                 
 1169:     E4E5 CE 9800                OUTACIA3 LDX  #ACIA
 1170:     E4E8 E6 00                           LDAB 0,X
 1171:     E4EA C5 02                           BITB #$2
 1172:     E4EC 27 F7                           BEQ  OUTACIA3  ;loop until tdre
 1173:     E4EE 84 7F                           ANDA #$7F      ;mask parity
 1174:     E4F0 A7 01                           STAA 1,X       ;output
 1175:     E4F2 39                              RTS
 1176:                                 *
 1177:                                 *        Space for modifying OUTACIA routine
 1178:                                 *
 1179:     E4F3 FFFF FFFF FFFF                  FDB  $FFFF,$FFFF,$FFFF,$FFFF
           E4F9 FFFF 
 1180:                                 *******************************
 1181:                                 *** I/O UTILITY SUBROUTINES ***
 1182:                                 ***These subroutines perform the neccesary
 1183:                                 * data I/O operations.
 1184:                                 * OUTLHLF-Convert left 4 bits of A from binary
 1185:                                 *            to ASCII and output.
 1186:                                 * OUTRHLF-Convert right 4 bits of A from binary
 1187:                                 *            to ASCII and output.
 1188:                                 * OUT1BYT-Convert byte addresed by X from binary
 1189:                                 *           to ASCII and output.
 1190:                                 * OUT1BSP-Convert byte addressed by X from binary
 1191:                                 *           to ASCII and output followed by a space.
 1192:                                 * OUT2BSP-Convert 2 bytes addressed by X from binary
 1193:                                 *            to ASCII and  output followed by a space.
 1194:                                 * OUTSPAC-Output a space.
 1195:                                 *
 1196:                                 * OUTCRLF-Output a line feed and carriage return.
 1197:                                 *
 1198:                                 * OUTSTRG-Output the string of ASCII bytes addressed
 1199:                                 *            by X until $04.
 1200:                                 * OUTA-Output the ASCII character in A.
 1201:                                 *
 1202:                                 * TABTO-Output spaces until column 20 is reached.
 1203:                                 *
 1204:                                 * INCHAR-Input to A and echo one character.  Loops
 1205:                                 *            until character read.
 1206:                                 *        *******************
 1207:                                 
 1208:                                 **********
 1209:                                 *  OUTRHLF(), OUTLHLF(), OUTA()
 1210:                                 *Convert A from binary to ASCII and output.
 1211:                                 *Contents of A are destroyed..
 1212:                                 **********
 1213:     E4FB 44                     OUTLHLF  LSRA           ; shift data to right
 1214:     E4FC 44                              LSRA
 1215:     E4FD 44                              LSRA
 1216:     E4FE 44                              LSRA
 1217:     E4FF 84 0F                  OUTRHLF  ANDA #$0F       ;mask top half
 1218:     E501 8B 30                           ADDA #$30       ;convert to ascii
 1219:     E503 81 39                           CMPA #$39
 1220:     E505 2F 02                           BLE  OUTA       ;jump if 0-9
 1221:     E507 8B 07                           ADDA #$07       ;convert to hex A-F
 1222:     E509 BD E3F0                OUTA     JSR  OUTPUT     ;output character
 1223:     E50C 39                              RTS
 1224:                                 
 1225:                                 **********
 1226:                                 *  OUT1BYT(x) - Convert the byte at X to two
 1227:                                 * ASCII characters and output. Return X pointing
 1228:                                 * to next byte.
 1229:                                 **********
 1230:     E50D 36                     OUT1BYT  PSHA
 1231:     E50E A6 00                           LDAA 0,X        ;get data in a
 1232:     E510 36                              PSHA            ;save copy
 1233:     E511 8D E8                           BSR  OUTLHLF    ;output left half
 1234:     E513 32                              PULA            ;retrieve copy
 1235:     E514 8D E9                           BSR  OUTRHLF    ;output right half
 1236:     E516 32                              PULA
 1237:     E517 08                              INX
 1238:     E518 39                              RTS
 1239:                                 
 1240:                                 **********
 1241:                                 *  OUT1BSP(x), OUT2BSP(x) - Output 1 or 2 bytes
 1242:                                 * at x followed by a space.  Returns x pointing to
 1243:                                 * next byte.
 1244:                                 **********
 1245:     E519 BD E50D                OUT2BSP  JSR  OUT1BYT      ;do first byte
 1246:     E51C BD E50D                OUT1BSP  JSR  OUT1BYT      ;do next byte
 1247:     E51F 86 20                  OUTSPAC  LDAA #$20         ;output a space
 1248:     E521 BD E3F0                         JSR  OUTPUT
 1249:     E524 39                              RTS
 1250:                                 
 1251:                                 **********
 1252:                                 *  OUTCRLF() - Output a Carriage return and
 1253:                                 * a line feed.  Returns a = cr.
 1254:                                 **********
 1255:     E525                        OUTCRLFv2
 1256:                                 ;       pshb
 1257:                                 ;       ldaa #' '
 1258:                                 ;       ldab chrcnt
 1259:                                 ;outcrlf1
 1260:                                 ;       staa $37
 1261:                                 ;       incb
 1262:                                 ;       cmpb #80
 1263:                                 ;       bne outcrlf1
 1264:     E525 7F 00BC                        clr chrcnt
 1265:                                 ;       ldaa #$80
 1266:                                 ;       staa $38        ; column zero
 1267:                                 ;       ldaa #$11
 1268:                                 ;       ldab #80
 1269:                                 ;outcrlf2
 1270:                                 ;       staa $38
 1271:                                 ;       decb
 1272:                                 ;       bne outcrlf2
 1273:                                 ;
 1274:                                 ;       ldaa #$80
 1275:                                 ;       staa $38        ; column zero
 1276:                                 ;       ldaa #$0d       
 1277:                                 ;       staa $38        ; scroll one line
 1278:                                 ;       pulb
 1279:     E528 86 0D                          ldaa #$0d
 1280:     E52A 97 37                          staa $37
 1281:     E52C 12 38 01 FC                    brset $38, $01, * ; wait until line is cleared
 1282:     E530 39                             rts
 1283:                                 
 1284:     E531                        outcrlf
 1285:     E531 BD E525                        jsr outcrlfv2
 1286:                                 ;         LDAA #$0D      ;cr
 1287:                                 ;       ldaa #$0d
 1288:     E534 BD E3CA                         JSR  OUTPUT_v1    ;output a
 1289:                                 ;         LDAA #$00
 1290:                                 ;         JSR  OUTPUT_v1    ;output padding
 1291:                                 ;         LDAA #$0D
 1292:                                 ;         CLR  CHRCNT    ;zero the column counter
 1293:                                 ;         RTS
 1294:                                 
 1295:     E537 39                             rts
 1296:                                         
 1297:                                 
 1298:                                 **********
 1299:                                 *  OUTSTRG(x) - Output string of ASCII bytes
 1300:                                 * starting at x until end of text ($04).  Can
 1301:                                 * be paused by control w (any char restarts).
 1302:                                 **********
 1303:     E538 BD E531                OUTSTRG  JSR  OUTCRLF
 1304:     E53B 36                     OUTSTRG0 PSHA
 1305:     E53C A6 00                  OUTSTRG1 LDAA 0,X          ;read char into a
 1306:     E53E 81 04                           CMPA #EOT
 1307:     E540 27 14                           BEQ  OUTSTRG3     ;jump if eot
 1308:     E542 BD E3F0                         JSR  OUTPUT       ;output character
 1309:     E545 08                              INX
 1310:     E546 BD E3A0                         JSR  INPUT
 1311:     E549 27 F1                           BEQ  OUTSTRG1     ;jump if no input
 1312:     E54B 81 17                           CMPA #CTLW
 1313:     E54D 26 ED                           BNE  OUTSTRG1     ;jump if not cntlw
 1314:     E54F BD E3A0                OUTSTRG2 JSR  INPUT
 1315:     E552 27 FB                           BEQ  OUTSTRG2     ;jump if any input
 1316:     E554 20 E6                           BRA  OUTSTRG1
 1317:     E556 32                     OUTSTRG3 PULA
 1318:     E557 39                              RTS
 1319:                                 
 1320:                                 
 1321:                                 *********
 1322:                                 *  TABTO() - move cursor over to column 20.
 1323:                                 *while(chrcnt < 16) outspac.
 1324:          =0000E558              TABTO   EQU  *
 1325:     E558 36                             PSHA
 1326:     E559 BD E51F                TABTOLP JSR  OUTSPAC
 1327:     E55C 96 BC                          LDAA CHRCNT
 1328:     E55E 81 14                          CMPA #20
 1329:     E560 2F F7                          BLE  TABTOLP
 1330:     E562 32                             PULA
 1331:     E563 39                             RTS
 1332:                                 
 1333:                                 **********
 1334:                                 *  INCHAR() - Reads input until character sent.
 1335:                                 *    Echoes char and returns with a = char.
 1336:     E564 BD E3A0                INCHAR   JSR  INPUT
 1337:     E567 4D                              TSTA
 1338:     E568 27 FA                           BEQ  INCHAR      ;jump if no input
 1339:     E56A BD E3F0                         JSR  OUTPUT      ;echo
 1340:     E56D 39                              RTS
 1341:                                 
 1342:                                 *********************
 1343:                                 *** COMMAND TABLE ***
 1344:          =0000E56E              COMTABL  EQU  *
 1345:     E56E 05                              FCB  5
 1346:     E56F 41 53 53 45 4D                  FCC  'ASSEM'
 1347:     E574 EAF5                            FDB  ASSEM
 1348:     E576 05                              FCB  5
 1349:     E577 42 52 45 41 4B                  FCC  'BREAK'
 1350:     E57C E70E                            FDB  BREAK
 1351:     E57E 04                              FCB  4
 1352:     E57F 42 55 4C 4B                     FCC  'BULK'
 1353:     E583 E7C9                            FDB  BULK
 1354:     E585 07                              FCB  7
 1355:     E586 42 55 4C 4B 41 4C               FCC  'BULKALL'
           E58C 4C 
 1356:     E58D E7CD                            FDB  BULKALL
 1357:     E58F 04                              FCB  4
 1358:     E590 43 41 4C 4C                     FCC  'CALL'
 1359:     E594 F9CE                            FDB  CALL
 1360:     E596 04                              FCB  4
 1361:     E597 44 55 4D 50                     FCC  'DUMP'
 1362:     E59B E7D6                            FDB  DUMP
 1363:     E59D 05                              FCB  5
 1364:     E59E 45 45 4D 4F 44                  FCC  'EEMOD'
 1365:     E5A3 E86B                            FDB  EEMOD
 1366:     E5A5 04                              FCB  4
 1367:     E5A6 46 49 4C 4C                     FCC  'FILL'
 1368:     E5AA E86C                            FDB  FILL
 1369:     E5AC 02                              FCB  2
 1370:     E5AD 47 4F                           FCC  'GO'
 1371:     E5AF FA27                            FDB  GO
 1372:     E5B1 04                              FCB  4
 1373:     E5B2 48 45 4C 50                     FCC  'HELP'
 1374:     E5B6 F5D5                            FDB  HELP
 1375:     E5B8 04                              FCB  4
 1376:     E5B9 48 4F 53 54                     FCC  'HOST'
 1377:     E5BD FBA0                            FDB  HOST
 1378:     E5BF 04                              FCB  4
 1379:     E5C0 4C 4F 41 44                     FCC  'LOAD'
 1380:     E5C4 FC3E                            FDB  LOAD
 1381:     E5C6 06                              FCB  6          ;LENGTH OF COMMAND
 1382:     E5C7 4D 45 4D 4F 52 59               FCC  'MEMORY'   ;ASCII COMMAND
 1383:     E5CD E8D4                            FDB  MEMORY    ;COMMAND ADDRESS
 1384:     E5CF 04                              FCB  4
 1385:     E5D0 4D 4F 56 45                     FCC  'MOVE'
 1386:     E5D4 E9A8                            FDB  MOVE
 1387:     E5D6 06                              FCB  6
 1388:     E5D7 4F 46 46 53 45 54               FCC  'OFFSET'
 1389:     E5DD FD52                            FDB  OFFSET
 1390:     E5DF 07                              FCB  7
 1391:     E5E0 50 52 4F 43 45 45               FCC  'PROCEED'
           E5E6 44 
 1392:     E5E7 FA15                            FDB  PROCEED
 1393:     E5E9 08                              FCB  8
 1394:     E5EA 52 45 47 49 53 54               FCC  'REGISTER'
           E5F0 45 52 
 1395:     E5F2 FD93                            FDB  REGISTER
 1396:     E5F4 06                              FCB  6
 1397:     E5F5 53 54 4F 50 41 54               FCC  'STOPAT'
 1398:     E5FB FB01                            FDB  STOPAT
 1399:     E5FD 05                              FCB  5
 1400:     E5FE 54 52 41 43 45                  FCC  'TRACE'
 1401:     E603 FABC                            FDB  TRACE
 1402:     E605 06                              FCB  6
 1403:     E606 56 45 52 49 46 59               FCC  'VERIFY'
 1404:     E60C FC36                            FDB  VERIFY
 1405:     E60E 01                              FCB  1
 1406:     E60F 3F                              FCC  '?'       ;initial command
 1407:     E610 F5D5                            FDB  HELP
 1408:     E612 05                              FCB  5
 1409:     E613 58 42 4F 4F 54                  FCC  'XBOOT'
 1410:     E618 FE03                            FDB  BOOT
 1411:     E61A 01                              FCB  1         ;dummy command for load
 1412:     E61B 7E                              FCC  '~'
 1413:     E61C FE7B                            FDB  TILDE
 1414:                                 *
 1415:                                 *** Command names for evm compatability ***
 1416:                                 *
 1417:     E61E 03                              FCB  3
 1418:     E61F 41 53 4D                        FCC  'ASM'
 1419:     E622 EAF5                            FDB  ASSEM
 1420:     E624 02                              FCB  2
 1421:     E625 42 46                           FCC  'BF'
 1422:     E627 E86C                            FDB  FILL
 1423:     E629 04                              FCB  4
 1424:     E62A 43 4F 50 59                     FCC  'COPY'
 1425:     E62E E9A8                            FDB  MOVE
 1426:     E630 05                              FCB  5
 1427:     E631 45 52 41 53 45                  FCC  'ERASE'
 1428:     E636 E7C9                            FDB  BULK
 1429:     E638 02                              FCB  2
 1430:     E639 4D 44                           FCC  'MD'
 1431:     E63B E7D6                            FDB  DUMP
 1432:     E63D 02                              FCB  2
 1433:     E63E 4D 4D                           FCC  'MM'
 1434:     E640 E8D4                            FDB  MEMORY
 1435:     E642 02                              FCB  2
 1436:     E643 52 44                           FCC  'RD'
 1437:     E645 FD93                            FDB  REGISTER
 1438:     E647 02                              FCB  2
 1439:     E648 52 4D                           FCC  'RM'
 1440:     E64A FD93                            FDB  REGISTER
 1441:     E64C 04                              FCB  4
 1442:     E64D 52 45 41 44                     FCC  'READ'
 1443:     E651 E9A8                            FDB  MOVE
 1444:     E653 02                              FCB  2
 1445:     E654 54 4D                           FCC  'TM'
 1446:     E656 FBA0                            FDB  HOST
 1447:     E658 04                              FCB  4
 1448:     E659 54 45 53 54                     FCC  'TEST'
 1449:     E65D FE7C                            FDB  EVBTEST
 1450:     E65F FF                              FCB  $FF
 1451:                                 
 1452:                                 *******************
 1453:                                 *** TEXT TABLES ***
 1454:                                 
 1455:     E660 42 55 46 46 41 4C      MSG1    FCC   'BUFFALO 3.4 (ext) - Bit User Fast Friendly Aid to Logical Operation'
           E666 4F 20 33 2E 34 20 
           E66C 28 65 78 74 29 20 
           E672 2D 20 42 69 74 20 
           E678 55 73 65 72 20 46 
           E67E 61 73 74 20 46 72 
           E684 69 65 6E 64 6C 79 
           E68A 20 41 69 64 20 74 
           E690 6F 20 4C 6F 67 69 
           E696 63 61 6C 20 4F 70 
           E69C 65 72 61 74 69 6F 
           E6A2 6E 
 1456:     E6A3 04                             FCB   EOT
 1457:     E6A4 57 68 61 74 3F         MSG2    FCC   'What?'
 1458:     E6A9 04                             FCB   EOT
 1459:     E6AA 54 6F 6F 20 4C 6F      MSG3    FCC   'Too Long'
           E6B0 6E 67 
 1460:     E6B2 04                             FCB   EOT
 1461:     E6B3 46 75 6C 6C            MSG4    FCC   'Full'
 1462:     E6B7 04                             FCB   EOT
 1463:     E6B8 4F 70 2D 20            MSG5    FCC   'Op- '
 1464:     E6BC 04                             FCB   EOT
 1465:     E6BD 72 6F 6D 2D            MSG6    FCC   'rom-'
 1466:     E6C1 04                             FCB   EOT
 1467:     E6C2 43 6F 6D 6D 61 6E      MSG8    FCC   'Command?'
           E6C8 64 3F 
 1468:     E6CA 04                             FCB   EOT
 1469:     E6CB 42 61 64 20 61 72      MSG9    FCC   'Bad argument'
           E6D1 67 75 6D 65 6E 74 
 1470:     E6D7 04                             FCB   EOT
 1471:     E6D8 4E 6F 20 68 6F 73      MSG10   FCC   'No host port'
           E6DE 74 20 70 6F 72 74 
 1472:     E6E4 04                             FCB   EOT
 1473:     E6E5 64 6F 6E 65            MSG11   FCC   'done'
 1474:     E6E9 04                             FCB   EOT
 1475:     E6EA 63 68 6B 73 75 6D      MSG12   FCC   'chksum error'
           E6F0 20 65 72 72 6F 72 
 1476:     E6F6 04                             FCB   EOT
 1477:     E6F7 65 72 72 6F 72 20      MSG13   FCC   'error addr '
           E6FD 61 64 64 72 20 
 1478:     E702 04                             FCB   EOT
 1479:     E703 72 63 76 72 20 65      MSG14   FCC   'rcvr error'
           E709 72 72 6F 72 
 1480:     E70D 04                             FCB   EOT
 1481:                                 
 1482:                                 **********
 1483:                                 *   break [-][<addr>] . . .
 1484:                                 * Modifies the breakpoint table.  More than
 1485:                                 * one argument can be entered on the command
 1486:                                 * line but the table will hold only 4 entries.
 1487:                                 * 4 types of arguments are implied above:
 1488:                                 * break           Prints table contents.
 1489:                                 * break <addr>    Inserts <addr>.
 1490:                                 * break -<addr>   Deletes <addr>.
 1491:                                 * break -         Clears all entries.
 1492:                                 **********
 1493:                                 * while 1
 1494:                                 *     a = wskip();
 1495:                                 *     switch(a)
 1496:                                 *          case(cr):
 1497:                                 *               bprint(); return;
 1498:                                 
 1499:     E70E BD E2FC                BREAK   JSR  WSKIP
 1500:     E711 26 04                          BNE  BRKDEL     ;jump if not cr
 1501:     E713 BD E7A5                        JSR  BPRINT     ;print table
 1502:     E716 39                             RTS
 1503:                                 
 1504:                                 *          case("-"):
 1505:                                 *               incbuff(); readbuff();
 1506:                                 *               if(dchek(a))          /* look for wspac or cr */
 1507:                                 *                    bpclr();
 1508:                                 *                    breaksw;
 1509:                                 *               a = buffarg();
 1510:                                 *               if( !dchek(a) ) return(bad argument);
 1511:                                 *               b = bpsrch();
 1512:                                 *               if(b >= 0)
 1513:                                 *                    brktabl[b] = 0;
 1514:                                 *               breaksw;
 1515:                                 
 1516:     E717 81 2D                  BRKDEL  CMPA #'-'
 1517:     E719 26 31                          BNE  BRKDEF     ;jump if not -
 1518:     E71B BD E2EE                        JSR  INCBUFF
 1519:     E71E BD E2E7                        JSR  READBUFF
 1520:     E721 BD E317                        JSR  DCHEK
 1521:     E724 26 06                          BNE  BRKDEL1    ;jump if not delimeter
 1522:     E726 BD E1B2                        JSR  BPCLR      ;clear table
 1523:     E729 7E E70E                        JMP  BREAK      ;do next argument
 1524:     E72C BD E234                BRKDEL1 JSR  BUFFARG    ;get address to delete
 1525:     E72F BD E317                        JSR  DCHEK
 1526:     E732 27 07                          BEQ  BRKDEL2    ;jump if delimeter
 1527:     E734 CE E6CB                        LDX  #MSG9      ;"bad argument"
 1528:     E737 BD E538                        JSR  OUTSTRG
 1529:     E73A 39                             RTS
 1530:     E73B BD E7B4                BRKDEL2 JSR  BPSRCH     ;look for addr in table
 1531:     E73E 5D                             TSTB
 1532:     E73F 2B 08                          BMI  BRKDEL3    ;jump if not found
 1533:     E741 CE 00AF                        LDX  #BRKTABL
 1534:     E744 3A                             ABX
 1535:     E745 6F 00                          CLR  0,X        ;clear entry
 1536:     E747 6F 01                          CLR  1,X
 1537:     E749 7E E70E                BRKDEL3 JMP  BREAK      ;do next argument
 1538:                                 
 1539:                                 *          default:
 1540:                                 *               a = buffarg();
 1541:                                 *               if( !dchek(a) ) return(bad argument);
 1542:                                 *               b = bpsrch();
 1543:                                 *               if(b < 0)            /* not already in table */
 1544:                                 *                    x = shftreg;
 1545:                                 *                    shftreg = 0;
 1546:                                 *                    a = x[0]; x[0] = $3F
 1547:                                 *                    b = x[0]; x[0] = a;
 1548:                                 *                    if(b != $3F) return(rom);
 1549:                                 *                    b = bpsrch();   /* look for hole */
 1550:                                 *                    if(b >= 0) return(table full);
 1551:                                 *                    brktabl[b] = x;
 1552:                                 *               breaksw;
 1553:                                 
 1554:     E74C BD E234                BRKDEF  JSR  BUFFARG    ;get argument
 1555:     E74F BD E317                        JSR  DCHEK
 1556:     E752 27 07                          BEQ  BRKDEF1    ;jump if delimiter
 1557:     E754 CE E6CB                        LDX  #MSG9      ;"bad argument"
 1558:     E757 BD E538                        JSR  OUTSTRG
 1559:     E75A 39                             RTS
 1560:     E75B BD E7B4                BRKDEF1 JSR  BPSRCH     ;look for entry in table
 1561:     E75E 5D                             TSTB
 1562:     E75F 2C AD                          BGE  BREAK      ;jump if already in table
 1563:                                 
 1564:     E761 DE A9                          LDX  SHFTREG     ;x = new entry addr
 1565:     E763 A6 00                          LDAA 0,X         ;save original contents
 1566:     E765 36                             PSHA
 1567:     E766 86 3F                          LDAA #SWI
 1568:     E768 BD E28A                        JSR  WRITE       ;write to entry addr
 1569:     E76B E6 00                          LDAB 0,X         ;read back
 1570:     E76D 32                             PULA
 1571:     E76E BD E28A                        JSR  WRITE       ;restore original
 1572:     E771 C1 3F                          CMPB #SWI
 1573:     E773 27 0C                          BEQ  BRKDEF2    ;jump if writes ok
 1574:     E775 DF C3                          STX  PTR1       ;save address
 1575:     E777 CE 00C3                        LDX  #PTR1
 1576:     E77A BD E519                        JSR  OUT2BSP     ;print address
 1577:     E77D BD E7A5                        JSR  BPRINT
 1578:     E780 39                             RTS
 1579:     E781 7F 00A9                BRKDEF2 CLR  SHFTREG
 1580:     E784 7F 00AA                        CLR  SHFTREG+1
 1581:     E787 3C                             PSHX
 1582:     E788 BD E7B4                        JSR  BPSRCH     ;look for 0 entry
 1583:     E78B 38                             PULX
 1584:     E78C 5D                             TSTB
 1585:     E78D 2A 0A                          BPL  BRKDEF3    ;jump if table not full
 1586:     E78F CE E6B3                        LDX  #MSG4      ;"full"
 1587:     E792 BD E538                        JSR  OUTSTRG
 1588:     E795 BD E7A5                        JSR  BPRINT
 1589:     E798 39                             RTS
 1590:     E799 18CE 00AF              BRKDEF3 LDY  #BRKTABL
 1591:     E79D 183A                           ABY
 1592:     E79F CDEF 00                        STX  0,Y        ;put new entry in
 1593:     E7A2 7E E70E                        JMP  BREAK      ;do next argument
 1594:                                 
 1595:                                 **********
 1596:                                 *   bprint() - print the contents of the table.
 1597:                                 **********
 1598:     E7A5 BD E531                BPRINT   JSR  OUTCRLF
 1599:     E7A8 CE 00AF                         LDX  #BRKTABL
 1600:     E7AB C6 04                           LDAB #4
 1601:     E7AD BD E519                BPRINT1  JSR  OUT2BSP
 1602:     E7B0 5A                              DECB
 1603:     E7B1 2E FA                           BGT  BPRINT1     ;loop 4 times
 1604:     E7B3 39                              RTS
 1605:                                 
 1606:                                 **********
 1607:                                 *   bpsrch() - search table for address in
 1608:                                 * shftreg. Returns b = index to entry or
 1609:                                 * b = -1 if not found.
 1610:                                 **********
 1611:                                 *for(b=0; b=6; b=+2)
 1612:                                 *     x[] = brktabl + b;
 1613:                                 *     if(x[0] = shftreg)
 1614:                                 *          return(b);
 1615:                                 *return(-1);
 1616:                                 
 1617:     E7B4 5F                     BPSRCH   CLRB
 1618:     E7B5 CE 00AF                BPSRCH1  LDX  #BRKTABL
 1619:     E7B8 3A                              ABX
 1620:     E7B9 EE 00                           LDX  0,X       ;get table entry
 1621:     E7BB 9C A9                           CPX  SHFTREG
 1622:     E7BD 26 01                           BNE  BPSRCH2   ;jump if no match
 1623:     E7BF 39                              RTS
 1624:     E7C0 5C                     BPSRCH2  INCB
 1625:     E7C1 5C                              INCB
 1626:     E7C2 C1 06                           CMPB #$6
 1627:     E7C4 2F EF                           BLE  BPSRCH1  ;loop 4 times
 1628:     E7C6 C6 FF                           LDAB #$FF
 1629:     E7C8 39                              RTS
 1630:                                 
 1631:                                 
 1632:                                 **********
 1633:                                 *  bulk  - Bulk erase the eeprom not config.
 1634:                                 * bulkall - Bulk erase eeprom and config.
 1635:                                 *********
 1636:          =0000E7C9              BULK    EQU  *
 1637:     E7C9 DE AB                          LDX  STREE
 1638:     E7CB 20 03                          BRA  BULK1
 1639:     E7CD CE 003F                BULKALL LDX  #CONFIG
 1640:     E7D0 86 FF                  BULK1   LDAA #$FF
 1641:     E7D2 BD E2CC                        JSR  EEBULK
 1642:     E7D5 39                             RTS
 1643:                                 
 1644:                                 
 1645:                                 
 1646:                                 **********
 1647:                                 *  dump [<addr1> [<addr2>]]  - Dump memory
 1648:                                 * in 16 byte lines from <addr1> to <addr2>.
 1649:                                 *   Default starting address is "current
 1650:                                 * location" and default number of lines is 8.
 1651:                                 **********
 1652:                                 *ptr1 = ptrmem;        /* default start address */
 1653:                                 *ptr2 = ptr1 + $80;    /* default end address */
 1654:                                 *a = wskip();
 1655:                                 *if(a != cr)
 1656:                                 *     a = buffarg();
 1657:                                 *     if(countu1 = 0) return(bad argument);
 1658:                                 *     if( !dchek(a) ) return(bad argument);
 1659:                                 *     ptr1 = shftreg;
 1660:                                 *     ptr2 = ptr1 + $80;  /* default end address */
 1661:                                 *     a = wskip();
 1662:                                 *     if(a != cr)
 1663:                                 *          a = buffarg();
 1664:                                 *          if(countu1 = 0) return(bad argument);
 1665:                                 *          a = wskip();
 1666:                                 *          if(a != cr) return(bad argument);
 1667:                                 *          ptr2 = shftreg;
 1668:                                 
 1669:     E7D6 DE BD                  DUMP     LDX  PTRMEM    ;current location
 1670:     E7D8 DF C3                           STX  PTR1      ;default start
 1671:     E7DA C6 80                           LDAB #$80
 1672:     E7DC 3A                              ABX
 1673:     E7DD DF C5                           STX  PTR2      ;default end
 1674:     E7DF BD E2FC                         JSR  WSKIP
 1675:     E7E2 27 35                           BEQ  DUMP1     ;jump - no arguments
 1676:     E7E4 BD E234                         JSR  BUFFARG   ;read argument
 1677:     E7E7 7D 00BB                         TST  COUNT
 1678:     E7EA 27 26                           BEQ  DUMPERR   ;jump if no argument
 1679:     E7EC BD E317                         JSR  DCHEK
 1680:     E7EF 26 21                           BNE  DUMPERR   ;jump if delimiter
 1681:     E7F1 DE A9                           LDX  SHFTREG
 1682:     E7F3 DF C3                           STX  PTR1
 1683:     E7F5 C6 80                           LDAB #$80
 1684:     E7F7 3A                              ABX
 1685:     E7F8 DF C5                           STX  PTR2      ;default end address
 1686:     E7FA BD E2FC                         JSR  WSKIP
 1687:     E7FD 27 1A                           BEQ  DUMP1     ;jump - 1 argument
 1688:     E7FF BD E234                         JSR  BUFFARG   ;read argument
 1689:     E802 7D 00BB                         TST  COUNT
 1690:     E805 27 0B                           BEQ  DUMPERR   ;jump if no argument
 1691:     E807 BD E2FC                         JSR  WSKIP
 1692:     E80A 26 06                           BNE  DUMPERR   ;jump if not cr
 1693:     E80C DE A9                           LDX  SHFTREG
 1694:     E80E DF C5                           STX  PTR2
 1695:     E810 20 07                           BRA  DUMP1     ;jump - 2 arguments
 1696:     E812 CE E6CB                DUMPERR  LDX  #MSG9     ;"bad argument"
 1697:     E815 BD E538                         JSR  OUTSTRG
 1698:     E818 39                              RTS
 1699:                                 
 1700:                                 *ptrmem = ptr1;
 1701:                                 *ptr1 = ptr1 & $fff0;
 1702:                                 
 1703:     E819 DC C3                  DUMP1    LDD  PTR1
 1704:     E81B DD BD                           STD  PTRMEM    ;new current location
 1705:     E81D C4 F0                           ANDB #$F0
 1706:     E81F DD C3                           STD  PTR1      ;start dump at 16 byte boundary
 1707:                                 
 1708:                                 *** dump loop starts here ***
 1709:                                 *do:
 1710:                                 *     output address of first byte;
 1711:                                 
 1712:     E821 BD E531                DUMPLP   JSR  OUTCRLF
 1713:     E824 CE 00C3                         LDX  #PTR1
 1714:     E827 BD E519                         JSR  OUT2BSP   ;first address
 1715:                                 
 1716:                                 *     x = ptr1;
 1717:                                 *     for(b=0; b=16; b++)
 1718:                                 *          output contents;
 1719:                                 
 1720:     E82A DE C3                           LDX  PTR1      ;base address
 1721:     E82C 5F                              CLRB           ;loop counter
 1722:     E82D BD E51C                DUMPDAT  JSR  OUT1BSP   ;hex value loop
 1723:     E830 5C                              INCB
 1724:     E831 C1 10                           CMPB #$10
 1725:     E833 2D F8                           BLT  DUMPDAT    ;loop 16 times
 1726:                                 
 1727:                                 *     x = ptr1;
 1728:                                 *     for(b=0; b=16; b++)
 1729:                                 *          a = x[b];
 1730:                                 *          if($7A < a < $20)  a = $20;
 1731:                                 *          output ascii contents;
 1732:                                 
 1733:     E835 5F                              CLRB           ;loop counter
 1734:     E836 DE C3                  DUMPASC  LDX  PTR1      ;base address
 1735:     E838 3A                              ABX
 1736:     E839 A6 00                           LDAA ,X        ;ascii value loop
 1737:     E83B 81 20                           CMPA #$20
 1738:     E83D 25 04                           BLO  DUMP3     ;jump if non printable
 1739:     E83F 81 7A                           CMPA #$7A
 1740:     E841 23 02                           BLS  DUMP4     ;jump if printable
 1741:     E843 86 20                  DUMP3    LDAA #$20      ;space for non printables
 1742:     E845 BD E3F0                DUMP4    JSR  OUTPUT    ;output ascii value
 1743:     E848 5C                              INCB
 1744:     E849 C1 10                           CMPB #$10
 1745:     E84B 2D E9                           BLT  DUMPASC   ;loop 16 times
 1746:                                 
 1747:                                 *     chkabrt();
 1748:                                 *     ptr1 = ptr1 + $10;
 1749:                                 *while(ptr1 <= ptr2);
 1750:                                 *return;
 1751:                                 
 1752:     E84D BD E31F                         JSR  CHKABRT   ;check abort or wait
 1753:     E850 DC C3                           LDD  PTR1
 1754:     E852 C3 0010                         ADDD #$10      ;point to next 16 byte bound
 1755:     E855 DD C3                           STD  PTR1      ;update ptr1
 1756:     E857 1A93 C5                         CPD  PTR2
 1757:     E85A 22 0E                           BHI  DUMP5     ;quit if ptr1 > ptr2
 1758:     E85C 1A83 0000                       CPD  #$00      ;check wraparound at $ffff
 1759:     E860 26 BF                           BNE  DUMPLP    ;jump - no wraparound
 1760:     E862 DC C5                           LDD  PTR2
 1761:     E864 1A83 FFF0                       CPD  #$FFF0
 1762:     E868 25 B7                           BLO  DUMPLP    ;upper bound not at top
 1763:     E86A 39                     DUMP5    RTS            ;quit
 1764:                                 
 1765:                                 
 1766:                                 
 1767:                                 **********
 1768:                                 *   eemod [<addr1> [<addr2>]]
 1769:                                 * Modifies the eeprom address range.
 1770:                                 *  EEMOD                 -show ee address range
 1771:                                 *  EEMOD <addr1>         -set range to addr1 -> addr1+2k
 1772:                                 *  EEMOD <addr1> <addr2> -set range to addr1 -> addr2
 1773:                                 **********
 1774:                                 *if(<addr1>)
 1775:                                 *    stree = addr1;
 1776:                                 *    endee = addr1 + 2k bytes;
 1777:                                 *if(<addr2>)
 1778:                                 *    endee = addr2;
 1779:                                 *print(stree,endee);
 1780:          =0000E86B              EEMOD    EQU  *
 1781:                                 ;         JSR  WSKIP
 1782:                                 ;         BEQ  EEMOD2    ;jump - no arguments
 1783:                                 ;         JSR  BUFFARG   ;read argument
 1784:                                 ;         TST  COUNT
 1785:                                 ;         BEQ  EEMODER   ;jump if no argument
 1786:                                 ;         JSR  DCHEK
 1787:                                 ;         BNE  EEMODER   ;jump if no delimeter
 1788:                                 ;         LDD  SHFTREG
 1789:                                 ;         STD  PTR1
 1790:                                 ;         ADDD #$07FF    ;add 2k bytes to stree
 1791:                                 ;         STD  PTR2      ;default endee address
 1792:                                 ;         JSR  WSKIP
 1793:                                 ;         BEQ  EEMOD1    ;jump - 1 argument
 1794:                                 ;         JSR  BUFFARG   ;read argument
 1795:                                 ;         TST  COUNT
 1796:                                 ;         BEQ  EEMODER   ;jump if no argument
 1797:                                 ;         JSR  WSKIP
 1798:                                 ;         BNE  EEMODER   ;jump if not cr
 1799:                                 ;         LDX  SHFTREG
 1800:                                 ;         STX  PTR2
 1801:                                 ;EEMOD1   LDX  PTR1
 1802:                                 ;         STX  STREE     ;new stree address
 1803:                                 ;         LDX  PTR2
 1804:                                 ;         STX  ENDEE     ;new endee address
 1805:                                 ;EEMOD2   JSR  OUTCRLF   ;display ee range
 1806:                                 ;         LDX  #STREE
 1807:                                 ;         JSR  OUT2BSP
 1808:                                 ;         LDX  #ENDEE
 1809:                                 ;         JSR  OUT2BSP
 1810:     E86B 39                              RTS
 1811:                                 
 1812:                                 ;EEMODER  LDX  #MSG9     ;"bad argument"
 1813:                                 ;         JSR  OUTSTRG
 1814:                                 ;         RTS
 1815:                                 
 1816:                                 
 1817:                                 
 1818:                                 
 1819:                                 **********
 1820:                                 *  fill <addr1> <addr2> [<data>]  - Block fill
 1821:                                 *memory from addr1 to addr2 with data.  Data
 1822:                                 *defaults to $FF.
 1823:                                 **********
 1824:                                 *get addr1 and addr2
 1825:          =0000E86C              FILL    EQU  *
 1826:     E86C BD E2FC                        JSR  WSKIP
 1827:     E86F BD E234                        JSR  BUFFARG
 1828:     E872 7D 00BB                        TST  COUNT
 1829:     E875 27 4F                          BEQ  FILLERR    ;jump if no argument
 1830:     E877 BD E30C                        JSR  WCHEK
 1831:     E87A 26 4A                          BNE  FILLERR    ;jump if bad argument
 1832:     E87C DE A9                          LDX  SHFTREG
 1833:     E87E DF C3                          STX  PTR1       ;address1
 1834:     E880 BD E2FC                        JSR  WSKIP
 1835:     E883 BD E234                        JSR  BUFFARG
 1836:     E886 7D 00BB                        TST  COUNT
 1837:     E889 27 3B                          BEQ  FILLERR    ;jump if no argument
 1838:     E88B BD E317                        JSR  DCHEK
 1839:     E88E 26 36                          BNE  FILLERR    ;jump if bad argument
 1840:     E890 DE A9                          LDX  SHFTREG
 1841:     E892 DF C5                          STX  PTR2       ;address2
 1842:                                 
 1843:                                 *Get data if it exists
 1844:     E894 86 FF                          LDAA #$FF
 1845:     E896 97 D4                          STAA TMP2       ;default data
 1846:     E898 BD E2FC                        JSR  WSKIP
 1847:     E89B 27 11                          BEQ  FILL1      ;jump if default data
 1848:     E89D BD E234                        JSR  BUFFARG
 1849:     E8A0 7D 00BB                        TST  COUNT
 1850:     E8A3 27 21                          BEQ  FILLERR    ;jump if no argument
 1851:     E8A5 BD E2FC                        JSR  WSKIP
 1852:     E8A8 26 1C                          BNE  FILLERR    ;jump if bad argument
 1853:     E8AA 96 AA                          LDAA SHFTREG+1
 1854:     E8AC 97 D4                          STAA TMP2
 1855:                                 
 1856:                                 *while(ptr1 <= ptr2)
 1857:                                 *   *ptr1 = data
 1858:                                 *   if(*ptr1 != data) abort
 1859:                                 
 1860:          =0000E8AE              FILL1   EQU  *
 1861:     E8AE BD E31F                        JSR  CHKABRT    ;check for abort
 1862:     E8B1 DE C3                          LDX  PTR1       ;starting address
 1863:     E8B3 96 D4                          LDAA TMP2       ;data
 1864:     E8B5 BD E28A                        JSR  WRITE      ;write the data to x
 1865:     E8B8 A1 00                          CMPA 0,X
 1866:     E8BA 26 11                          BNE  FILLBAD    ;jump if no write
 1867:     E8BC 9C C5                          CPX  PTR2
 1868:     E8BE 27 05                          BEQ  FILL2      ;quit yet?
 1869:     E8C0 08                             INX
 1870:     E8C1 DF C3                          STX  PTR1
 1871:     E8C3 20 E9                          BRA  FILL1      ;loop
 1872:     E8C5 39                     FILL2   RTS
 1873:                                 
 1874:     E8C6 CE E6CB                FILLERR LDX  #MSG9     ;"bad argument"
 1875:     E8C9 BD E538                        JSR  OUTSTRG
 1876:     E8CC 39                             RTS
 1877:                                 
 1878:          =0000E8CD              FILLBAD EQU  *
 1879:     E8CD CE 00C3                        LDX  #PTR1     ;output bad address
 1880:     E8D0 BD E519                        JSR  OUT2BSP
 1881:     E8D3 39                             RTS
 1882:                                 
 1883:                                 
 1884:                                 
 1885:                                 *******************************************
 1886:                                 *   MEMORY [<addr>]
 1887:                                 *   [<addr>]/
 1888:                                 * Opens memory and allows user to modify the
 1889:                                 *contents at <addr> or the last opened location.
 1890:                                 *    Subcommands:
 1891:                                 * [<data>]<cr>       - Close current location and exit.
 1892:                                 * [<data>]<lf><+>    - Close current and open next.
 1893:                                 * [<data>]<^><-><bs> - Close current and open previous.
 1894:                                 * [<data>]<sp>       - Close current and open next.
 1895:                                 * [<data>]</><=>     - Reopen current location.
 1896:                                 *     The contents of the current location is only
 1897:                                 *  changed if valid data is entered before each
 1898:                                 *  subcommand.
 1899:                                 * [<addr>]O - Compute relative offset from current
 1900:                                 *     location to <addr>.  The current location must
 1901:                                 *     be the address of the offset byte.
 1902:                                 **********
 1903:                                 *a = wskip();
 1904:                                 *if(a != cr)
 1905:                                 *     a = buffarg();
 1906:                                 *     if(a != cr) return(bad argument);
 1907:                                 *     if(countu1 != 0) ptrmem[] = shftreg;
 1908:                                 
 1909:     E8D4 BD E2FC                MEMORY   JSR  WSKIP
 1910:     E8D7 27 18                           BEQ  MEM1      ;jump if cr
 1911:     E8D9 BD E234                         JSR  BUFFARG
 1912:     E8DC BD E2FC                         JSR  WSKIP
 1913:     E8DF 27 07                           BEQ  MSLASH    ;jump if cr
 1914:     E8E1 CE E6CB                         LDX  #MSG9     ;"bad argument"
 1915:     E8E4 BD E538                         JSR  OUTSTRG
 1916:     E8E7 39                              RTS
 1917:     E8E8 7D 00BB                MSLASH   TST  COUNT
 1918:     E8EB 27 04                           BEQ  MEM1      ;jump if no argument
 1919:     E8ED DE A9                           LDX  SHFTREG
 1920:     E8EF DF BD                           STX  PTRMEM    ;update "current location"
 1921:                                 
 1922:                                 **********
 1923:                                 * Subcommands
 1924:                                 **********
 1925:                                 *outcrlf();
 1926:                                 *out2bsp(ptrmem[]);
 1927:                                 *out1bsp(ptrmem[0]);
 1928:                                 
 1929:     E8F1 BD E531                MEM1     JSR  OUTCRLF
 1930:     E8F4 CE 00BD                MEM2     LDX  #PTRMEM
 1931:     E8F7 BD E519                         JSR  OUT2BSP   ;output address
 1932:     E8FA DE BD                  MEM3     LDX  PTRMEM
 1933:     E8FC BD E51C                         JSR  OUT1BSP   ;output contents
 1934:     E8FF 7F 00A9                         CLR  SHFTREG
 1935:     E902 7F 00AA                         CLR  SHFTREG+1
 1936:                                 *while 1
 1937:                                 *a = termarg();
 1938:                                 *     switch(a)
 1939:                                 *          case(space):
 1940:                                 *             chgbyt();
 1941:                                 *             ptrmem[]++;
 1942:                                 *             if(ptrmem%16 == 0) start new line;
 1943:                                 *          case(linefeed | +):
 1944:                                 *             chgbyt();
 1945:                                 *             ptrmem[]++;
 1946:                                 *          case(up arrow | backspace | -):
 1947:                                 *               chgbyt();
 1948:                                 *               ptrmem[]--;
 1949:                                 *          case('/' | '='):
 1950:                                 *               chgbyt();
 1951:                                 *               outcrlf();
 1952:                                 *          case(O):
 1953:                                 *               d = ptrmem[0] - (shftreg);
 1954:                                 *               if($80 < d < $ff81)
 1955:                                 *                    print(out of range);
 1956:                                 *               countt1 = d-1;
 1957:                                 *               out1bsp(countt1);
 1958:                                 *          case(carriage return):
 1959:                                 *               chgbyt();
 1960:                                 *               return;
 1961:                                 *          default: return(command?)
 1962:                                 
 1963:     E905 BD E257                MEM4     JSR  TERMARG
 1964:     E908 BD E1A7                         JSR  UPCASE
 1965:     E90B DE BD                           LDX  PTRMEM
 1966:     E90D 81 20                           CMPA #$20
 1967:     E90F 27 31                           BEQ  MEMSP     ;jump if space
 1968:     E911 81 0A                           CMPA #$0A
 1969:     E913 27 3E                           BEQ  MEMLF     ;jump if linefeed
 1970:     E915 81 2B                           CMPA #$2B
 1971:     E917 27 43                           BEQ  MEMPLUS   ;jump if +
 1972:     E919 81 5E                           CMPA #$5E
 1973:     E91B 27 48                           BEQ  MEMUA     ;jump if up arrow
 1974:     E91D 81 2D                           CMPA #$2D
 1975:     E91F 27 44                           BEQ  MEMUA     ;jump if -
 1976:     E921 81 08                           CMPA #$08
 1977:     E923 27 40                           BEQ  MEMUA     ;jump if backspace
 1978:     E925 81 2F                           CMPA #'/'
 1979:     E927 27 45                           BEQ  MEMSL     ;jump if /
 1980:     E929 81 3D                           CMPA #'='
 1981:     E92B 27 41                           BEQ  MEMSL     ;jump if =
 1982:     E92D 81 4F                           CMPA #'O'
 1983:     E92F 27 43                           BEQ  MEMOFF    ;jump if O
 1984:     E931 81 0D                           CMPA #$0D
 1985:     E933 27 6F                           BEQ  MEMCR     ;jump if carriage ret
 1986:     E935 81 2E                           CMPA #'.'
 1987:     E937 27 6E                           BEQ  MEMEND    ;jump if .
 1988:     E939 CE E6C2                         LDX  #MSG8     ;"command?"
 1989:     E93C BD E538                         JSR  OUTSTRG
 1990:     E93F 7E E8F1                         JMP  MEM1
 1991:     E942 BD E27F                MEMSP    JSR  CHGBYT
 1992:     E945 08                              INX
 1993:     E946 DF BD                           STX  PTRMEM
 1994:     E948 8F                              XGDX
 1995:     E949 C4 0F                           ANDB #$0F
 1996:     E94B 27 03                           BEQ  MEMSP1    ;jump if mod16=0
 1997:     E94D 7E E8FA                         JMP  MEM3      ;continue same line
 1998:     E950 7E E8F1                MEMSP1   JMP  MEM1      ;.. else start new line
 1999:     E953 BD E27F                MEMLF    JSR  CHGBYT
 2000:     E956 08                              INX
 2001:     E957 DF BD                           STX  PTRMEM
 2002:     E959 7E E8F4                         JMP  MEM2      ;output next address
 2003:     E95C BD E27F                MEMPLUS  JSR  CHGBYT
 2004:     E95F 08                              INX
 2005:     E960 DF BD                           STX  PTRMEM
 2006:     E962 7E E8F1                         JMP  MEM1      ;output cr, next address
 2007:     E965 BD E27F                MEMUA    JSR  CHGBYT
 2008:     E968 09                              DEX
 2009:     E969 DF BD                           STX  PTRMEM
 2010:     E96B 7E E8F1                         JMP  MEM1      ;output cr, previous address
 2011:     E96E BD E27F                MEMSL    JSR  CHGBYT
 2012:     E971 7E E8F1                         JMP  MEM1      ;output cr, same address
 2013:     E974 DC A9                  MEMOFF   LDD  SHFTREG   ;destination addr
 2014:     E976 93 BD                           SUBD PTRMEM
 2015:     E978 81 00                           CMPA #$0
 2016:     E97A 26 06                           BNE  MEMOFF1   ;jump if not 0
 2017:     E97C C1 80                           CMPB #$80
 2018:     E97E 23 13                           BLS  MEMOFF3   ;jump if in range
 2019:     E980 20 08                           BRA  MEMOFF2   ;out of range
 2020:     E982 81 FF                  MEMOFF1  CMPA #$FF
 2021:     E984 26 04                           BNE  MEMOFF2   ;out of range
 2022:     E986 C1 81                           CMPB #$81
 2023:     E988 24 09                           BHS  MEMOFF3   ;in range
 2024:     E98A CE E6AA                MEMOFF2  LDX  #MSG3     ;"Too long"
 2025:     E98D BD E538                         JSR  OUTSTRG
 2026:     E990 7E E8F1                         JMP  MEM1      ;output cr, addr, contents
 2027:     E993 83 0001                MEMOFF3  SUBD #$1       ;b now has offset
 2028:     E996 D7 D6                           STAB TMP4
 2029:     E998 BD E51F                         JSR  OUTSPAC
 2030:     E99B CE 00D6                         LDX  #TMP4
 2031:     E99E BD E51C                         JSR  OUT1BSP   ;output offset
 2032:     E9A1 7E E8F1                         JMP  MEM1      ;output cr, addr, contents
 2033:     E9A4 BD E27F                MEMCR    JSR  CHGBYT
 2034:     E9A7 39                     MEMEND   RTS            ;exit task
 2035:                                 
 2036:                                 
 2037:                                 **********
 2038:                                 *   move <src1> <src2> [<dest>]  - move
 2039:                                 *block at <src1> to <src2> to <dest>.
 2040:                                 *  Moves block 1 byte up if no <dest>.
 2041:                                 **********
 2042:                                 *a = buffarg();
 2043:                                 *if(countu1 = 0) return(bad argument);
 2044:                                 *if( !wchek(a) ) return(bad argument);
 2045:                                 *ptr1 = shftreg;         /* src1 */
 2046:                                 
 2047:          =0000E9A8              MOVE     EQU  *
 2048:     E9A8 BD E234                         JSR  BUFFARG
 2049:     E9AB 7D 00BB                         TST  COUNT
 2050:     E9AE 27 2B                           BEQ  MOVERR    ;jump if no arg
 2051:     E9B0 BD E30C                         JSR  WCHEK
 2052:     E9B3 26 26                           BNE  MOVERR    ;jump if no delim
 2053:     E9B5 DE A9                           LDX  SHFTREG   ;src1
 2054:     E9B7 DF C3                           STX  PTR1
 2055:                                 
 2056:                                 *a = buffarg();
 2057:                                 *if(countu1 = 0) return(bad argument);
 2058:                                 *if( !dchek(a) ) return(bad argument);
 2059:                                 *ptr2 = shftreg;         /* src2 */
 2060:                                 
 2061:     E9B9 BD E234                         JSR  BUFFARG
 2062:     E9BC 7D 00BB                         TST  COUNT
 2063:     E9BF 27 1A                           BEQ  MOVERR    ;jump if no arg
 2064:     E9C1 BD E317                         JSR  DCHEK
 2065:     E9C4 26 15                           BNE  MOVERR    ;jump if no delim
 2066:     E9C6 DE A9                           LDX  SHFTREG   ;src2
 2067:     E9C8 DF C5                           STX  PTR2
 2068:                                 
 2069:                                 *a = buffarg();
 2070:                                 *a = wskip();
 2071:                                 *if(a != cr) return(bad argument);
 2072:                                 *if(countu1 != 0) tmp2 = shftreg;  /* dest */
 2073:                                 *else tmp2 = ptr1 + 1;
 2074:                                 
 2075:     E9CA BD E234                         JSR  BUFFARG
 2076:     E9CD BD E2FC                         JSR  WSKIP
 2077:     E9D0 26 09                           BNE  MOVERR    ;jump if not cr
 2078:     E9D2 7D 00BB                         TST  COUNT
 2079:     E9D5 27 0B                           BEQ  MOVE1     ;jump if no arg
 2080:     E9D7 DE A9                           LDX  SHFTREG   ;dest
 2081:     E9D9 20 0A                           BRA  MOVE2
 2082:     E9DB CE E6CB                MOVERR   LDX  #MSG9     ;"bad argument"
 2083:     E9DE BD E538                         JSR  OUTSTRG
 2084:     E9E1 39                              RTS
 2085:                                 
 2086:     E9E2 DE C3                  MOVE1    LDX  PTR1
 2087:     E9E4 08                              INX            ;default dest
 2088:     E9E5 DF C7                  MOVE2    STX  PTR3
 2089:                                 
 2090:                                 *if(src1 < dest <= src2)
 2091:                                 *     dest = dest+(src2-src1);
 2092:                                 *     for(x = src2; x = src1; x--)
 2093:                                 *          dest[0]-- = x[0]--;
 2094:     E9E7 DE C7                           LDX  PTR3        ;dest
 2095:     E9E9 9C C3                           CPX  PTR1        ;src1
 2096:     E9EB 23 28                           BLS  MOVE3       ;jump if dest =< src1
 2097:     E9ED 9C C5                           CPX  PTR2        ;src2
 2098:     E9EF 22 24                           BHI  MOVE3       ;jump if dest > src2
 2099:     E9F1 DC C5                           LDD  PTR2
 2100:     E9F3 93 C3                           SUBD PTR1
 2101:     E9F5 D3 C7                           ADDD PTR3
 2102:     E9F7 DD C7                           STD  PTR3        ;dest = dest+(src2-src1)
 2103:     E9F9 DE C5                           LDX  PTR2
 2104:     E9FB BD E31F                MOVELP1  JSR  CHKABRT     ;check for abort
 2105:     E9FE A6 00                           LDAA ,X          ;char at src2
 2106:     EA00 3C                              PSHX
 2107:     EA01 DE C7                           LDX  PTR3
 2108:     EA03 BD E28A                         JSR  WRITE       ;write a to x
 2109:     EA06 A1 00                           CMPA 0,X
 2110:     EA08 26 28                           BNE  MOVEBAD     ;jump if no write
 2111:     EA0A 09                              DEX
 2112:     EA0B DF C7                           STX  PTR3
 2113:     EA0D 38                              PULX
 2114:     EA0E 9C C3                           CPX  PTR1
 2115:     EA10 27 1F                           BEQ  MOVRTS
 2116:     EA12 09                              DEX
 2117:     EA13 20 E6                           BRA  MOVELP1    ;Loop SRC2 - SRC1 times
 2118:                                 *
 2119:                                 * else
 2120:                                 *     for(x=src1; x=src2; x++)
 2121:                                 *          dest[0]++ = x[0]++;
 2122:                                 
 2123:                                 
 2124:     EA15 DE C3                  MOVE3    LDX  PTR1        ;srce1
 2125:     EA17 BD E31F                MOVELP2  JSR  CHKABRT     ;check for abort
 2126:     EA1A A6 00                           LDAA ,X
 2127:     EA1C 3C                              PSHX
 2128:     EA1D DE C7                           LDX  PTR3        ;dest
 2129:     EA1F BD E28A                         JSR  WRITE       ;write a to x
 2130:     EA22 A1 00                           CMPA 0,X
 2131:     EA24 26 0C                           BNE  MOVEBAD     ;jump if no write
 2132:     EA26 08                              INX
 2133:     EA27 DF C7                           STX  PTR3
 2134:     EA29 38                              PULX
 2135:     EA2A 9C C5                           CPX  PTR2
 2136:     EA2C 27 03                           BEQ  MOVRTS
 2137:     EA2E 08                              INX
 2138:     EA2F 20 E6                           BRA  MOVELP2      ;Loop SRC2-SRC1 times
 2139:     EA31 39                     MOVRTS   RTS
 2140:                                 
 2141:     EA32 38                     MOVEBAD  PULX              ;restore stack
 2142:     EA33 CE 00C7                         LDX  #PTR3
 2143:     EA36 BD E519                         JSR  OUT2BSP      ;output bad address
 2144:     EA39 39                              RTS
 2145:                                 
 2146:                                 
 2147:                                 ****************
 2148:                                 *  assem(addr) -68HC11 line assembler/disassembler.
 2149:                                 *       This routine will disassemble the opcode at
 2150:                                 *<addr> and then allow the user to enter a line for
 2151:                                 *assembly. Rules for assembly are as follows:
 2152:                                 * -A '#' sign indicates immediate addressing.
 2153:                                 * -A ',' (comma) indicates indexed addressing
 2154:                                 *       and the next character must be X or Y.
 2155:                                 * -All arguments are assumed to be hex and the
 2156:                                 *       '$' sign shouldn't be used.
 2157:                                 * -Arguments should be separated by 1 or more
 2158:                                 *       spaces or tabs.
 2159:                                 * -Any input after the required number of
 2160:                                 *       arguments is ignored.
 2161:                                 * -Upper or lower case makes no difference.
 2162:                                 *
 2163:                                 *       To signify end of input line, the following
 2164:                                 *commands are available and have the indicated action:
 2165:                                 *   <cr>      - Finds the next opcode for
 2166:                                 *          assembly.  If there was no assembly input,
 2167:                                 *          the next opcode disassembled is retrieved
 2168:                                 *          from the disassembler.
 2169:                                 *   <lf><+>   - Works the same as carriage return
 2170:                                 *          except if there was no assembly input, the
 2171:                                 *          <addr> is incremented and the next <addr> is
 2172:                                 *          disassembled.
 2173:                                 *    <^><->   - Decrements <addr> and the previous
 2174:                                 *          address is then disassembled.
 2175:                                 *    </><=>   - Redisassembles the current address.
 2176:                                 *
 2177:                                 *       To exit the assembler use CONTROL A or . (period).
 2178:                                 *Of course control X and DEL will also allow you to abort.
 2179:                                 *** Equates for assembler ***
 2180:          =00000000              PAGE1   EQU  $00     ;values for page opcodes
 2181:          =00000018              PAGE2   EQU  $18
 2182:          =0000001A              PAGE3   EQU  $1A
 2183:          =000000CD              PAGE4   EQU  $CD
 2184:          =00000000              IMMED   EQU  $0      ;addressing modes
 2185:          =00000001              INDX    EQU  $1
 2186:          =00000002              INDY    EQU  $2
 2187:          =00000003              LIMMED  EQU  $3      ;(long immediate)
 2188:          =00000004              OTHER   EQU  $4
 2189:                                 
 2190:                                 *** Rename variables for assem/disassem ***
 2191:          =000000D4              AMODE   EQU  TMP2    ;addressing mode
 2192:          =000000D5              YFLAG   EQU  TMP3
 2193:          =000000D6              PNORM   EQU  TMP4    ;page for normal opcode
 2194:          =000000D1              OLDPC   EQU  PTR8
 2195:          =000000C3              PC      EQU  PTR1    ;program counter
 2196:          =000000C5              PX      EQU  PTR2    ;page for x indexed
 2197:          =000000C6              PY      EQU  PTR2+1  ;page for y indexed
 2198:          =000000C7              BASEOP  EQU  PTR3    ;base opcode
 2199:          =000000C8              CLASS   EQU  PTR3+1  ;class
 2200:          =000000C9              DISPC   EQU  PTR4    ;pc for disassembler
 2201:          =000000CB              BRADDR  EQU  PTR5    ;relative branch offset
 2202:          =000000CD              MNEPTR  EQU  PTR6    ;pointer to table for dis
 2203:          =000000CF              ASSCOMM EQU  PTR7    ;subcommand for assembler
 2204:                                 
 2205:                                 *** Error messages for assembler ***
 2206:     EA3A EA4C                   MSGDIR  FDB  MSGA1   ;message table index
 2207:     EA3C EA5F                           FDB  MSGA2
 2208:     EA3E EA72                           FDB  MSGA3
 2209:     EA40 EA81                           FDB  MSGA4
 2210:     EA42 EA8E                           FDB  MSGA5
 2211:     EA44 EAA1                           FDB  MSGA6
 2212:     EA46 EAB9                           FDB  MSGA7
 2213:     EA48 EAD4                           FDB  MSGA8
 2214:     EA4A EAE1                           FDB  MSGA9
 2215:     EA4C 49 6D 6D 65 64 20      MSGA1   FCC  'Immed mode illegal'
           EA52 6D 6F 64 65 20 69 
           EA58 6C 6C 65 67 61 6C 
 2216:     EA5E 04                             FCB  EOT
 2217:     EA5F 45 72 72 6F 72 20      MSGA2   FCC  'Error in Mne table'
           EA65 69 6E 20 4D 6E 65 
           EA6B 20 74 61 62 6C 65 
 2218:     EA71 04                             FCB  EOT
 2219:     EA72 49 6C 6C 65 67 61      MSGA3   FCC  'Illegal bit op'
           EA78 6C 20 62 69 74 20 
           EA7E 6F 70 
 2220:     EA80 04                             FCB  EOT
 2221:     EA81 42 61 64 20 61 72      MSGA4   FCC  'Bad argument'
           EA87 67 75 6D 65 6E 74 
 2222:     EA8D 04                             FCB  EOT
 2223:     EA8E 4D 6E 65 6D 6F 6E      MSGA5   FCC  'Mnemonic not found'
           EA94 69 63 20 6E 6F 74 
           EA9A 20 66 6F 75 6E 64 
 2224:     EAA0 04                             FCB  EOT
 2225:     EAA1 55 6E 6B 6E 6F 77      MSGA6   FCC  'Unknown addressing mode'
           EAA7 6E 20 61 64 64 72 
           EAAD 65 73 73 69 6E 67 
           EAB3 20 6D 6F 64 65 
 2226:     EAB8 04                             FCB  EOT
 2227:     EAB9 49 6E 64 65 78 65      MSGA7   FCC  'Indexed addressing assumed'
           EABF 64 20 61 64 64 72 
           EAC5 65 73 73 69 6E 67 
           EACB 20 61 73 73 75 6D 
           EAD1 65 64 
 2228:     EAD3 04                             FCB  EOT
 2229:     EAD4 53 79 6E 74 61 78      MSGA8   FCC  'Syntax error'
           EADA 20 65 72 72 6F 72 
 2230:     EAE0 04                             FCB  EOT
 2231:     EAE1 42 72 61 6E 63 68      MSGA9   FCC  'Branch out of range'
           EAE7 20 6F 75 74 20 6F 
           EAED 66 20 72 61 6E 67 
           EAF3 65 
 2232:     EAF4 04                             FCB  EOT
 2233:                                 
 2234:                                 **********
 2235:                                 *oldpc = rambase;
 2236:                                 *a = wskip();
 2237:                                 *if (a != cr)
 2238:                                 *   buffarg()
 2239:                                 *   a = wskip();
 2240:                                 *   if ( a != cr ) return(error);
 2241:                                 *   oldpc = a;
 2242:          =0000EAF5              ASSEM   EQU  *
 2243:     EAF5 CE 0040                        LDX  #RAMBS
 2244:     EAF8 DF D1                          STX  OLDPC
 2245:     EAFA BD E2FC                        JSR  WSKIP
 2246:     EAFD 27 13                          BEQ  ASSLOOP ;jump if no argument
 2247:     EAFF BD E234                        JSR  BUFFARG
 2248:     EB02 BD E2FC                        JSR  WSKIP
 2249:     EB05 27 07                          BEQ  ASSEM1  ;jump if argument ok
 2250:     EB07 CE EA81                        LDX  #MSGA4  ;"bad argument"
 2251:     EB0A BD E538                        JSR  OUTSTRG
 2252:     EB0D 39                             RTS
 2253:     EB0E DE A9                  ASSEM1  LDX  SHFTREG
 2254:     EB10 DF D1                          STX  OLDPC
 2255:                                 
 2256:                                 *repeat
 2257:                                 *  pc = oldpc;
 2258:                                 *  out2bsp(pc);
 2259:                                 *  disassem();
 2260:                                 *  a=readln();
 2261:                                 *  asscomm = a;  /* save command */
 2262:                                 *  if(a == [^,+,-,/,=]) outcrlf;
 2263:                                 *  if(a == 0) return(error);
 2264:                                 
 2265:     EB12 DE D1                  ASSLOOP LDX  OLDPC
 2266:     EB14 DF C3                          STX  PC
 2267:     EB16 BD E531                        JSR  OUTCRLF
 2268:     EB19 CE 00C3                        LDX  #PC
 2269:     EB1C BD E519                        JSR  OUT2BSP   ;output the address
 2270:     EB1F BD F347                        JSR  DISASSM   ;disassemble opcode
 2271:     EB22 BD E558                        JSR  TABTO
 2272:     EB25 86 3E                          LDAA #PROMPT   ;prompt user
 2273:     EB27 BD E509                        JSR  OUTA      ;output prompt character
 2274:     EB2A BD EBD6                        JSR  READLN    ;read input for assembly
 2275:     EB2D 97 CF                          STAA ASSCOMM
 2276:     EB2F 81 5E                          CMPA #'^'
 2277:     EB31 27 15                          BEQ  ASSLP0    ;jump if '^'
 2278:     EB33 81 2B                          CMPA #'+'
 2279:     EB35 27 11                          BEQ  ASSLP0    ;jump if '+'
 2280:     EB37 81 2D                          CMPA #'-'
 2281:     EB39 27 0D                          BEQ  ASSLP0    ;jump if '-'
 2282:     EB3B 81 2F                          CMPA #'/'
 2283:     EB3D 27 09                          BEQ  ASSLP0    ;jump if '/'
 2284:     EB3F 81 3D                          CMPA #'='
 2285:     EB41 27 05                          BEQ  ASSLP0    ;jump if '='
 2286:     EB43 81 00                          CMPA #$00
 2287:     EB45 26 04                          BNE  ASSLP1    ;jump if none of above
 2288:     EB47 39                             RTS            ;return if bad input
 2289:     EB48 BD E531                ASSLP0  JSR  OUTCRLF
 2290:          =0000EB4B              ASSLP1  EQU  *         ;come here for cr or lf
 2291:     EB4B BD E51F                        JSR  OUTSPAC
 2292:     EB4E BD E51F                        JSR  OUTSPAC
 2293:     EB51 BD E51F                        JSR  OUTSPAC
 2294:     EB54 BD E51F                        JSR  OUTSPAC
 2295:     EB57 BD E51F                        JSR  OUTSPAC
 2296:                                 
 2297:                                 *  b = parse(input); /* get mnemonic */
 2298:                                 *  if(b > 5) print("not found"); asscomm='/';
 2299:                                 *  elseif(b >= 1)
 2300:                                 *     msrch();
 2301:                                 *     if(class==$FF)
 2302:                                 *        print("not found"); asscomm='/';
 2303:                                 *     else
 2304:                                 *        a = doop(opcode,class);
 2305:                                 *        if(a == 0) dispc=0;
 2306:                                 *        else process error; asscomm='/';
 2307:                                 
 2308:     EB5A BD EC1F                        JSR  PARSE
 2309:     EB5D C1 05                          CMPB #$5
 2310:     EB5F 2F 08                          BLE  ASSLP2  ;jump if mnemonic <= 5 chars
 2311:     EB61 CE EA8E                        LDX  #MSGA5  ;"mnemonic not found"
 2312:     EB64 BD E538                        JSR  OUTSTRG
 2313:     EB67 20 2F                          BRA  ASSLP5
 2314:          =0000EB69              ASSLP2  EQU  *
 2315:     EB69 C1 00                          CMPB #$0
 2316:     EB6B 27 2E                          BEQ  ASSLP10 ;jump if no input
 2317:     EB6D BD EC66                        JSR  MSRCH
 2318:     EB70 96 C8                          LDAA CLASS
 2319:     EB72 81 FF                          CMPA #$FF
 2320:     EB74 26 08                          BNE  ASSLP3
 2321:     EB76 CE EA8E                        LDX  #MSGA5  ;"mnemonic not found"
 2322:     EB79 BD E538                        JSR  OUTSTRG
 2323:     EB7C 20 1A                          BRA  ASSLP5
 2324:     EB7E BD EC9E                ASSLP3  JSR  DOOP
 2325:     EB81 81 00                          CMPA #$00
 2326:     EB83 26 07                          BNE  ASSLP4  ;jump if doop error
 2327:     EB85 CE 0000                        LDX  #$00
 2328:     EB88 DF C9                          STX  DISPC   ;indicate good assembly
 2329:     EB8A 20 0F                          BRA  ASSLP10
 2330:     EB8C 4A                     ASSLP4  DECA         ;a = error message index
 2331:     EB8D 16                             TAB
 2332:     EB8E CE EA3A                        LDX  #MSGDIR
 2333:     EB91 3A                             ABX
 2334:     EB92 3A                             ABX
 2335:     EB93 EE 00                          LDX  0,X
 2336:     EB95 BD E538                        JSR  OUTSTRG ;output error message
 2337:     EB98 7F 00CF                ASSLP5  CLR  ASSCOMM ;error command
 2338:                                 
 2339:                                 *  /* compute next address - asscomm holds subcommand
 2340:                                 *     and dispc indicates if valid assembly occured. */
 2341:                                 *  if(asscomm== ^ or -) oldpc--;
 2342:                                 *  if(asscomm==(lf or + or cr)
 2343:                                 *     if(dispc==0) oldpc=pc;   /* good assembly */
 2344:                                 *     else
 2345:                                 *        if(asscomm==lf or +) dispc= ++oldpc;
 2346:                                 *        oldpc=dispc;
 2347:                                 *until(eot)
 2348:          =0000EB9B              ASSLP10 EQU  *
 2349:     EB9B 96 CF                          LDAA ASSCOMM
 2350:     EB9D 81 5E                          CMPA #'^'
 2351:     EB9F 27 04                          BEQ  ASSLPA     ;jump if '^'
 2352:     EBA1 81 2D                          CMPA #'-'
 2353:     EBA3 26 07                          BNE  ASSLP11    ;jump not '-'
 2354:     EBA5 DE D1                  ASSLPA  LDX  OLDPC      ;back up for '^' or '-'
 2355:     EBA7 09                             DEX
 2356:     EBA8 DF D1                          STX  OLDPC
 2357:     EBAA 20 27                          BRA  ASSLP15
 2358:     EBAC 81 0A                  ASSLP11 CMPA #$0A
 2359:     EBAE 27 08                          BEQ  ASSLP12    ;jump if linefeed
 2360:     EBB0 81 2B                          CMPA #'+'
 2361:     EBB2 27 04                          BEQ  ASSLP12    ;jump if '+'
 2362:     EBB4 81 0D                          CMPA #$0D
 2363:     EBB6 26 1B                          BNE  ASSLP15    ;jump if not cr
 2364:     EBB8 DE C9                  ASSLP12 LDX  DISPC
 2365:     EBBA 26 06                          BNE  ASSLP13    ;jump if dispc != 0
 2366:     EBBC DE C3                          LDX  PC
 2367:     EBBE DF D1                          STX  OLDPC
 2368:     EBC0 20 11                          BRA  ASSLP15
 2369:     EBC2 81 0A                  ASSLP13 CMPA #$0A
 2370:     EBC4 27 04                          BEQ  ASSLPB    ;jump not lf
 2371:     EBC6 81 2B                          CMPA #'+'
 2372:     EBC8 26 05                          BNE  ASSLP14   ;jump not lf or '+'
 2373:     EBCA DE D1                  ASSLPB  LDX  OLDPC
 2374:     EBCC 08                             INX
 2375:     EBCD DF C9                          STX  DISPC
 2376:     EBCF DE C9                  ASSLP14 LDX  DISPC
 2377:     EBD1 DF D1                          STX  OLDPC
 2378:     EBD3 7E EB12                ASSLP15 JMP  ASSLOOP
 2379:                                 
 2380:                                 ****************
 2381:                                 *  readln() --- Read input from terminal into buffer
 2382:                                 * until a command character is read (cr,lf,/,^).
 2383:                                 * If more chars are typed than the buffer will hold,
 2384:                                 * the extra characters are overwritten on the end.
 2385:                                 *  On exit: b=number of chars read, a=0 if quit,
 2386:                                 * else a=next command.
 2387:                                 ****************
 2388:                                 *for(b==0;b<=bufflng;b++) inbuff[b] = cr;
 2389:                                 
 2390:     EBD6 5F                     READLN  CLRB
 2391:     EBD7 86 0D                          LDAA #$0D    ;carriage ret
 2392:     EBD9 CE 007E                RLN0    LDX  #INBUFF
 2393:     EBDC 3A                             ABX
 2394:     EBDD A7 00                          STAA 0,X     ;initialize input buffer
 2395:     EBDF 5C                             INCB
 2396:     EBE0 C1 23                          CMPB #BUFFLNG
 2397:     EBE2 2D F5                          BLT  RLN0
 2398:                                 *b=0;
 2399:                                 *repeat
 2400:                                 *  if(a == (ctla, cntlc, cntld, cntlx, del))
 2401:                                 *     return(a=0);
 2402:                                 *  if(a == backspace)
 2403:                                 *     if(b > 0) b--;
 2404:                                 *     else b=0;
 2405:                                 *  else  inbuff[b] = upcase(a);
 2406:                                 *  if(b < bufflng) b++;
 2407:                                 *until (a == [cr,lf,+,^,-,/,=])
 2408:                                 *return(a);
 2409:                                 
 2410:     EBE4 5F                             CLRB
 2411:     EBE5 BD E564                RLN1    JSR  INCHAR
 2412:     EBE8 81 7F                          CMPA #DEL    ;Delete
 2413:     EBEA 27 31                          BEQ  RLNQUIT
 2414:     EBEC 81 18                          CMPA #CTLX   ;Control X
 2415:     EBEE 27 2D                          BEQ  RLNQUIT
 2416:     EBF0 81 01                          CMPA #CTLA   ;Control A
 2417:     EBF2 27 29                          BEQ  RLNQUIT
 2418:     EBF4 81 2E                          CMPA #$2E    ;Period
 2419:     EBF6 27 25                          BEQ  RLNQUIT
 2420:     EBF8 81 03                          CMPA #$03    ;Control C
 2421:     EBFA 27 21                          BEQ  RLNQUIT
 2422:     EBFC 81 04                          CMPA #$04    ;Control D
 2423:     EBFE 27 1D                          BEQ  RLNQUIT
 2424:     EC00 81 08                          CMPA #$08    ;backspace
 2425:     EC02 26 05                          BNE  RLN2
 2426:     EC04 5A                             DECB
 2427:     EC05 2E DE                          BGT  RLN1
 2428:     EC07 20 CD                          BRA  READLN  ;start over
 2429:     EC09 CE 007E                RLN2    LDX  #INBUFF
 2430:     EC0C 3A                             ABX
 2431:     EC0D BD E1A7                        JSR  UPCASE
 2432:     EC10 A7 00                          STAA 0,X     ;put char in buffer
 2433:     EC12 C1 23                          CMPB #BUFFLNG        ;max buffer length
 2434:     EC14 2C 01                          BGE  RLN3    ;jump if buffer full
 2435:     EC16 5C                             INCB         ;move buffer pointer
 2436:     EC17 BD EC4B                RLN3    JSR  ASSCHEK ;check for subcommand
 2437:     EC1A 26 C9                          BNE  RLN1
 2438:     EC1C 39                             RTS
 2439:     EC1D 4F                     RLNQUIT CLRA         ;quit
 2440:     EC1E 39                             RTS          ;return
 2441:                                 
 2442:                                 
 2443:                                 **********
 2444:                                 *  parse() -parse out the mnemonic from INBUFF
 2445:                                 * to COMBUFF. on exit: b=number of chars parsed.
 2446:                                 **********
 2447:                                 *combuff[3] = <space>;   initialize 4th character to space.
 2448:                                 *ptrbuff[] = inbuff[];
 2449:                                 *a=wskip();
 2450:                                 *for (b = 0; b = 5; b++)
 2451:                                 *   a=readbuff(); incbuff();
 2452:                                 *   if (a = (cr,lf,^,/,wspace)) return(b);
 2453:                                 *   combuff[b] = upcase(a);
 2454:                                 *return(b);
 2455:                                 
 2456:     EC1F 86 20                  PARSE   LDAA #$20
 2457:     EC21 97 A4                          STAA COMBUFF+3
 2458:     EC23 CE 007E                        LDX  #INBUFF         ;initialize buffer ptr
 2459:     EC26 DF C1                          STX  PTR0
 2460:     EC28 BD E2FC                        JSR  WSKIP           ;find first character
 2461:     EC2B 5F                             CLRB
 2462:     EC2C BD E2E7                PARSLP  JSR  READBUFF        ;read character
 2463:     EC2F BD E2EE                        JSR  INCBUFF
 2464:     EC32 BD E30C                        JSR  WCHEK
 2465:     EC35 27 13                          BEQ  PARSRT          ;jump if whitespace
 2466:     EC37 BD EC4B                        JSR  ASSCHEK
 2467:     EC3A 27 0E                          BEQ  PARSRT          ;jump if end of line
 2468:     EC3C BD E1A7                        JSR  UPCASE          ;convert to upper case
 2469:     EC3F CE 00A1                        LDX  #COMBUFF
 2470:     EC42 3A                             ABX
 2471:     EC43 A7 00                          STAA 0,X             ;store in combuff
 2472:     EC45 5C                             INCB
 2473:     EC46 C1 05                          CMPB #$5
 2474:     EC48 2F E2                          BLE  PARSLP          ;loop 6 times
 2475:     EC4A 39                     PARSRT  RTS
 2476:                                 
 2477:                                 
 2478:                                 ****************
 2479:                                 *  asschek() -perform compares for
 2480:                                 * lf, cr, ^, /, +, -, =
 2481:                                 ****************
 2482:     EC4B 81 0A                  ASSCHEK CMPA #$0A    ;linefeed
 2483:     EC4D 27 16                          BEQ  ASSCHK1
 2484:     EC4F 81 0D                          CMPA #$0D    ;carriage ret
 2485:     EC51 27 12                          BEQ  ASSCHK1
 2486:     EC53 81 5E                          CMPA #'^'    ;up arrow
 2487:     EC55 27 0E                          BEQ  ASSCHK1
 2488:     EC57 81 2F                          CMPA #'/'    ;slash
 2489:     EC59 27 0A                          BEQ  ASSCHK1
 2490:     EC5B 81 2B                          CMPA #'+'    ;plus
 2491:     EC5D 27 06                          BEQ  ASSCHK1
 2492:     EC5F 81 2D                          CMPA #'-'    ;minus
 2493:     EC61 27 02                          BEQ  ASSCHK1
 2494:     EC63 81 3D                          CMPA #'='    ;equals
 2495:     EC65 39                     ASSCHK1 RTS
 2496:                                 
 2497:                                 
 2498:                                 *********
 2499:                                 *  msrch() --- Search MNETABL for mnemonic in COMBUFF.
 2500:                                 *stores base opcode at baseop and class at class.
 2501:                                 *  Class = FF if not found.
 2502:                                 **********
 2503:                                 *while ( != EOF )
 2504:                                 *   if (COMBUFF[0-3] = MNETABL[0-3])
 2505:                                 *      return(MNETABL[4],MNETABL[5]);
 2506:                                 *   else *MNETABL =+ 6
 2507:                                 
 2508:     EC66 CE EFC8                MSRCH   LDX  #MNETABL        ;pointer to mnemonic table
 2509:     EC69 18CE 00A1                      LDY  #COMBUFF        ;pointer to string
 2510:     EC6D 20 03                          BRA  MSRCH1
 2511:          =0000EC6F              MSNEXT  EQU  *
 2512:     EC6F C6 06                          LDAB #6
 2513:     EC71 3A                             ABX                  ;point to next table entry
 2514:     EC72 A6 00                  MSRCH1  LDAA 0,X             ;read table
 2515:     EC74 81 04                          CMPA #EOT
 2516:     EC76 26 05                          BNE  MSRCH2          ;jump if not end of table
 2517:     EC78 86 FF                          LDAA #$FF
 2518:     EC7A 97 C8                          STAA CLASS           ;FF = not in table
 2519:     EC7C 39                             RTS
 2520:     EC7D 18A1 00                MSRCH2  CMPA 0,Y             ;op[0] = tabl[0] ?
 2521:     EC80 26 ED                          BNE  MSNEXT
 2522:     EC82 A6 01                          LDAA 1,X
 2523:     EC84 18A1 01                        CMPA 1,Y             ;op[1] = tabl[1] ?
 2524:     EC87 26 E6                          BNE  MSNEXT
 2525:     EC89 A6 02                          LDAA 2,X
 2526:     EC8B 18A1 02                        CMPA 2,Y             ;op[2] = tabl[2] ?
 2527:     EC8E 26 DF                          BNE  MSNEXT
 2528:     EC90 A6 03                          LDAA 3,X
 2529:     EC92 18A1 03                        CMPA 3,Y             ;op[2] = tabl[2] ?
 2530:     EC95 26 D8                          BNE  MSNEXT
 2531:     EC97 EC 04                          LDD  4,X             ;opcode, class
 2532:     EC99 97 C7                          STAA BASEOP
 2533:     EC9B D7 C8                          STAB CLASS
 2534:     EC9D 39                             RTS
 2535:                                 
 2536:                                 **********
 2537:                                 **   doop(baseop,class) --- process mnemonic.
 2538:                                 **   on exit: a=error code corresponding to error
 2539:                                 **                                     messages.
 2540:                                 **********
 2541:                                 *amode = OTHER; /* addressing mode */
 2542:                                 *yflag = 0;     /* ynoimm, nlimm, and cpd flag */
 2543:                                 *x[] = ptrbuff[]
 2544:                                 
 2545:          =0000EC9E              DOOP    EQU  *
 2546:     EC9E 86 04                          LDAA #OTHER
 2547:     ECA0 97 D4                          STAA AMODE   ;mode
 2548:     ECA2 7F 00D5                        CLR  YFLAG
 2549:     ECA5 DE C1                          LDX  PTR0
 2550:                                 
 2551:                                 *while (*x != end of buffer)
 2552:                                 *   if (x[0]++ == ',')
 2553:                                 *      if (x[0] == 'y') amode = INDY;
 2554:                                 *      else amod = INDX;
 2555:                                 *      break;
 2556:                                 *a = wskip()
 2557:                                 *if( a == '#' ) amode = IMMED;
 2558:                                 
 2559:     ECA7 8C 00A1                DOPLP1  CPX  #ENDBUFF ;(end of buffer)
 2560:     ECAA 27 1B                          BEQ  DOOP1   ;jump if end of buffer
 2561:     ECAC EC 00                          LDD  0,X     ;read 2 chars from buffer
 2562:     ECAE 08                             INX          ;move pointer
 2563:     ECAF 81 2C                          CMPA #','
 2564:     ECB1 26 F4                          BNE  DOPLP1
 2565:     ECB3 C1 59                          CMPB #'Y'    ;look for ",y"
 2566:     ECB5 26 06                          BNE  DOPLP2
 2567:     ECB7 86 02                          LDAA #INDY
 2568:     ECB9 97 D4                          STAA AMODE
 2569:     ECBB 20 0A                          BRA  DOOP1
 2570:     ECBD C1 58                  DOPLP2  CMPB #'X'    ;look for ",x"
 2571:     ECBF 26 06                          BNE  DOOP1   ;jump if not x
 2572:     ECC1 86 01                          LDAA #INDX
 2573:     ECC3 97 D4                          STAA AMODE
 2574:     ECC5 20 00                          BRA  DOOP1
 2575:     ECC7 BD E2FC                DOOP1   JSR  WSKIP
 2576:     ECCA 81 23                          CMPA #'#'    ;look for immediate mode
 2577:     ECCC 26 07                          BNE  DOOP2
 2578:     ECCE BD E2EE                        JSR  INCBUFF ;point at argument
 2579:     ECD1 86 00                          LDAA #IMMED
 2580:     ECD3 97 D4                          STAA AMODE
 2581:          =0000ECD5              DOOP2   EQU  *
 2582:                                 
 2583:                                 *switch(class)
 2584:     ECD5 D6 C8                          LDAB CLASS
 2585:     ECD7 C1 02                          CMPB #P2INH
 2586:     ECD9 26 03                          BNE  DOSW1
 2587:     ECDB 7E ED3C                        JMP  DOP2I
 2588:     ECDE C1 01                  DOSW1   CMPB #INH
 2589:     ECE0 26 03                          BNE  DOSW2
 2590:     ECE2 7E ED41                        JMP  DOINH
 2591:     ECE5 C1 05                  DOSW2   CMPB #REL
 2592:     ECE7 26 03                          BNE  DOSW3
 2593:     ECE9 7E ED48                        JMP  DOREL
 2594:     ECEC C1 08                  DOSW3   CMPB #LIMM
 2595:     ECEE 26 03                          BNE  DOSW4
 2596:     ECF0 7E ED77                        JMP  DOLIM
 2597:     ECF3 C1 07                  DOSW4   CMPB #NIMM
 2598:     ECF5 26 03                          BNE  DOSW5
 2599:     ECF7 7E ED81                        JMP  DONOI
 2600:     ECFA C1 03                  DOSW5   CMPB #GEN
 2601:     ECFC 26 03                          BNE  DOSW6
 2602:     ECFE 7E ED8A                        JMP  DOGENE
 2603:     ED01 C1 04                  DOSW6   CMPB #GRP2
 2604:     ED03 26 03                          BNE  DOSW7
 2605:     ED05 7E ED98                        JMP  DOGRP
 2606:     ED08 C1 15                  DOSW7   CMPB #CPD
 2607:     ED0A 26 03                          BNE  DOSW8
 2608:     ED0C 7E EDCA                        JMP  DOCPD
 2609:     ED0F C1 10                  DOSW8   CMPB #XNIMM
 2610:     ED11 26 03                          BNE  DOSW9
 2611:     ED13 7E EDEB                        JMP  DOXNOI
 2612:     ED16 C1 09                  DOSW9   CMPB #XLIMM
 2613:     ED18 26 03                          BNE  DOSW10
 2614:     ED1A 7E EDF4                        JMP  DOXLI
 2615:     ED1D C1 12                  DOSW10  CMPB #YNIMM
 2616:     ED1F 26 03                          BNE  DOSW11
 2617:     ED21 7E EE0C                        JMP  DOYNOI
 2618:     ED24 C1 11                  DOSW11  CMPB #YLIMM
 2619:     ED26 26 03                          BNE  DOSW12
 2620:     ED28 7E EE15                        JMP  DOYLI
 2621:     ED2B C1 13                  DOSW12  CMPB #BTB
 2622:     ED2D 26 03                          BNE  DOSW13
 2623:     ED2F 7E EE34                        JMP  DOBTB
 2624:     ED32 C1 14                  DOSW13  CMPB #SETCLR
 2625:     ED34 26 03                          BNE  DODEF
 2626:     ED36 7E EE34                        JMP  DOSET
 2627:                                 
 2628:                                 *   default: return("error in mnemonic table");
 2629:                                 
 2630:     ED39 86 02                  DODEF   LDAA #$2
 2631:     ED3B 39                             RTS
 2632:                                 
 2633:                                 *  case P2INH: emit(PAGE2)
 2634:                                 
 2635:     ED3C 86 18                  DOP2I   LDAA #PAGE2
 2636:     ED3E BD EFBD                        JSR  EMIT
 2637:                                 
 2638:                                 *  case INH: emit(baseop);
 2639:                                 *       return(0);
 2640:                                 
 2641:     ED41 96 C7                  DOINH   LDAA BASEOP
 2642:     ED43 BD EFBD                        JSR  EMIT
 2643:     ED46 4F                             CLRA
 2644:     ED47 39                             RTS
 2645:                                 
 2646:                                 *  case REL: a = assarg();
 2647:                                 *            if(a=4) return(a);
 2648:                                 *            d = address - pc + 2;
 2649:                                 *            if ($7f >= d >= $ff82)
 2650:                                 *               return (out of range);
 2651:                                 *            emit(opcode);
 2652:                                 *            emit(offset);
 2653:                                 *            return(0);
 2654:                                 
 2655:     ED48 BD EF9F                DOREL   JSR  ASSARG
 2656:     ED4B 81 04                          CMPA #$04
 2657:     ED4D 26 01                          BNE  DOREL1  ;jump if arg ok
 2658:     ED4F 39                             RTS
 2659:     ED50 DC A9                  DOREL1  LDD  SHFTREG ;get branch address
 2660:     ED52 DE C3                          LDX  PC      ;get program counter
 2661:     ED54 08                             INX
 2662:     ED55 08                             INX          ;point to end of opcode
 2663:     ED56 DF CB                          STX  BRADDR
 2664:     ED58 93 CB                          SUBD BRADDR  ;calculate offset
 2665:     ED5A DD CB                          STD  BRADDR  ;save result
 2666:     ED5C 1A83 007F                      CPD #$7F    ;in range ?
 2667:     ED60 23 09                          BLS  DOREL2  ;jump if in range
 2668:     ED62 1A83 FF80                      CPD #$FF80
 2669:     ED66 24 03                          BHS  DOREL2  ;jump if in range
 2670:     ED68 86 09                          LDAA #$09    ;'Out of range'
 2671:     ED6A 39                             RTS
 2672:     ED6B 96 C7                  DOREL2  LDAA BASEOP
 2673:     ED6D BD EFBD                        JSR  EMIT    ;emit opcode
 2674:     ED70 96 CC                          LDAA BRADDR+1
 2675:     ED72 BD EFBD                        JSR  EMIT    ;emit offset
 2676:     ED75 4F                             CLRA         ;normal return
 2677:     ED76 39                             RTS
 2678:                                 
 2679:                                 *  case LIMM: if (amode == IMMED) amode = LIMMED;
 2680:                                 
 2681:     ED77 96 D4                  DOLIM   LDAA AMODE
 2682:     ED79 81 00                          CMPA #IMMED
 2683:     ED7B 26 04                          BNE  DONOI
 2684:     ED7D 86 03                          LDAA #LIMMED
 2685:     ED7F 97 D4                          STAA AMODE
 2686:                                 
 2687:                                 *  case NIMM: if (amode == IMMED)
 2688:                                 *                return("Immediate mode illegal");
 2689:                                 
 2690:     ED81 96 D4                  DONOI   LDAA AMODE
 2691:     ED83 81 00                          CMPA #IMMED
 2692:     ED85 26 03                          BNE  DOGENE  ;jump if not immediate
 2693:     ED87 86 01                          LDAA #$1     ;"immediate mode illegal"
 2694:     ED89 39                             RTS
 2695:                                 
 2696:                                 *  case GEN: dogen(baseop,amode,PAGE1,PAGE1,PAGE2);
 2697:                                 *            return;
 2698:                                 
 2699:     ED8A 86 00                  DOGENE  LDAA #PAGE1
 2700:     ED8C 97 D6                          STAA PNORM
 2701:     ED8E 97 C5                          STAA PX
 2702:     ED90 86 18                          LDAA #PAGE2
 2703:     ED92 97 C6                          STAA PY
 2704:     ED94 BD EED0                        JSR  DOGEN
 2705:     ED97 39                             RTS
 2706:                                 
 2707:                                 *  case GRP2: if (amode == INDY)
 2708:                                 *                emit(PAGE2);
 2709:                                 *                amode = INDX;
 2710:                                 *             if( amode == INDX )
 2711:                                 *                doindx(baseop);
 2712:                                 *             else a = assarg();
 2713:                                 *                if(a=4) return(a);
 2714:                                 *                emit(opcode+0x10);
 2715:                                 *                emit(extended address);
 2716:                                 *             return;
 2717:                                 
 2718:     ED98 96 D4                  DOGRP   LDAA AMODE
 2719:     ED9A 81 02                          CMPA #INDY
 2720:     ED9C 26 09                          BNE  DOGRP1
 2721:     ED9E 86 18                          LDAA #PAGE2
 2722:     EDA0 BD EFBD                        JSR  EMIT
 2723:     EDA3 86 01                          LDAA #INDX
 2724:     EDA5 97 D4                          STAA AMODE
 2725:          =0000EDA7              DOGRP1  EQU  *
 2726:     EDA7 96 D4                          LDAA AMODE
 2727:     EDA9 81 01                          CMPA #INDX
 2728:     EDAB 26 04                          BNE  DOGRP2
 2729:     EDAD BD EF70                        JSR  DOINDEX
 2730:     EDB0 39                             RTS
 2731:          =0000EDB1              DOGRP2  EQU  *
 2732:     EDB1 96 C7                          LDAA BASEOP
 2733:     EDB3 8B 10                          ADDA #$10
 2734:     EDB5 BD EFBD                        JSR  EMIT
 2735:     EDB8 BD EF9F                        JSR  ASSARG
 2736:     EDBB 81 04                          CMPA #$04
 2737:     EDBD 27 0A                          BEQ  DOGRPRT ;jump if bad arg
 2738:     EDBF DC A9                          LDD  SHFTREG ;extended address
 2739:     EDC1 BD EFBD                        JSR  EMIT
 2740:     EDC4 17                             TBA
 2741:     EDC5 BD EFBD                        JSR  EMIT
 2742:     EDC8 4F                             CLRA
 2743:     EDC9 39                     DOGRPRT RTS
 2744:                                 
 2745:                                 *  case CPD: if (amode == IMMED)
 2746:                                 *               amode = LIMMED; /* cpd */
 2747:                                 *            if( amode == INDY ) yflag = 1;
 2748:                                 *            dogen(baseop,amode,PAGE3,PAGE3,PAGE4);
 2749:                                 *            return;
 2750:                                 
 2751:     EDCA 96 D4                  DOCPD   LDAA AMODE
 2752:     EDCC 81 00                          CMPA #IMMED
 2753:     EDCE 26 04                          BNE  DOCPD1
 2754:     EDD0 86 03                          LDAA #LIMMED
 2755:     EDD2 97 D4                          STAA AMODE
 2756:     EDD4 96 D4                  DOCPD1  LDAA AMODE
 2757:     EDD6 81 02                          CMPA #INDY
 2758:     EDD8 26 03                          BNE  DOCPD2
 2759:     EDDA 7C 00D5                        INC  YFLAG
 2760:     EDDD 86 1A                  DOCPD2  LDAA #PAGE3
 2761:     EDDF 97 D6                          STAA PNORM
 2762:     EDE1 97 C5                          STAA PX
 2763:     EDE3 86 CD                          LDAA #PAGE4
 2764:     EDE5 97 C6                          STAA PY
 2765:     EDE7 BD EED0                        JSR  DOGEN
 2766:     EDEA 39                             RTS
 2767:                                 
 2768:                                 *  case XNIMM: if (amode == IMMED)      /* stx */
 2769:                                 *                 return("Immediate mode illegal");
 2770:                                 
 2771:     EDEB 96 D4                  DOXNOI  LDAA AMODE
 2772:     EDED 81 00                          CMPA #IMMED
 2773:     EDEF 26 03                          BNE  DOXLI
 2774:     EDF1 86 01                          LDAA #$1     ;"immediate mode illegal"
 2775:     EDF3 39                             RTS
 2776:                                 
 2777:                                 *  case XLIMM: if (amode == IMMED)  /* cpx, ldx */
 2778:                                 *                 amode = LIMMED;
 2779:                                 *              dogen(baseop,amode,PAGE1,PAGE1,PAGE4);
 2780:                                 *              return;
 2781:                                 
 2782:     EDF4 96 D4                  DOXLI   LDAA AMODE
 2783:     EDF6 81 00                          CMPA #IMMED
 2784:     EDF8 26 04                          BNE  DOXLI1
 2785:     EDFA 86 03                          LDAA #LIMMED
 2786:     EDFC 97 D4                          STAA AMODE
 2787:     EDFE 86 00                  DOXLI1  LDAA #PAGE1
 2788:     EE00 97 D6                          STAA PNORM
 2789:     EE02 97 C5                          STAA PX
 2790:     EE04 86 CD                          LDAA #PAGE4
 2791:     EE06 97 C6                          STAA PY
 2792:     EE08 BD EED0                        JSR  DOGEN
 2793:     EE0B 39                             RTS
 2794:                                 
 2795:                                 *  case YNIMM: if (amode == IMMED)      /* sty */
 2796:                                 *                 return("Immediate mode illegal");
 2797:                                 
 2798:     EE0C 96 D4                  DOYNOI  LDAA AMODE
 2799:     EE0E 81 00                          CMPA #IMMED
 2800:     EE10 26 03                          BNE  DOYLI
 2801:     EE12 86 01                          LDAA #$1     ;"immediate mode illegal"
 2802:     EE14 39                             RTS
 2803:                                 
 2804:                                 *  case YLIMM: if (amode == INDY) yflag = 1;/* cpy, ldy */
 2805:                                 *              if(amode == IMMED) amode = LIMMED;
 2806:                                 *              dogen(opcode,amode,PAGE2,PAGE3,PAGE2);
 2807:                                 *              return;
 2808:                                 
 2809:     EE15 96 D4                  DOYLI   LDAA AMODE
 2810:     EE17 81 02                          CMPA #INDY
 2811:     EE19 26 03                          BNE  DOYLI1
 2812:     EE1B 7C 00D5                        INC  YFLAG
 2813:     EE1E 81 00                  DOYLI1  CMPA #IMMED
 2814:     EE20 26 04                          BNE  DOYLI2
 2815:     EE22 86 03                          LDAA #LIMMED
 2816:     EE24 97 D4                          STAA AMODE
 2817:     EE26 86 18                  DOYLI2  LDAA #PAGE2
 2818:     EE28 97 D6                          STAA PNORM
 2819:     EE2A 97 C6                          STAA PY
 2820:     EE2C 86 1A                          LDAA #PAGE3
 2821:     EE2E 97 C5                          STAA PX
 2822:     EE30 BD EED0                        JSR  DOGEN
 2823:     EE33 39                             RTS
 2824:                                 
 2825:                                 *  case BTB:        /* bset, bclr */
 2826:                                 *  case SETCLR: a = bitop(baseop,amode,class);
 2827:                                 *               if(a=0) return(a = 3);
 2828:                                 *               if( amode == INDY )
 2829:                                 *                  emit(PAGE2);
 2830:                                 *                  amode = INDX;
 2831:                                 
 2832:          =0000EE34              DOBTB   EQU  *
 2833:     EE34 BD EEAA                DOSET   JSR  BITOP
 2834:     EE37 81 00                          CMPA #$00
 2835:     EE39 26 03                          BNE  DOSET1
 2836:     EE3B 86 03                          LDAA #$3     ;"illegal bit op"
 2837:     EE3D 39                             RTS
 2838:     EE3E 96 D4                  DOSET1  LDAA AMODE
 2839:     EE40 81 02                          CMPA #INDY
 2840:     EE42 26 09                          BNE  DOSET2
 2841:     EE44 86 18                          LDAA #PAGE2
 2842:     EE46 BD EFBD                        JSR  EMIT
 2843:     EE49 86 01                          LDAA #INDX
 2844:     EE4B 97 D4                          STAA AMODE
 2845:          =0000EE4D              DOSET2  EQU  *
 2846:                                 
 2847:                                 *               emit(baseop);
 2848:                                 *               a = assarg();
 2849:                                 *               if(a = 4) return(a);
 2850:                                 *               emit(index offset);
 2851:                                 *               if( amode == INDX )
 2852:                                 *                  Buffptr += 2;      /* skip ,x or ,y */
 2853:                                 
 2854:     EE4D 96 C7                          LDAA BASEOP
 2855:     EE4F BD EFBD                        JSR  EMIT
 2856:     EE52 BD EF9F                        JSR  ASSARG
 2857:     EE55 81 04                          CMPA #$04
 2858:     EE57 26 01                          BNE  DOSET22    ;     jump if arg ok
 2859:     EE59 39                             RTS
 2860:     EE5A 96 AA                  DOSET22 LDAA SHFTREG+1   ;    index offset
 2861:     EE5C BD EFBD                        JSR  EMIT
 2862:     EE5F 96 D4                          LDAA AMODE
 2863:     EE61 81 01                          CMPA #INDX
 2864:     EE63 26 06                          BNE  DOSET3
 2865:     EE65 BD E2EE                        JSR  INCBUFF
 2866:     EE68 BD E2EE                        JSR  INCBUFF
 2867:          =0000EE6B              DOSET3  EQU  *
 2868:                                 
 2869:                                 *               a = assarg();
 2870:                                 *               if(a = 4) return(a);
 2871:                                 *               emit(mask);   /* mask */
 2872:                                 *               if( class == SETCLR )
 2873:                                 *                  return;
 2874:                                 
 2875:     EE6B BD EF9F                        JSR  ASSARG
 2876:     EE6E 81 04                          CMPA #$04
 2877:     EE70 26 01                          BNE  DOSET33     ;    jump if arg ok
 2878:     EE72 39                             RTS
 2879:     EE73 96 AA                  DOSET33 LDAA SHFTREG+1    ;   mask
 2880:     EE75 BD EFBD                        JSR  EMIT
 2881:     EE78 96 C8                          LDAA CLASS
 2882:     EE7A 81 14                          CMPA #SETCLR
 2883:     EE7C 26 02                          BNE  DOSET4
 2884:     EE7E 4F                             CLRA
 2885:     EE7F 39                             RTS
 2886:          =0000EE80              DOSET4  EQU  *
 2887:                                 
 2888:                                 *               a = assarg();
 2889:                                 *               if(a = 4) return(a);
 2890:                                 *               d = (pc+1) - shftreg;
 2891:                                 *               if ($7f >= d >= $ff82)
 2892:                                 *                  return (out of range);
 2893:                                 *               emit(branch offset);
 2894:                                 *               return(0);
 2895:                                 
 2896:     EE80 BD EF9F                        JSR  ASSARG
 2897:     EE83 81 04                          CMPA #$04
 2898:     EE85 26 01                          BNE  DOSET5        ;  jump if arg ok
 2899:     EE87 39                             RTS
 2900:     EE88 DE C3                  DOSET5  LDX  PC             ; program counter
 2901:     EE8A 08                             INX                  ;point to next inst
 2902:     EE8B DF CB                          STX  BRADDR          ;save pc value
 2903:     EE8D DC A9                          LDD  SHFTREG         ;get branch address
 2904:     EE8F 93 CB                          SUBD BRADDR          ;calculate offset
 2905:     EE91 1A83 007F                      CPD #$7F
 2906:     EE95 23 0D                          BLS  DOSET6          ;jump if in range
 2907:     EE97 1A83 FF80                      CPD #$FF80
 2908:     EE9B 24 07                          BHS  DOSET6          ;jump if in range
 2909:     EE9D 4F                             CLRA
 2910:     EE9E BD EFBD                        JSR  EMIT
 2911:     EEA1 86 09                          LDAA #$09            ;'out of range'
 2912:     EEA3 39                             RTS
 2913:     EEA4 17                     DOSET6  TBA                  ;offset
 2914:     EEA5 BD EFBD                        JSR  EMIT
 2915:     EEA8 4F                             CLRA
 2916:     EEA9 39                             RTS
 2917:                                 
 2918:                                 
 2919:                                 **********
 2920:                                 **   bitop(baseop,amode,class) --- adjust opcode on bit
 2921:                                 **       manipulation instructions.  Returns opcode in a
 2922:                                 **       or a = 0 if error
 2923:                                 **********
 2924:                                 *if( amode == INDX || amode == INDY ) return(op);
 2925:                                 *if( class == SETCLR ) return(op-8);
 2926:                                 *else if(class==BTB) return(op-12);
 2927:                                 *else fatal("bitop");
 2928:                                 
 2929:          =0000EEAA              BITOP   EQU  *
 2930:     EEAA 96 D4                          LDAA AMODE
 2931:     EEAC D6 C8                          LDAB CLASS
 2932:     EEAE 81 01                          CMPA #INDX
 2933:     EEB0 26 01                          BNE  BITOP1
 2934:     EEB2 39                             RTS
 2935:     EEB3 81 02                  BITOP1  CMPA #INDY
 2936:     EEB5 26 01                          BNE  BITOP2  ;jump not indexed
 2937:     EEB7 39                             RTS
 2938:     EEB8 C1 14                  BITOP2  CMPB #SETCLR
 2939:     EEBA 26 07                          BNE  BITOP3  ;jump not bset,bclr
 2940:     EEBC 96 C7                          LDAA BASEOP  ;get opcode
 2941:     EEBE 80 08                          SUBA #8
 2942:     EEC0 97 C7                          STAA BASEOP
 2943:     EEC2 39                             RTS
 2944:     EEC3 C1 13                  BITOP3  CMPB #BTB
 2945:     EEC5 26 07                          BNE  BITOP4  ;jump not bit branch
 2946:     EEC7 96 C7                          LDAA BASEOP  ;get opcode
 2947:     EEC9 80 0C                          SUBA #12
 2948:     EECB 97 C7                          STAA BASEOP
 2949:     EECD 39                             RTS
 2950:     EECE 4F                     BITOP4  CLRA         ;0 = fatal bitop
 2951:     EECF 39                             RTS
 2952:                                 
 2953:                                 **********
 2954:                                 **   dogen(baseop,mode,pnorm,px,py) - process
 2955:                                 ** general addressing modes. Returns a = error #.
 2956:                                 **********
 2957:                                 *pnorm = page for normal addressing modes: IMM,DIR,EXT
 2958:                                 *px = page for INDX addressing
 2959:                                 *py = page for INDY addressing
 2960:                                 *switch(amode)
 2961:     EED0 96 D4                  DOGEN   LDAA AMODE
 2962:     EED2 81 03                          CMPA #LIMMED
 2963:     EED4 27 13                          BEQ  DOGLIM
 2964:     EED6 81 00                          CMPA #IMMED
 2965:     EED8 27 2C                          BEQ  DOGIMM
 2966:     EEDA 81 02                          CMPA #INDY
 2967:     EEDC 27 41                          BEQ  DOGINDY
 2968:     EEDE 81 01                          CMPA #INDX
 2969:     EEE0 27 4C                          BEQ  DOGINDX
 2970:     EEE2 81 04                          CMPA #OTHER
 2971:     EEE4 27 57                          BEQ  DOGOTH
 2972:                                 
 2973:                                 *default: error("Unknown Addressing Mode");
 2974:                                 
 2975:     EEE6 86 06                  DOGDEF  LDAA #$06     ;   unknown addre...
 2976:     EEE8 39                             RTS
 2977:                                 
 2978:                                 *case LIMMED: epage(pnorm);
 2979:                                 *             emit(baseop);
 2980:                                 *             a = assarg();
 2981:                                 *             if(a = 4) return(a);
 2982:                                 *             emit(2 bytes);
 2983:                                 *             return(0);
 2984:                                 
 2985:     EEE9 96 D6                  DOGLIM  LDAA PNORM
 2986:     EEEB BD EFB5                        JSR  EPAGE
 2987:     EEEE 96 C7                  DOGLIM1 LDAA BASEOP
 2988:     EEF0 BD EFBD                        JSR  EMIT
 2989:     EEF3 BD EF9F                        JSR  ASSARG   ;get next argument
 2990:     EEF6 81 04                          CMPA #$04
 2991:     EEF8 26 01                          BNE  DOGLIM2   ;jump if arg ok
 2992:     EEFA 39                             RTS
 2993:     EEFB DC A9                  DOGLIM2 LDD  SHFTREG
 2994:     EEFD BD EFBD                        JSR  EMIT
 2995:     EF00 17                             TBA
 2996:     EF01 BD EFBD                        JSR  EMIT
 2997:     EF04 4F                             CLRA
 2998:     EF05 39                             RTS
 2999:                                 
 3000:                                 *case IMMED: epage(pnorm);
 3001:                                 *            emit(baseop);
 3002:                                 *            a = assarg();
 3003:                                 *            if(a = 4) return(a);
 3004:                                 *            emit(lobyte);
 3005:                                 *            return(0);
 3006:                                 
 3007:     EF06 96 D6                  DOGIMM  LDAA PNORM
 3008:     EF08 BD EFB5                        JSR  EPAGE
 3009:     EF0B 96 C7                          LDAA BASEOP
 3010:     EF0D BD EFBD                        JSR  EMIT
 3011:     EF10 BD EF9F                        JSR  ASSARG
 3012:     EF13 81 04                          CMPA #$04
 3013:     EF15 26 01                          BNE  DOGIMM1   ;jump if arg ok
 3014:     EF17 39                             RTS
 3015:     EF18 96 AA                  DOGIMM1 LDAA SHFTREG+1
 3016:     EF1A BD EFBD                        JSR  EMIT
 3017:     EF1D 4F                             CLRA
 3018:     EF1E 39                             RTS
 3019:                                 
 3020:                                 *case INDY: epage(py);
 3021:                                 *           a=doindex(op+0x20);
 3022:                                 *           return(a);
 3023:                                 
 3024:     EF1F 96 C6                  DOGINDY LDAA PY
 3025:     EF21 BD EFB5                        JSR  EPAGE
 3026:     EF24 96 C7                          LDAA BASEOP
 3027:     EF26 8B 20                          ADDA #$20
 3028:     EF28 97 C7                          STAA BASEOP
 3029:     EF2A BD EF70                        JSR  DOINDEX
 3030:     EF2D 39                             RTS
 3031:                                 
 3032:                                 *case INDX: epage(px);
 3033:                                 *           a=doindex(op+0x20);
 3034:                                 *           return(a);
 3035:                                 
 3036:     EF2E 96 C5                  DOGINDX LDAA PX
 3037:     EF30 BD EFB5                        JSR  EPAGE
 3038:     EF33 96 C7                          LDAA BASEOP
 3039:     EF35 8B 20                          ADDA #$20
 3040:     EF37 97 C7                          STAA BASEOP
 3041:     EF39 BD EF70                        JSR  DOINDEX
 3042:     EF3C 39                             RTS
 3043:                                 
 3044:                                 *case OTHER: a = assarg();
 3045:                                 *            if(a = 4) return(a);
 3046:                                 *            epage(pnorm);
 3047:                                 *            if(countu1 <= 2 digits)   /* direct */
 3048:                                 *               emit(op+0x10);
 3049:                                 *               emit(lobyte(Result));
 3050:                                 *               return(0);
 3051:                                 *            else    emit(op+0x30);    /* extended */
 3052:                                 *               eword(Result);
 3053:                                 *               return(0)
 3054:                                 
 3055:     EF3D BD EF9F                DOGOTH  JSR  ASSARG
 3056:     EF40 81 04                          CMPA #$04
 3057:     EF42 26 01                          BNE  DOGOTH0  ;jump if arg ok
 3058:     EF44 39                             RTS
 3059:     EF45 96 D6                  DOGOTH0 LDAA PNORM
 3060:     EF47 BD EFB5                        JSR  EPAGE
 3061:     EF4A 96 BB                          LDAA COUNT
 3062:     EF4C 81 02                          CMPA #$2
 3063:     EF4E 2E 0E                          BGT  DOGOTH1
 3064:     EF50 96 C7                          LDAA BASEOP
 3065:     EF52 8B 10                          ADDA #$10      ;      direct mode opcode
 3066:     EF54 BD EFBD                        JSR  EMIT
 3067:     EF57 96 AA                          LDAA SHFTREG+1
 3068:     EF59 BD EFBD                        JSR  EMIT
 3069:     EF5C 4F                             CLRA
 3070:     EF5D 39                             RTS
 3071:     EF5E 96 C7                  DOGOTH1 LDAA BASEOP
 3072:     EF60 8B 30                          ADDA #$30       ;     extended mode opcode
 3073:     EF62 BD EFBD                        JSR  EMIT
 3074:     EF65 DC A9                          LDD  SHFTREG
 3075:     EF67 BD EFBD                        JSR  EMIT
 3076:     EF6A 17                             TBA
 3077:     EF6B BD EFBD                        JSR  EMIT
 3078:     EF6E 4F                             CLRA
 3079:     EF6F 39                             RTS
 3080:                                 
 3081:                                 **********
 3082:                                 **  doindex(op) --- handle all wierd stuff for
 3083:                                 **   indexed addressing. Returns a = error number.
 3084:                                 **********
 3085:                                 *emit(baseop);
 3086:                                 *a=assarg();
 3087:                                 *if(a = 4) return(a);
 3088:                                 *if( a != ',' ) return("Syntax");
 3089:                                 *buffptr++
 3090:                                 *a=readbuff()
 3091:                                 *if( a != 'x' &&  != 'y') warn("Ind Addr Assumed");
 3092:                                 *emit(lobyte);
 3093:                                 *return(0);
 3094:                                 
 3095:     EF70 96 C7                  DOINDEX LDAA BASEOP
 3096:     EF72 BD EFBD                        JSR  EMIT
 3097:     EF75 BD EF9F                        JSR  ASSARG
 3098:     EF78 81 04                          CMPA #$04
 3099:     EF7A 26 01                          BNE  DOINDX0    ; jump if arg ok
 3100:     EF7C 39                             RTS
 3101:     EF7D 81 2C                  DOINDX0 CMPA #','
 3102:     EF7F 27 03                          BEQ  DOINDX1
 3103:     EF81 86 08                          LDAA #$08        ;"syntax error"
 3104:     EF83 39                             RTS
 3105:     EF84 BD E2EE                DOINDX1 JSR  INCBUFF
 3106:     EF87 BD E2E7                        JSR  READBUFF
 3107:     EF8A 81 59                          CMPA #'Y'
 3108:     EF8C 27 0A                          BEQ  DOINDX2
 3109:     EF8E 81 58                          CMPA #'X'
 3110:     EF90 27 06                          BEQ  DOINDX2
 3111:     EF92 FE EAB9                        LDX  MSGA7       ;"index addr assumed"
 3112:     EF95 BD E538                        JSR  OUTSTRG
 3113:     EF98 96 AA                  DOINDX2 LDAA SHFTREG+1
 3114:     EF9A BD EFBD                        JSR  EMIT
 3115:     EF9D 4F                             CLRA
 3116:     EF9E 39                             RTS
 3117:                                 
 3118:                                 **********
 3119:                                 **   assarg(); - get argument.  Returns a = 4 if bad
 3120:                                 ** argument, else a = first non hex char.
 3121:                                 **********
 3122:                                 *a = buffarg()
 3123:                                 *if(asschk(aa) && countu1 != 0) return(a);
 3124:                                 *return(bad argument);
 3125:                                 
 3126:     EF9F BD E234                ASSARG  JSR  BUFFARG
 3127:     EFA2 BD EC4B                        JSR  ASSCHEK   ;check for command
 3128:     EFA5 27 05                          BEQ  ASSARG1   ;jump if ok
 3129:     EFA7 BD E30C                        JSR  WCHEK     ;check for whitespace
 3130:     EFAA 26 06                          BNE  ASSARG2   ;jump if not ok
 3131:     EFAC 7D 00BB                ASSARG1 TST  COUNT
 3132:     EFAF 27 01                          BEQ  ASSARG2   ;jump if no argument
 3133:     EFB1 39                             RTS
 3134:     EFB2 86 04                  ASSARG2 LDAA #$04      ;bad argument
 3135:     EFB4 39                             RTS
 3136:                                 
 3137:                                 **********
 3138:                                 **  epage(a) --- emit page prebyte
 3139:                                 **********
 3140:                                 *if( a != PAGE1 ) emit(a);
 3141:                                 
 3142:     EFB5 81 00                  EPAGE   CMPA #PAGE1
 3143:     EFB7 27 03                          BEQ  EPAGRT  ;jump if page 1
 3144:     EFB9 BD EFBD                        JSR  EMIT
 3145:     EFBC 39                     EPAGRT  RTS
 3146:                                 
 3147:                                 **********
 3148:                                 *   emit(a) --- emit contents of a
 3149:                                 **********
 3150:     EFBD DE C3                  EMIT    LDX  PC
 3151:     EFBF BD E28A                        JSR  WRITE      ;write a to x
 3152:     EFC2 BD E51C                        JSR  OUT1BSP
 3153:     EFC5 DF C3                          STX  PC
 3154:     EFC7 39                             RTS
 3155:                                 
 3156:                                 *Mnemonic table for hc11 line assembler
 3157:          =00000000              NULL    EQU  $0      ;nothing
 3158:          =00000001              INH     EQU  $1      ;inherent
 3159:          =00000002              P2INH   EQU  $2      ;page 2 inherent
 3160:          =00000003              GEN     EQU  $3      ;general addressing
 3161:          =00000004              GRP2    EQU  $4      ;group 2
 3162:          =00000005              REL     EQU  $5      ;relative
 3163:          =00000006              IMM     EQU  $6      ;immediate
 3164:          =00000007              NIMM    EQU  $7      ;general except for immediate
 3165:          =00000008              LIMM    EQU  $8      ;2 byte immediate
 3166:          =00000009              XLIMM   EQU  $9      ;longimm for x
 3167:          =00000010              XNIMM   EQU  $10     ;no immediate for x
 3168:          =00000011              YLIMM   EQU  $11     ;longimm for y
 3169:          =00000012              YNIMM   EQU  $12     ;no immediate for y
 3170:          =00000013              BTB     EQU  $13     ;bit test and branch
 3171:          =00000014              SETCLR  EQU  $14     ;bit set or clear
 3172:          =00000015              CPD     EQU  $15     ;compare d
 3173:          =00000016              BTBD    EQU  $16     ;bit test and branch direct
 3174:          =00000017              SETCLRD EQU  $17     ;bit set or clear direct
 3175:                                 
 3176:                                 **********
 3177:                                 *   mnetabl - includes all '11 mnemonics, base opcodes,
 3178:                                 * and type of instruction.  The assembler search routine
 3179:                                 *depends on 4 characters for each mnemonic so that 3 char
 3180:                                 *mnemonics are extended with a space and 5 char mnemonics
 3181:                                 *are truncated.
 3182:                                 **********
 3183:                                 
 3184:          =0000EFC8              MNETABL EQU  *
 3185:     EFC8 41 42 41 20                    FCC  'ABA ' ;  Mnemonic
 3186:     EFCC 1B                             FCB  $1B     ;Base opcode
 3187:     EFCD 01                             FCB  INH     ;Class
 3188:     EFCE 41 42 58 20                    FCC  'ABX '
 3189:     EFD2 3A                             FCB  $3A
 3190:     EFD3 01                             FCB  INH
 3191:     EFD4 41 42 59 20                    FCC  'ABY '
 3192:     EFD8 3A                             FCB  $3A
 3193:     EFD9 02                             FCB  P2INH
 3194:     EFDA 41 44 43 41                    FCC  'ADCA'
 3195:     EFDE 89                             FCB  $89
 3196:     EFDF 03                             FCB  GEN
 3197:     EFE0 41 44 43 42                    FCC  'ADCB'
 3198:     EFE4 C9                             FCB  $C9
 3199:     EFE5 03                             FCB  GEN
 3200:     EFE6 41 44 44 41                    FCC  'ADDA'
 3201:     EFEA 8B                             FCB  $8B
 3202:     EFEB 03                             FCB  GEN
 3203:     EFEC 41 44 44 42                    FCC  'ADDB'
 3204:     EFF0 CB                             FCB  $CB
 3205:     EFF1 03                             FCB  GEN
 3206:     EFF2 41 44 44 44                    FCC  'ADDD'
 3207:     EFF6 C3                             FCB  $C3
 3208:     EFF7 08                             FCB  LIMM
 3209:     EFF8 41 4E 44 41                    FCC  'ANDA'
 3210:     EFFC 84                             FCB  $84
 3211:     EFFD 03                             FCB  GEN
 3212:     EFFE 41 4E 44 42                    FCC  'ANDB'
 3213:     F002 C4                             FCB  $C4
 3214:     F003 03                             FCB  GEN
 3215:     F004 41 53 4C 20                    FCC  'ASL '
 3216:     F008 68                             FCB  $68
 3217:     F009 04                             FCB  GRP2
 3218:     F00A 41 53 4C 41                    FCC  'ASLA'
 3219:     F00E 48                             FCB  $48
 3220:     F00F 01                             FCB  INH
 3221:     F010 41 53 4C 42                    FCC  'ASLB'
 3222:     F014 58                             FCB  $58
 3223:     F015 01                             FCB  INH
 3224:     F016 41 53 4C 44                    FCC  'ASLD'
 3225:     F01A 05                             FCB  $05
 3226:     F01B 01                             FCB  INH
 3227:     F01C 41 53 52 20                    FCC  'ASR '
 3228:     F020 67                             FCB  $67
 3229:     F021 04                             FCB  GRP2
 3230:     F022 41 53 52 41                    FCC  'ASRA'
 3231:     F026 47                             FCB  $47
 3232:     F027 01                             FCB  INH
 3233:     F028 41 53 52 42                    FCC  'ASRB'
 3234:     F02C 57                             FCB  $57
 3235:     F02D 01                             FCB  INH
 3236:     F02E 42 43 43 20                    FCC  'BCC '
 3237:     F032 24                             FCB  $24
 3238:     F033 05                             FCB  REL
 3239:     F034 42 43 4C 52                    FCC  'BCLR'
 3240:     F038 1D                             FCB  $1D
 3241:     F039 14                             FCB  SETCLR
 3242:     F03A 42 43 53 20                    FCC  'BCS '
 3243:     F03E 25                             FCB  $25
 3244:     F03F 05                             FCB  REL
 3245:     F040 42 45 51 20                    FCC  'BEQ '
 3246:     F044 27                             FCB  $27
 3247:     F045 05                             FCB  REL
 3248:     F046 42 47 45 20                    FCC  'BGE '
 3249:     F04A 2C                             FCB  $2C
 3250:     F04B 05                             FCB  REL
 3251:     F04C 42 47 54 20                    FCC  'BGT '
 3252:     F050 2E                             FCB  $2E
 3253:     F051 05                             FCB  REL
 3254:     F052 42 48 49 20                    FCC  'BHI '
 3255:     F056 22                             FCB  $22
 3256:     F057 05                             FCB  REL
 3257:     F058 42 48 53 20                    FCC  'BHS '
 3258:     F05C 24                             FCB  $24
 3259:     F05D 05                             FCB  REL
 3260:     F05E 42 49 54 41                    FCC  'BITA'
 3261:     F062 85                             FCB  $85
 3262:     F063 03                             FCB  GEN
 3263:     F064 42 49 54 42                    FCC  'BITB'
 3264:     F068 C5                             FCB  $C5
 3265:     F069 03                             FCB  GEN
 3266:     F06A 42 4C 45 20                    FCC  'BLE '
 3267:     F06E 2F                             FCB  $2F
 3268:     F06F 05                             FCB  REL
 3269:     F070 42 4C 4F 20                    FCC  'BLO '
 3270:     F074 25                             FCB  $25
 3271:     F075 05                             FCB  REL
 3272:     F076 42 4C 53 20                    FCC  'BLS '
 3273:     F07A 23                             FCB  $23
 3274:     F07B 05                             FCB  REL
 3275:     F07C 42 4C 54 20                    FCC  'BLT '
 3276:     F080 2D                             FCB  $2D
 3277:     F081 05                             FCB  REL
 3278:     F082 42 4D 49 20                    FCC  'BMI '
 3279:     F086 2B                             FCB  $2B
 3280:     F087 05                             FCB  REL
 3281:     F088 42 4E 45 20                    FCC  'BNE '
 3282:     F08C 26                             FCB  $26
 3283:     F08D 05                             FCB  REL
 3284:     F08E 42 50 4C 20                    FCC  'BPL '
 3285:     F092 2A                             FCB  $2A
 3286:     F093 05                             FCB  REL
 3287:     F094 42 52 41 20                    FCC  'BRA '
 3288:     F098 20                             FCB  $20
 3289:     F099 05                             FCB  REL
 3290:     F09A 42 52 43 4C                    FCC  'BRCL'   ;    (BRCLR)
 3291:     F09E 1F                             FCB  $1F
 3292:     F09F 13                             FCB  BTB
 3293:     F0A0 42 52 4E 20                    FCC  'BRN '
 3294:     F0A4 21                             FCB  $21
 3295:     F0A5 05                             FCB  REL
 3296:     F0A6 42 52 53 45                    FCC  'BRSE'    ;   (BRSET)
 3297:     F0AA 1E                             FCB  $1E
 3298:     F0AB 13                             FCB  BTB
 3299:     F0AC 42 53 45 54                    FCC  'BSET'
 3300:     F0B0 1C                             FCB  $1C
 3301:     F0B1 14                             FCB  SETCLR
 3302:     F0B2 42 53 52 20                    FCC  'BSR '
 3303:     F0B6 8D                             FCB  $8D
 3304:     F0B7 05                             FCB  REL
 3305:     F0B8 42 56 43 20                    FCC  'BVC '
 3306:     F0BC 28                             FCB  $28
 3307:     F0BD 05                             FCB  REL
 3308:     F0BE 42 56 53 20                    FCC  'BVS '
 3309:     F0C2 29                             FCB  $29
 3310:     F0C3 05                             FCB  REL
 3311:     F0C4 43 42 41 20                    FCC  'CBA '
 3312:     F0C8 11                             FCB  $11
 3313:     F0C9 01                             FCB  INH
 3314:     F0CA 43 4C 43 20                    FCC  'CLC '
 3315:     F0CE 0C                             FCB  $0C
 3316:     F0CF 01                             FCB  INH
 3317:     F0D0 43 4C 49 20                    FCC  'CLI '
 3318:     F0D4 0E                             FCB  $0E
 3319:     F0D5 01                             FCB  INH
 3320:     F0D6 43 4C 52 20                    FCC  'CLR '
 3321:     F0DA 6F                             FCB  $6F
 3322:     F0DB 04                             FCB  GRP2
 3323:     F0DC 43 4C 52 41                    FCC  'CLRA'
 3324:     F0E0 4F                             FCB  $4F
 3325:     F0E1 01                             FCB  INH
 3326:     F0E2 43 4C 52 42                    FCC  'CLRB'
 3327:     F0E6 5F                             FCB  $5F
 3328:     F0E7 01                             FCB  INH
 3329:     F0E8 43 4C 56 20                    FCC  'CLV '
 3330:     F0EC 0A                             FCB  $0A
 3331:     F0ED 01                             FCB  INH
 3332:     F0EE 43 4D 50 41                    FCC  'CMPA'
 3333:     F0F2 81                             FCB  $81
 3334:     F0F3 03                             FCB  GEN
 3335:     F0F4 43 4D 50 42                    FCC  'CMPB'
 3336:     F0F8 C1                             FCB  $C1
 3337:     F0F9 03                             FCB  GEN
 3338:     F0FA 43 4F 4D 20                    FCC  'COM '
 3339:     F0FE 63                             FCB  $63
 3340:     F0FF 04                             FCB  GRP2
 3341:     F100 43 4F 4D 41                    FCC  'COMA'
 3342:     F104 43                             FCB  $43
 3343:     F105 01                             FCB  INH
 3344:     F106 43 4F 4D 42                    FCC  'COMB'
 3345:     F10A 53                             FCB  $53
 3346:     F10B 01                             FCB  INH
 3347:     F10C 43 50 44 20                    FCC  'CPD '
 3348:     F110 83                             FCB  $83
 3349:     F111 15                             FCB  CPD
 3350:     F112 43 50 58 20                    FCC  'CPX '
 3351:     F116 8C                             FCB  $8C
 3352:     F117 09                             FCB  XLIMM
 3353:     F118 43 50 59 20                    FCC  'CPY '
 3354:     F11C 8C                             FCB  $8C
 3355:     F11D 11                             FCB  YLIMM
 3356:     F11E 44 41 41 20                    FCC  'DAA '
 3357:     F122 19                             FCB  $19
 3358:     F123 01                             FCB  INH
 3359:     F124 44 45 43 20                    FCC  'DEC '
 3360:     F128 6A                             FCB  $6A
 3361:     F129 04                             FCB  GRP2
 3362:     F12A 44 45 43 41                    FCC  'DECA'
 3363:     F12E 4A                             FCB  $4A
 3364:     F12F 01                             FCB  INH
 3365:     F130 44 45 43 42                    FCC  'DECB'
 3366:     F134 5A                             FCB  $5A
 3367:     F135 01                             FCB  INH
 3368:     F136 44 45 53 20                    FCC  'DES '
 3369:     F13A 34                             FCB  $34
 3370:     F13B 01                             FCB  INH
 3371:     F13C 44 45 58 20                    FCC  'DEX '
 3372:     F140 09                             FCB  $09
 3373:     F141 01                             FCB  INH
 3374:     F142 44 45 59 20                    FCC  'DEY '
 3375:     F146 09                             FCB  $09
 3376:     F147 02                             FCB  P2INH
 3377:     F148 45 4F 52 41                    FCC  'EORA'
 3378:     F14C 88                             FCB  $88
 3379:     F14D 03                             FCB  GEN
 3380:     F14E 45 4F 52 42                    FCC  'EORB'
 3381:     F152 C8                             FCB  $C8
 3382:     F153 03                             FCB  GEN
 3383:     F154 46 44 49 56                    FCC  'FDIV'
 3384:     F158 03                             FCB  $03
 3385:     F159 01                             FCB  INH
 3386:     F15A 49 44 49 56                    FCC  'IDIV'
 3387:     F15E 02                             FCB  $02
 3388:     F15F 01                             FCB  INH
 3389:     F160 49 4E 43 20                    FCC  'INC '
 3390:     F164 6C                             FCB  $6C
 3391:     F165 04                             FCB  GRP2
 3392:     F166 49 4E 43 41                    FCC  'INCA'
 3393:     F16A 4C                             FCB  $4C
 3394:     F16B 01                             FCB  INH
 3395:     F16C 49 4E 43 42                    FCC  'INCB'
 3396:     F170 5C                             FCB  $5C
 3397:     F171 01                             FCB  INH
 3398:     F172 49 4E 53 20                    FCC  'INS '
 3399:     F176 31                             FCB  $31
 3400:     F177 01                             FCB  INH
 3401:     F178 49 4E 58 20                    FCC  'INX '
 3402:     F17C 08                             FCB  $08
 3403:     F17D 01                             FCB  INH
 3404:     F17E 49 4E 59 20                    FCC  'INY '
 3405:     F182 08                             FCB  $08
 3406:     F183 02                             FCB  P2INH
 3407:     F184 4A 4D 50 20                    FCC  'JMP '
 3408:     F188 6E                             FCB  $6E
 3409:     F189 04                             FCB  GRP2
 3410:     F18A 4A 53 52 20                    FCC  'JSR '
 3411:     F18E 8D                             FCB  $8D
 3412:     F18F 07                             FCB  NIMM
 3413:     F190 4C 44 41 41                    FCC  'LDAA'
 3414:     F194 86                             FCB  $86
 3415:     F195 03                             FCB  GEN
 3416:     F196 4C 44 41 42                    FCC  'LDAB'
 3417:     F19A C6                             FCB  $C6
 3418:     F19B 03                             FCB  GEN
 3419:     F19C 4C 44 44 20                    FCC  'LDD '
 3420:     F1A0 CC                             FCB  $CC
 3421:     F1A1 08                             FCB  LIMM
 3422:     F1A2 4C 44 53 20                    FCC  'LDS '
 3423:     F1A6 8E                             FCB  $8E
 3424:     F1A7 08                             FCB  LIMM
 3425:     F1A8 4C 44 58 20                    FCC  'LDX '
 3426:     F1AC CE                             FCB  $CE
 3427:     F1AD 09                             FCB  XLIMM
 3428:     F1AE 4C 44 59 20                    FCC  'LDY '
 3429:     F1B2 CE                             FCB  $CE
 3430:     F1B3 11                             FCB  YLIMM
 3431:     F1B4 4C 53 4C 20                    FCC  'LSL '
 3432:     F1B8 68                             FCB  $68
 3433:     F1B9 04                             FCB  GRP2
 3434:     F1BA 4C 53 4C 41                    FCC  'LSLA'
 3435:     F1BE 48                             FCB  $48
 3436:     F1BF 01                             FCB  INH
 3437:     F1C0 4C 53 4C 42                    FCC  'LSLB'
 3438:     F1C4 58                             FCB  $58
 3439:     F1C5 01                             FCB  INH
 3440:     F1C6 4C 53 4C 44                    FCC  'LSLD'
 3441:     F1CA 05                             FCB  $05
 3442:     F1CB 01                             FCB  INH
 3443:     F1CC 4C 53 52 20                    FCC  'LSR '
 3444:     F1D0 64                             FCB  $64
 3445:     F1D1 04                             FCB  GRP2
 3446:     F1D2 4C 53 52 41                    FCC  'LSRA'
 3447:     F1D6 44                             FCB  $44
 3448:     F1D7 01                             FCB  INH
 3449:     F1D8 4C 53 52 42                    FCC  'LSRB'
 3450:     F1DC 54                             FCB  $54
 3451:     F1DD 01                             FCB  INH
 3452:     F1DE 4C 53 52 44                    FCC  'LSRD'
 3453:     F1E2 04                             FCB  $04
 3454:     F1E3 01                             FCB  INH
 3455:     F1E4 4D 55 4C 20                    FCC  'MUL '
 3456:     F1E8 3D                             FCB  $3D
 3457:     F1E9 01                             FCB  INH
 3458:     F1EA 4E 45 47 20                    FCC  'NEG '
 3459:     F1EE 60                             FCB  $60
 3460:     F1EF 04                             FCB  GRP2
 3461:     F1F0 4E 45 47 41                    FCC  'NEGA'
 3462:     F1F4 40                             FCB  $40
 3463:     F1F5 01                             FCB  INH
 3464:     F1F6 4E 45 47 42                    FCC  'NEGB'
 3465:     F1FA 50                             FCB  $50
 3466:     F1FB 01                             FCB  INH
 3467:     F1FC 4E 4F 50 20                    FCC  'NOP '
 3468:     F200 01                             FCB  $01
 3469:     F201 01                             FCB  INH
 3470:     F202 4F 52 41 41                    FCC  'ORAA'
 3471:     F206 8A                             FCB  $8A
 3472:     F207 03                             FCB  GEN
 3473:     F208 4F 52 41 42                    FCC  'ORAB'
 3474:     F20C CA                             FCB  $CA
 3475:     F20D 03                             FCB  GEN
 3476:     F20E 50 53 48 41                    FCC  'PSHA'
 3477:     F212 36                             FCB  $36
 3478:     F213 01                             FCB  INH
 3479:     F214 50 53 48 42                    FCC  'PSHB'
 3480:     F218 37                             FCB  $37
 3481:     F219 01                             FCB  INH
 3482:     F21A 50 53 48 58                    FCC  'PSHX'
 3483:     F21E 3C                             FCB  $3C
 3484:     F21F 01                             FCB  INH
 3485:     F220 50 53 48 59                    FCC  'PSHY'
 3486:     F224 3C                             FCB  $3C
 3487:     F225 02                             FCB  P2INH
 3488:     F226 50 55 4C 41                    FCC  'PULA'
 3489:     F22A 32                             FCB  $32
 3490:     F22B 01                             FCB  INH
 3491:     F22C 50 55 4C 42                    FCC  'PULB'
 3492:     F230 33                             FCB  $33
 3493:     F231 01                             FCB  INH
 3494:     F232 50 55 4C 58                    FCC  'PULX'
 3495:     F236 38                             FCB  $38
 3496:     F237 01                             FCB  INH
 3497:     F238 50 55 4C 59                    FCC  'PULY'
 3498:     F23C 38                             FCB  $38
 3499:     F23D 02                             FCB  P2INH
 3500:     F23E 52 4F 4C 20                    FCC  'ROL '
 3501:     F242 69                             FCB  $69
 3502:     F243 04                             FCB  GRP2
 3503:     F244 52 4F 4C 41                    FCC  'ROLA'
 3504:     F248 49                             FCB  $49
 3505:     F249 01                             FCB  INH
 3506:     F24A 52 4F 4C 42                    FCC  'ROLB'
 3507:     F24E 59                             FCB  $59
 3508:     F24F 01                             FCB  INH
 3509:     F250 52 4F 52 20                    FCC  'ROR '
 3510:     F254 66                             FCB  $66
 3511:     F255 04                             FCB  GRP2
 3512:     F256 52 4F 52 41                    FCC  'RORA'
 3513:     F25A 46                             FCB  $46
 3514:     F25B 01                             FCB  INH
 3515:     F25C 52 4F 52 42                    FCC  'RORB'
 3516:     F260 56                             FCB  $56
 3517:     F261 01                             FCB  INH
 3518:     F262 52 54 49 20                    FCC  'RTI '
 3519:     F266 3B                             FCB  $3B
 3520:     F267 01                             FCB  INH
 3521:     F268 52 54 53 20                    FCC  'RTS '
 3522:     F26C 39                             FCB  $39
 3523:     F26D 01                             FCB  INH
 3524:     F26E 53 42 41 20                    FCC  'SBA '
 3525:     F272 10                             FCB  $10
 3526:     F273 01                             FCB  INH
 3527:     F274 53 42 43 41                    FCC  'SBCA'
 3528:     F278 82                             FCB  $82
 3529:     F279 03                             FCB  GEN
 3530:     F27A 53 42 43 42                    FCC  'SBCB'
 3531:     F27E C2                             FCB  $C2
 3532:     F27F 03                             FCB  GEN
 3533:     F280 53 45 43 20                    FCC  'SEC '
 3534:     F284 0D                             FCB  $0D
 3535:     F285 01                             FCB  INH
 3536:     F286 53 45 49 20                    FCC  'SEI '
 3537:     F28A 0F                             FCB  $0F
 3538:     F28B 01                             FCB  INH
 3539:     F28C 53 45 56 20                    FCC  'SEV '
 3540:     F290 0B                             FCB  $0B
 3541:     F291 01                             FCB  INH
 3542:     F292 53 54 41 41                    FCC  'STAA'
 3543:     F296 87                             FCB  $87
 3544:     F297 07                             FCB  NIMM
 3545:     F298 53 54 41 42                    FCC  'STAB'
 3546:     F29C C7                             FCB  $C7
 3547:     F29D 07                             FCB  NIMM
 3548:     F29E 53 54 44 20                    FCC  'STD '
 3549:     F2A2 CD                             FCB  $CD
 3550:     F2A3 07                             FCB  NIMM
 3551:     F2A4 53 54 4F 50                    FCC  'STOP'
 3552:     F2A8 CF                             FCB  $CF
 3553:     F2A9 01                             FCB  INH
 3554:     F2AA 53 54 53 20                    FCC  'STS '
 3555:     F2AE 8F                             FCB  $8F
 3556:     F2AF 07                             FCB  NIMM
 3557:     F2B0 53 54 58 20                    FCC  'STX '
 3558:     F2B4 CF                             FCB  $CF
 3559:     F2B5 10                             FCB  XNIMM
 3560:     F2B6 53 54 59 20                    FCC  'STY '
 3561:     F2BA CF                             FCB  $CF
 3562:     F2BB 12                             FCB  YNIMM
 3563:     F2BC 53 55 42 41                    FCC  'SUBA'
 3564:     F2C0 80                             FCB  $80
 3565:     F2C1 03                             FCB  GEN
 3566:     F2C2 53 55 42 42                    FCC  'SUBB'
 3567:     F2C6 C0                             FCB  $C0
 3568:     F2C7 03                             FCB  GEN
 3569:     F2C8 53 55 42 44                    FCC  'SUBD'
 3570:     F2CC 83                             FCB  $83
 3571:     F2CD 08                             FCB  LIMM
 3572:     F2CE 53 57 49 20                    FCC  'SWI '
 3573:     F2D2 3F                             FCB  $3F
 3574:     F2D3 01                             FCB  INH
 3575:     F2D4 54 41 42 20                    FCC  'TAB '
 3576:     F2D8 16                             FCB  $16
 3577:     F2D9 01                             FCB  INH
 3578:     F2DA 54 41 50 20                    FCC  'TAP '
 3579:     F2DE 06                             FCB  $06
 3580:     F2DF 01                             FCB  INH
 3581:     F2E0 54 42 41 20                    FCC  'TBA '
 3582:     F2E4 17                             FCB  $17
 3583:     F2E5 01                             FCB  INH
 3584:     F2E6 54 50 41 20                    FCC  'TPA '
 3585:     F2EA 07                             FCB  $07
 3586:     F2EB 01                             FCB  INH
 3587:     F2EC 54 45 53 54                    FCC  'TEST'
 3588:     F2F0 00                             FCB  $00
 3589:     F2F1 01                             FCB  INH
 3590:     F2F2 54 53 54 20                    FCC  'TST '
 3591:     F2F6 6D                             FCB  $6D
 3592:     F2F7 04                             FCB  GRP2
 3593:     F2F8 54 53 54 41                    FCC  'TSTA'
 3594:     F2FC 4D                             FCB  $4D
 3595:     F2FD 01                             FCB  INH
 3596:     F2FE 54 53 54 42                    FCC  'TSTB'
 3597:     F302 5D                             FCB  $5D
 3598:     F303 01                             FCB  INH
 3599:     F304 54 53 58 20                    FCC  'TSX '
 3600:     F308 30                             FCB  $30
 3601:     F309 01                             FCB  INH
 3602:     F30A 54 53 59 20                    FCC  'TSY '
 3603:     F30E 30                             FCB  $30
 3604:     F30F 02                             FCB  P2INH
 3605:     F310 54 58 53 20                    FCC  'TXS '
 3606:     F314 35                             FCB  $35
 3607:     F315 01                             FCB  INH
 3608:     F316 54 59 53 20                    FCC  'TYS '
 3609:     F31A 35                             FCB  $35
 3610:     F31B 02                             FCB  P2INH
 3611:     F31C 57 41 49 20                    FCC  'WAI '
 3612:     F320 3E                             FCB  $3E
 3613:     F321 01                             FCB  INH
 3614:     F322 58 47 44 58                    FCC  'XGDX'
 3615:     F326 8F                             FCB  $8F
 3616:     F327 01                             FCB  INH
 3617:     F328 58 47 44 59                    FCC  'XGDY'
 3618:     F32C 8F                             FCB  $8F
 3619:     F32D 02                             FCB  P2INH
 3620:     F32E 42 52 53 45                    FCC  'BRSE'     ;   bit direct modes for
 3621:     F332 12                             FCB  $12         ;    disassembler.
 3622:     F333 16                             FCB  BTBD
 3623:     F334 42 52 43 4C                    FCC  'BRCL'
 3624:     F338 13                             FCB  $13
 3625:     F339 16                             FCB  BTBD
 3626:     F33A 42 53 45 54                    FCC  'BSET'
 3627:     F33E 14                             FCB  $14
 3628:     F33F 17                             FCB  SETCLRD
 3629:     F340 42 43 4C 52                    FCC  'BCLR'
 3630:     F344 15                             FCB  $15
 3631:     F345 17                             FCB  SETCLRD
 3632:     F346 04                             FCB  EOT          ;   End of table
 3633:                                 
 3634:                                 **********************************************
 3635:          =00000000              PG1     EQU     $0
 3636:          =00000001              PG2     EQU     $1
 3637:          =00000002              PG3     EQU     $2
 3638:          =00000003              PG4     EQU     $3
 3639:                                 
 3640:                                 ******************
 3641:                                 *disassem() - disassemble the opcode.
 3642:                                 ******************
 3643:                                 *(check for page prebyte)
 3644:                                 *baseop=pc[0];
 3645:                                 *pnorm=PG1;
 3646:                                 *if(baseop==$18) pnorm=PG2;
 3647:                                 *if(baseop==$1A) pnorm=PG3;
 3648:                                 *if(baseop==$CD) pnorm=PG4;
 3649:                                 *if(pnorm != PG1) dispc=pc+1;
 3650:                                 *else dispc=pc; (dispc points to next byte)
 3651:                                 
 3652:          =0000F347              DISASSM EQU  *
 3653:     F347 DE C3                          LDX  PC      ;   address
 3654:     F349 A6 00                          LDAA 0,X      ;  opcode
 3655:     F34B C6 00                          LDAB #PG1
 3656:     F34D 81 18                          CMPA #$18
 3657:     F34F 27 0A                          BEQ  DISP2     ; jump if page2
 3658:     F351 81 1A                          CMPA #$1A
 3659:     F353 27 05                          BEQ  DISP3      ;jump if page3
 3660:     F355 81 CD                          CMPA #$CD
 3661:     F357 26 04                          BNE  DISP1      ;jump if not page4
 3662:     F359 5C                     DISP4   INCB            ;set up page value
 3663:     F35A 5C                     DISP3   INCB
 3664:     F35B 5C                     DISP2   INCB
 3665:     F35C 08                             INX
 3666:     F35D DF C9                  DISP1   STX  DISPC      ;point to opcode
 3667:     F35F D7 D6                          STAB PNORM      ;save page
 3668:                                 
 3669:                                 *If(opcode == ($00-$5F or $8D or $8F or $CF))
 3670:                                 *  if(pnorm == (PG3 or PG4))
 3671:                                 *      disillop(); return();
 3672:                                 *  b=disrch(opcode,NULL);
 3673:                                 *  if(b==0) disillop(); return();
 3674:                                 
 3675:     F361 A6 00                          LDAA 0,X  ;get current opcode
 3676:     F363 97 C7                          STAA BASEOP
 3677:     F365 08                             INX
 3678:     F366 DF C9                          STX  DISPC      ;point to next byte
 3679:     F368 81 5F                          CMPA #$5F
 3680:     F36A 23 0F                          BLS  DIS1       ;jump if in range
 3681:     F36C 81 8D                          CMPA #$8D
 3682:     F36E 27 0B                          BEQ  DIS1       ;jump if bsr
 3683:     F370 81 8F                          CMPA #$8F
 3684:     F372 27 07                          BEQ  DIS1       ;jump if xgdx
 3685:     F374 81 CF                          CMPA #$CF
 3686:     F376 27 03                          BEQ  DIS1       ;jump if stop
 3687:     F378 7E F412                        JMP  DISGRP     ;try next part of map
 3688:     F37B D6 D6                  DIS1    LDAB PNORM
 3689:     F37D C1 02                          CMPB #PG3
 3690:     F37F 25 04                          BLO  DIS2       ;jump if page 1 or 2
 3691:     F381 BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3692:     F384 39                             RTS
 3693:     F385 D6 C7                  DIS2    LDAB BASEOP     ;opcode
 3694:     F387 5F                             CLRB            ;class=null
 3695:     F388 BD F4FB                        JSR  DISRCH
 3696:     F38B 5D                             TSTB
 3697:     F38C 26 04                          BNE  DISPEC     ;jump if opcode found
 3698:     F38E BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3699:     F391 39                             RTS
 3700:                                 
 3701:                                 *   if(opcode==$8D) dissrch(opcode,REL);
 3702:                                 *   if(opcode==($8F or $CF)) disrch(opcode,INH);
 3703:                                 
 3704:     F392 96 C7                  DISPEC  LDAA BASEOP
 3705:     F394 81 8D                          CMPA #$8D
 3706:     F396 26 04                          BNE  DISPEC1
 3707:     F398 C6 05                          LDAB #REL
 3708:     F39A 20 0A                          BRA  DISPEC3    ;look for BSR opcode
 3709:     F39C 81 8F                  DISPEC1 CMPA #$8F
 3710:     F39E 27 04                          BEQ  DISPEC2    ;jump if XGDX opcode
 3711:     F3A0 81 CF                          CMPA #$CF
 3712:     F3A2 26 05                          BNE  DISINH     ;jump not STOP opcode
 3713:     F3A4 C6 01                  DISPEC2 LDAB #INH
 3714:     F3A6 BD F4FB                DISPEC3 JSR  DISRCH     ;find other entry in table
 3715:                                 
 3716:                                 *   if(class==INH)           /* INH */
 3717:                                 *      if(pnorm==PG2)
 3718:                                 *         b=disrch(baseop,P2INH);
 3719:                                 *         if(b==0) disillop(); return();
 3720:                                 *      prntmne();
 3721:                                 *      return();
 3722:                                 
 3723:          =0000F3A9              DISINH  EQU  *
 3724:     F3A9 D6 C8                          LDAB CLASS
 3725:     F3AB C1 01                          CMPB #INH
 3726:     F3AD 26 18                          BNE  DISREL     ;jump if not inherent
 3727:     F3AF D6 D6                          LDAB PNORM
 3728:     F3B1 C1 00                          CMPB #PG1
 3729:     F3B3 27 0E                          BEQ  DISINH1    ;jump if page1
 3730:     F3B5 96 C7                          LDAA BASEOP     ;get opcode
 3731:     F3B7 C6 02                          LDAB #P2INH     ;class=p2inh
 3732:     F3B9 BD F4FB                        JSR  DISRCH
 3733:     F3BC 5D                             TSTB
 3734:     F3BD 26 04                          BNE  DISINH1    ;jump if found
 3735:     F3BF BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3736:     F3C2 39                             RTS
 3737:     F3C3 BD F51E                DISINH1 JSR  PRNTMNE
 3738:     F3C6 39                             RTS
 3739:                                 
 3740:                                 *   elseif(class=REL)       /* REL */
 3741:                                 *      if(pnorm != PG1)
 3742:                                 *         disillop(); return();
 3743:                                 *      prntmne();
 3744:                                 *      disrelad();
 3745:                                 *      return();
 3746:                                 
 3747:          =0000F3C7              DISREL  EQU  *
 3748:     F3C7 D6 C8                          LDAB CLASS
 3749:     F3C9 C1 05                          CMPB #REL
 3750:     F3CB 26 10                          BNE  DISBTD
 3751:     F3CD 7D 00D6                        TST  PNORM
 3752:     F3D0 27 04                          BEQ  DISREL1    ;jump if page1
 3753:     F3D2 BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3754:     F3D5 39                             RTS
 3755:     F3D6 BD F51E                DISREL1 JSR  PRNTMNE    ;output mnemonic
 3756:     F3D9 BD F554                        JSR  DISRELAD   ;compute relative address
 3757:     F3DC 39                             RTS
 3758:                                 
 3759:                                 *   else           /* SETCLR,SETCLRD,BTB,BTBD */
 3760:                                 *      if(class == (SETCLRD or BTBD))
 3761:                                 *         if(pnorm != PG1)
 3762:                                 *            disillop(); return();   /* illop */
 3763:                                 *         prntmne();           /* direct */
 3764:                                 *         disdir();           /* output $byte */
 3765:                                 *      else (class == (SETCLR or BTB))
 3766:                                 *         prntmne();           /* indexed */
 3767:                                 *         disindx();
 3768:                                 *      outspac();
 3769:                                 *      disdir();
 3770:                                 *      outspac();
 3771:                                 *      if(class == (BTB or BTBD))
 3772:                                 *         disrelad();
 3773:                                 *   return();
 3774:                                 
 3775:          =0000F3DD              DISBTD  EQU  *
 3776:     F3DD D6 C8                          LDAB CLASS
 3777:     F3DF C1 17                          CMPB #SETCLRD
 3778:     F3E1 27 04                          BEQ  DISBTD1
 3779:     F3E3 C1 16                          CMPB #BTBD
 3780:     F3E5 26 11                          BNE  DISBIT     ;jump not direct bitop
 3781:     F3E7 7D 00D6                DISBTD1 TST  PNORM
 3782:     F3EA 27 04                          BEQ  DISBTD2    ;jump if page 1
 3783:     F3EC BD F5CC                        JSR  DISILLOP
 3784:     F3EF 39                             RTS
 3785:     F3F0 BD F51E                DISBTD2 JSR  PRNTMNE
 3786:     F3F3 BD F5AC                        JSR  DISDIR     ;operand(direct)
 3787:     F3F6 20 06                          BRA  DISBIT1
 3788:          =0000F3F8              DISBIT  EQU  *
 3789:     F3F8 BD F51E                        JSR  PRNTMNE
 3790:     F3FB BD F538                        JSR  DISINDX    ;operand(indexed)
 3791:     F3FE BD E51F                DISBIT1 JSR  OUTSPAC
 3792:     F401 BD F5AC                        JSR  DISDIR     ;mask
 3793:     F404 D6 C8                          LDAB CLASS
 3794:     F406 C1 13                          CMPB #BTB
 3795:     F408 27 04                          BEQ  DISBIT2    ;jump if btb
 3796:     F40A C1 16                          CMPB #BTBD
 3797:     F40C 26 03                          BNE  DISBIT3    ;jump if not bit branch
 3798:     F40E BD F554                DISBIT2 JSR  DISRELAD   ;relative address
 3799:     F411 39                     DISBIT3 RTS
 3800:                                 
 3801:                                 
 3802:                                 *Elseif($60 <= opcode <= $7F)  /*  GRP2 */
 3803:                                 *   if(pnorm == (PG3 or PG4))
 3804:                                 *      disillop(); return();
 3805:                                 *   if((pnorm==PG2) and (opcode != $6x))
 3806:                                 *      disillop(); return();
 3807:                                 *   b=disrch(baseop & $6F,NULL);
 3808:                                 *   if(b==0) disillop(); return();
 3809:                                 *   prntmne();
 3810:                                 *   if(opcode == $6x)
 3811:                                 *      disindx();
 3812:                                 *   else
 3813:                                 *      disext();
 3814:                                 *   return();
 3815:                                 
 3816:          =0000F412              DISGRP  EQU  *
 3817:     F412 81 7F                          CMPA #$7F       ;a=opcode
 3818:     F414 22 2A                          BHI  DISNEXT    ;try next part of map
 3819:     F416 D6 D6                          LDAB PNORM
 3820:     F418 C1 02                          CMPB #PG3
 3821:     F41A 25 04                          BLO  DISGRP2    ;jump if page 1 or 2
 3822:     F41C BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3823:     F41F 39                             RTS
 3824:     F420 84 6F                  DISGRP2 ANDA #$6F       ;mask bit 4
 3825:     F422 5F                             CLRB            ;class=null
 3826:     F423 BD F4FB                        JSR  DISRCH
 3827:     F426 5D                             TSTB
 3828:     F427 26 04                          BNE  DISGRP3    ;jump if found
 3829:     F429 BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3830:     F42C 39                             RTS
 3831:     F42D BD F51E                DISGRP3 JSR  PRNTMNE
 3832:     F430 96 C7                          LDAA BASEOP     ;get opcode
 3833:     F432 84 F0                          ANDA #$F0
 3834:     F434 81 60                          CMPA #$60
 3835:     F436 26 04                          BNE  DISGRP4    ;jump if not 6x
 3836:     F438 BD F538                        JSR  DISINDX    ;operand(indexed)
 3837:     F43B 39                             RTS
 3838:     F43C BD F5B9                DISGRP4 JSR  DISEXT     ;operand(extended)
 3839:     F43F 39                             RTS
 3840:                                 
 3841:                                 *Else  ($80 <= opcode <= $FF)
 3842:                                 *   if(opcode == ($87 or $C7))
 3843:                                 *      disillop(); return();
 3844:                                 *   b=disrch(opcode&$CF,NULL);
 3845:                                 *   if(b==0) disillop(); return();
 3846:                                 
 3847:          =0000F440              DISNEXT EQU  *
 3848:     F440 81 87                          CMPA #$87       ;a=opcode
 3849:     F442 27 04                          BEQ  DISNEX1
 3850:     F444 81 C7                          CMPA #$C7
 3851:     F446 26 04                          BNE  DISNEX2
 3852:     F448 BD F5CC                DISNEX1 JSR  DISILLOP   ;"illegal opcode"
 3853:     F44B 39                             RTS
 3854:     F44C 84 CF                  DISNEX2 ANDA #$CF
 3855:     F44E 5F                             CLRB            ;class=null
 3856:     F44F BD F4FB                        JSR  DISRCH
 3857:     F452 5D                             TSTB
 3858:     F453 26 04                          BNE  DISNEW     ;jump if mne found
 3859:     F455 BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3860:     F458 39                             RTS
 3861:                                 
 3862:                                 *   if(opcode&$CF==$8D) disrch(baseop,NIMM; (jsr)
 3863:                                 *   if(opcode&$CF==$8F) disrch(baseop,NIMM; (sts)
 3864:                                 *   if(opcode&$CF==$CF) disrch(baseop,XNIMM; (stx)
 3865:                                 *   if(opcode&$CF==$83) disrch(baseop,LIMM); (subd)
 3866:                                 
 3867:     F459 96 C7                  DISNEW  LDAA BASEOP
 3868:     F45B 84 CF                          ANDA #$CF
 3869:     F45D 81 8D                          CMPA #$8D
 3870:     F45F 26 04                          BNE  DISNEW1    ;jump not jsr
 3871:     F461 C6 07                          LDAB #NIMM
 3872:     F463 20 16                          BRA  DISNEW4
 3873:     F465 81 8F                  DISNEW1 CMPA #$8F
 3874:     F467 26 04                          BNE  DISNEW2    ;jump not sts
 3875:     F469 C6 07                          LDAB #NIMM
 3876:     F46B 20 0E                          BRA  DISNEW4
 3877:     F46D 81 CF                  DISNEW2 CMPA #$CF
 3878:     F46F 26 04                          BNE  DISNEW3    ;jump not stx
 3879:     F471 C6 10                          LDAB #XNIMM
 3880:     F473 20 06                          BRA  DISNEW4
 3881:     F475 81 83                  DISNEW3 CMPA #$83
 3882:     F477 26 0C                          BNE  DISGEN     ;jump not subd
 3883:     F479 C6 08                          LDAB #LIMM
 3884:     F47B BD F4FB                DISNEW4 JSR  DISRCH
 3885:     F47E 5D                             TSTB
 3886:     F47F 26 04                          BNE  DISGEN     ;jump if found
 3887:     F481 BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3888:     F484 39                             RTS
 3889:                                 
 3890:                                 *   if(class == (GEN or NIMM or LIMM   ))   /* GEN,NIMM,LIMM,CPD */
 3891:                                 *      if(opcode&$CF==$83)
 3892:                                 *         if(pnorm==(PG3 or PG4)) disrch(opcode#$CF,CPD)
 3893:                                 *         class=LIMM;
 3894:                                 *      if((pnorm == (PG2 or PG4) and (opcode != ($Ax or $Ex)))
 3895:                                 *         disillop(); return();
 3896:                                 *      disgenrl();
 3897:                                 *      return();
 3898:                                 
 3899:     F485 D6 C8                  DISGEN  LDAB CLASS      ;get class
 3900:     F487 C1 03                          CMPB #GEN
 3901:     F489 27 08                          BEQ  DISGEN1
 3902:     F48B C1 07                          CMPB #NIMM
 3903:     F48D 27 04                          BEQ  DISGEN1
 3904:     F48F C1 08                          CMPB #LIMM
 3905:     F491 26 31                          BNE  DISXLN     ;jump if other class
 3906:     F493 96 C7                  DISGEN1 LDAA BASEOP
 3907:     F495 84 CF                          ANDA #$CF
 3908:     F497 81 83                          CMPA #$83
 3909:     F499 26 0F                          BNE  DISGEN3    ;jump if not #$83
 3910:     F49B D6 D6                          LDAB PNORM
 3911:     F49D C1 02                          CMPB #PG3
 3912:     F49F 25 09                          BLO  DISGEN3    ;jump not pg3 or 4
 3913:     F4A1 C6 15                          LDAB #CPD
 3914:     F4A3 BD F4FB                        JSR  DISRCH     ;look for cpd mne
 3915:     F4A6 C6 08                          LDAB #LIMM
 3916:     F4A8 D7 C8                          STAB CLASS      ;set class to limm
 3917:     F4AA D6 D6                  DISGEN3 LDAB PNORM
 3918:     F4AC C1 01                          CMPB #PG2
 3919:     F4AE 27 04                          BEQ  DISGEN4    ;jump if page 2
 3920:     F4B0 C1 03                          CMPB #PG4
 3921:     F4B2 26 0C                          BNE  DISGEN5   ;jump not page 2 or 4
 3922:     F4B4 96 C7                  DISGEN4 LDAA BASEOP
 3923:     F4B6 84 B0                          ANDA #$B0       ;mask bits 6,3-0
 3924:     F4B8 81 A0                          CMPA #$A0
 3925:     F4BA 27 04                          BEQ  DISGEN5     ;jump if $Ax or $Ex
 3926:     F4BC BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3927:     F4BF 39                             RTS
 3928:     F4C0 BD F576                DISGEN5 JSR  DISGENRL   ;process general class
 3929:     F4C3 39                             RTS
 3930:                                 
 3931:                                 *   else       /* XLIMM,XNIMM,YLIMM,YNIMM */
 3932:                                 *      if(pnorm==(PG2 or PG3))
 3933:                                 *         if(class==XLIMM) disrch(opcode&$CF,YLIMM);
 3934:                                 *         else disrch(opcode&$CF,YNIMM);
 3935:                                 *      if((pnorm == (PG3 or PG4))
 3936:                                 *         if(opcode != ($Ax or $Ex))
 3937:                                 *            disillop(); return();
 3938:                                 *      class=LIMM;
 3939:                                 *      disgen();
 3940:                                 *   return();
 3941:                                 
 3942:     F4C4 D6 D6                  DISXLN  LDAB PNORM
 3943:     F4C6 C1 01                          CMPB #PG2
 3944:     F4C8 27 04                          BEQ  DISXLN1    ;jump if page2
 3945:     F4CA C1 02                          CMPB #PG3
 3946:     F4CC 26 13                          BNE  DISXLN4    ;jump not page3
 3947:     F4CE 96 C7                  DISXLN1 LDAA BASEOP
 3948:     F4D0 84 CF                          ANDA #$CF
 3949:     F4D2 D6 C8                          LDAB CLASS
 3950:     F4D4 C1 09                          CMPB #XLIMM
 3951:     F4D6 26 04                          BNE  DISXLN2
 3952:     F4D8 C6 11                          LDAB #YLIMM
 3953:     F4DA 20 02                          BRA  DISXLN3    ;look for ylimm
 3954:     F4DC C6 12                  DISXLN2 LDAB #YNIMM     ;look for ynimm
 3955:     F4DE BD F4FB                DISXLN3 JSR  DISRCH
 3956:     F4E1 D6 D6                  DISXLN4 LDAB PNORM
 3957:     F4E3 C1 02                          CMPB #PG3
 3958:     F4E5 25 0C                          BLO  DISXLN5    ;jump if page 1 or 2
 3959:     F4E7 96 C7                          LDAA BASEOP     ;get opcode
 3960:     F4E9 84 B0                          ANDA #$B0       ;mask bits 6,3-0
 3961:     F4EB 81 A0                          CMPA #$A0
 3962:     F4ED 27 04                          BEQ  DISXLN5    ;jump opcode = $Ax or $Ex
 3963:     F4EF BD F5CC                        JSR  DISILLOP   ;"illegal opcode"
 3964:     F4F2 39                             RTS
 3965:     F4F3 C6 08                  DISXLN5 LDAB #LIMM
 3966:     F4F5 D7 C8                          STAB CLASS
 3967:     F4F7 BD F576                        JSR  DISGENRL   ;process general class
 3968:     F4FA 39                             RTS
 3969:                                 
 3970:                                 
 3971:                                 ******************
 3972:                                 *disrch(a=opcode,b=class)
 3973:                                 *return b=0 if not found
 3974:                                 *  else mneptr=points to mnemonic
 3975:                                 *        class=class of opcode
 3976:                                 ******************
 3977:                                 *x=#MNETABL
 3978:                                 *while(x[0] != eot)
 3979:                                 *   if((opcode==x[4]) && ((class=NULL) || (class=x[5])))
 3980:                                 *      mneptr=x;
 3981:                                 *      class=x[5];
 3982:                                 *      return(1);
 3983:                                 *   x += 6;
 3984:                                 *return(0);      /* not found */
 3985:                                 
 3986:          =0000F4FB              DISRCH  EQU  *
 3987:     F4FB CE EFC8                        LDX  #MNETABL   ;point to top of table
 3988:     F4FE A1 04                  DISRCH1 CMPA 4,X        ;test opcode
 3989:     F500 26 0F                          BNE  DISRCH3    ;jump not this entry
 3990:     F502 5D                             TSTB
 3991:     F503 27 04                          BEQ  DISRCH2    ;jump if class=null
 3992:     F505 E1 05                          CMPB 5,X        ;test class
 3993:     F507 26 08                          BNE  DISRCH3    ;jump not this entry
 3994:     F509 E6 05                  DISRCH2 LDAB 5,X
 3995:     F50B D7 C8                          STAB CLASS
 3996:     F50D DF CD                          STX  MNEPTR     ;return ptr to mnemonic
 3997:     F50F 5C                             INCB
 3998:     F510 39                             RTS             ;return found
 3999:     F511 37                     DISRCH3 PSHB            ;save class
 4000:     F512 C6 06                          LDAB #6
 4001:     F514 3A                             ABX
 4002:     F515 E6 00                          LDAB 0,X
 4003:     F517 C1 04                          CMPB #EOT       ;test end of table
 4004:     F519 33                             PULB
 4005:     F51A 26 E2                          BNE  DISRCH1
 4006:     F51C 5F                             CLRB
 4007:     F51D 39                             RTS             ;return not found
 4008:                                 
 4009:                                 ******************
 4010:                                 *prntmne() - output the mnemonic pointed
 4011:                                 *at by mneptr.
 4012:                                 ******************
 4013:                                 *outa(mneptr[0-3]);
 4014:                                 *outspac;
 4015:                                 *return();
 4016:                                 
 4017:          =0000F51E              PRNTMNE EQU  *
 4018:     F51E DE CD                          LDX  MNEPTR
 4019:     F520 A6 00                          LDAA 0,X
 4020:     F522 BD E509                        JSR  OUTA       ;output char1
 4021:     F525 A6 01                          LDAA 1,X
 4022:     F527 BD E509                        JSR  OUTA       ;output char2
 4023:     F52A A6 02                          LDAA 2,X
 4024:     F52C BD E509                        JSR  OUTA       ;output char3
 4025:     F52F A6 03                          LDAA 3,X
 4026:     F531 BD E509                        JSR  OUTA       ;output char4
 4027:     F534 BD E51F                        JSR  OUTSPAC
 4028:     F537 39                             RTS
 4029:                                 
 4030:                                 ******************
 4031:                                 *disindx() - process indexed mode
 4032:                                 ******************
 4033:                                 *disdir();
 4034:                                 *outa(',');
 4035:                                 *if(pnorm == (PG2 or PG4)) outa('Y');
 4036:                                 *else outa('X');
 4037:                                 *return();
 4038:                                 
 4039:          =0000F538              DISINDX EQU  *
 4040:     F538 BD F5AC                        JSR  DISDIR     ;output $byte
 4041:     F53B 86 2C                          LDAA #','
 4042:     F53D BD E509                        JSR  OUTA       ;output ,
 4043:     F540 D6 D6                          LDAB PNORM
 4044:     F542 C1 01                          CMPB #PG2
 4045:     F544 27 04                          BEQ  DISIND1    ;jump if page2
 4046:     F546 C1 03                          CMPB #PG4
 4047:     F548 26 04                          BNE  DISIND2    ;jump if not page4
 4048:     F54A 86 59                  DISIND1 LDAA #'Y'
 4049:     F54C 20 02                          BRA DISIND3
 4050:     F54E 86 58                  DISIND2 LDAA #'X'
 4051:     F550 BD E509                DISIND3 JSR  OUTA       ;output x or y
 4052:     F553 39                             RTS
 4053:                                 
 4054:                                 ******************
 4055:                                 *disrelad() - compute and output relative address.
 4056:                                 ******************
 4057:                                 * braddr = dispc[0] + (dispc++);( 2's comp arith)
 4058:                                 *outa('$');
 4059:                                 *out2bsp(braddr);
 4060:                                 *return();
 4061:                                 
 4062:          =0000F554              DISRELAD EQU *
 4063:     F554 DE C9                          LDX  DISPC
 4064:     F556 E6 00                          LDAB 0,X        ;get relative offset
 4065:     F558 08                             INX
 4066:     F559 DF C9                          STX  DISPC
 4067:     F55B 5D                             TSTB
 4068:     F55C 2B 03                          BMI  DISRLD1    ;jump if negative
 4069:     F55E 3A                             ABX
 4070:     F55F 20 04                          BRA  DISRLD2
 4071:     F561 09                     DISRLD1 DEX
 4072:     F562 5C                             INCB
 4073:     F563 26 FC                          BNE  DISRLD1    ;subtract
 4074:     F565 DF CB                  DISRLD2 STX  BRADDR     ;save address
 4075:     F567 BD E51F                        JSR  OUTSPAC
 4076:     F56A 86 24                          LDAA #'$'
 4077:     F56C BD E509                        JSR  OUTA
 4078:     F56F CE 00CB                        LDX  #BRADDR
 4079:     F572 BD E519                        JSR  OUT2BSP    ;output address
 4080:     F575 39                             RTS
 4081:                                 
 4082:                                 
 4083:                                 ******************
 4084:                                 *disgenrl() - output data for the general cases which
 4085:                                 *includes immediate, direct, indexed, and extended modes.
 4086:                                 ******************
 4087:                                 *prntmne();
 4088:                                 *if(baseop == ($8x or $Cx))   /* immediate */
 4089:                                 *   outa('#');
 4090:                                 *   disdir();
 4091:                                 *   if(class == LIMM)
 4092:                                 *      out1byt(dispc++);
 4093:                                 *elseif(baseop == ($9x or $Dx))  /* direct */
 4094:                                 *   disdir();
 4095:                                 *elseif(baseop == ($Ax or $Ex)) /* indexed */
 4096:                                 *   disindx();
 4097:                                 *else  (baseop == ($Bx or $Fx)) /* extended */
 4098:                                 *   disext();
 4099:                                 *return();
 4100:                                 
 4101:          =0000F576              DISGENRL EQU *
 4102:     F576 BD F51E                        JSR  PRNTMNE    ;print mnemonic
 4103:     F579 96 C7                          LDAA BASEOP     ;get opcode
 4104:     F57B 84 B0                          ANDA #$B0       ;mask bits 6,3-0
 4105:     F57D 81 80                          CMPA #$80
 4106:     F57F 26 17                          BNE  DISGRL2   ;jump if not immed
 4107:     F581 86 23                          LDAA #'#'       ;do immediate
 4108:     F583 BD E509                        JSR  OUTA
 4109:     F586 BD F5AC                        JSR  DISDIR
 4110:     F589 D6 C8                          LDAB CLASS
 4111:     F58B C1 08                          CMPB #LIMM
 4112:     F58D 27 01                          BEQ  DISGRL1   ;jump class = limm
 4113:     F58F 39                             RTS
 4114:     F590 DE C9                  DISGRL1 LDX  DISPC
 4115:     F592 BD E50D                        JSR  OUT1BYT
 4116:     F595 DF C9                          STX  DISPC
 4117:     F597 39                             RTS
 4118:     F598 81 90                  DISGRL2 CMPA #$90
 4119:     F59A 26 04                          BNE  DISGRL3    ;jump not direct
 4120:     F59C BD F5AC                        JSR  DISDIR     ;do direct
 4121:     F59F 39                             RTS
 4122:     F5A0 81 A0                  DISGRL3 CMPA #$A0
 4123:     F5A2 26 04                          BNE  DISGRL4    ;jump not indexed
 4124:     F5A4 BD F538                        JSR  DISINDX    ;do extended
 4125:     F5A7 39                             RTS
 4126:     F5A8 BD F5B9                DISGRL4 JSR  DISEXT     ;do extended
 4127:     F5AB 39                             RTS
 4128:                                 
 4129:                                 *****************
 4130:                                 *disdir() - output "$ next byte"
 4131:                                 *****************
 4132:          =0000F5AC              DISDIR  EQU  *
 4133:     F5AC 86 24                          LDAA #'$'
 4134:     F5AE BD E509                        JSR  OUTA
 4135:     F5B1 DE C9                          LDX  DISPC
 4136:     F5B3 BD E50D                        JSR  OUT1BYT
 4137:     F5B6 DF C9                          STX  DISPC
 4138:     F5B8 39                             RTS
 4139:                                 
 4140:                                 *****************
 4141:                                 *disext() - output "$ next 2 bytes"
 4142:                                 *****************
 4143:          =0000F5B9              DISEXT  EQU  *
 4144:     F5B9 86 24                          LDAA #'$'
 4145:     F5BB BD E509                        JSR  OUTA
 4146:     F5BE DE C9                          LDX  DISPC
 4147:     F5C0 BD E519                        JSR  OUT2BSP
 4148:     F5C3 DF C9                          STX  DISPC
 4149:     F5C5 39                             RTS
 4150:                                 
 4151:                                 
 4152:                                 *****************
 4153:                                 *disillop() - output "illegal opcode"
 4154:                                 *****************
 4155:     F5C6 49 4C 4C 4F 50         DISMSG1 FCC  'ILLOP'
 4156:     F5CB 04                             FCB  EOT
 4157:          =0000F5CC              DISILLOP EQU *
 4158:     F5CC 3C                             PSHX
 4159:     F5CD CE F5C6                        LDX  #DISMSG1
 4160:     F5D0 BD E53B                        JSR  OUTSTRG0   ;no cr
 4161:     F5D3 38                             PULX
 4162:     F5D4 39                             RTS
 4163:                                 
 4164:                                 
 4165:                                 
 4166:                                 **********
 4167:                                 *   help  -  List buffalo commands to terminal.
 4168:                                 **********
 4169:          =0000F5D5              HELP     EQU  *
 4170:     F5D5 CE F5DC                         LDX  #HELPMSG1
 4171:     F5D8 BD E538                         JSR  OUTSTRG    ;print help screen
 4172:     F5DB 39                              RTS
 4173:                                 
 4174:          =0000F5DC              HELPMSG1 EQU  *
 4175:     F5DC 41 53 4D 20 5B 3C               FCC  'ASM [<addr>]  Line asm/disasm'
           F5E2 61 64 64 72 3E 5D 
           F5E8 20 20 4C 69 6E 65 
           F5EE 20 61 73 6D 2F 64 
           F5F4 69 73 61 73 6D 
 4176:     F5F9 0D                              FCB  $0D
 4177:     F5FA 20 20 5B 2F 2C 3D               FCC  '  [/,=]  Same addr,       [^,-]  Prev addr,       [+,CTLJ] Next addr'
           F600 5D 20 20 53 61 6D 
           F606 65 20 61 64 64 72 
           F60C 2C 20 20 20 20 20 
           F612 20 20 5B 5E 2C 2D 
           F618 5D 20 20 50 72 65 
           F61E 76 20 61 64 64 72 
           F624 2C 20 20 20 20 20 
           F62A 20 20 5B 2B 2C 43 
           F630 54 4C 4A 5D 20 4E 
           F636 65 78 74 20 61 64 
           F63C 64 72 
 4178:     F63E 0D                              FCB  $0D
 4179:     F63F 20 20 5B 43 52 5D               FCC  '  [CR]  Next opcode,                              [CTLA,.]  Quit'
           F645 20 20 4E 65 78 74 
           F64B 20 6F 70 63 6F 64 
           F651 65 2C 20 20 20 20 
           F657 20 20 20 20 20 20 
           F65D 20 20 20 20 20 20 
           F663 20 20 20 20 20 20 
           F669 20 20 20 20 20 20 
           F66F 20 20 5B 43 54 4C 
           F675 41 2C 2E 5D 20 20 
           F67B 51 75 69 74 
 4180:     F67F 0D                              FCB  $0D
 4181:     F680 42 46 20 3C 61 64               FCC  'BF <addr1> <addr2> [<data>]  Block fill memory'
           F686 64 72 31 3E 20 3C 
           F68C 61 64 64 72 32 3E 
           F692 20 5B 3C 64 61 74 
           F698 61 3E 5D 20 20 42 
           F69E 6C 6F 63 6B 20 66 
           F6A4 69 6C 6C 20 6D 65 
           F6AA 6D 6F 72 79 
 4182:     F6AE 0D                              FCB  $0D
 4183:     F6AF 42 52 20 5B 2D 5D               FCC  'BR [-][<addr>] Set up bkpt table'
           F6B5 5B 3C 61 64 64 72 
           F6BB 3E 5D 20 53 65 74 
           F6C1 20 75 70 20 62 6B 
           F6C7 70 74 20 74 61 62 
           F6CD 6C 65 
 4184:     F6CF 0D                              FCB  $0D
 4185:     F6D0 42 55 4C 4B 20 20               FCC  'BULK  Erase EEPROM,                 BULKALL  Erase EEPROM and CONFIG'
           F6D6 45 72 61 73 65 20 
           F6DC 45 45 50 52 4F 4D 
           F6E2 2C 20 20 20 20 20 
           F6E8 20 20 20 20 20 20 
           F6EE 20 20 20 20 20 20 
           F6F4 42 55 4C 4B 41 4C 
           F6FA 4C 20 20 45 72 61 
           F700 73 65 20 45 45 50 
           F706 52 4F 4D 20 61 6E 
           F70C 64 20 43 4F 4E 46 
           F712 49 47 
 4186:     F714 0D                              FCB  $0D
 4187:     F715 43 41 4C 4C 20 5B               FCC  'CALL [<addr>] Call subroutine'
           F71B 3C 61 64 64 72 3E 
           F721 5D 20 43 61 6C 6C 
           F727 20 73 75 62 72 6F 
           F72D 75 74 69 6E 65 
 4188:     F732 0D                              FCB  $0D
 4189:     F733 47 4F 20 5B 3C 61               FCC  'GO [<addr>] Execute code at addr,        PROCEED  Continue execution'
           F739 64 64 72 3E 5D 20 
           F73F 45 78 65 63 75 74 
           F745 65 20 63 6F 64 65 
           F74B 20 61 74 20 61 64 
           F751 64 72 2C 20 20 20 
           F757 20 20 20 20 20 50 
           F75D 52 4F 43 45 45 44 
           F763 20 20 43 6F 6E 74 
           F769 69 6E 75 65 20 65 
           F76F 78 65 63 75 74 69 
           F775 6F 6E 
 4190:     F777 0D                              FCB  $0D
 4191:     F778 45 45 4D 4F 44 20               FCC  'EEMOD [<addr> [<addr>]] Modify EEPROM range'
           F77E 5B 3C 61 64 64 72 
           F784 3E 20 5B 3C 61 64 
           F78A 64 72 3E 5D 5D 20 
           F790 4D 6F 64 69 66 79 
           F796 20 45 45 50 52 4F 
           F79C 4D 20 72 61 6E 67 
           F7A2 65 
 4192:     F7A3 0D                              FCB  $0D
 4193:     F7A4 4C 4F 41 44 2C 20               FCC  'LOAD, VERIFY [T] <host dwnld command>  Load or verify S-records'
           F7AA 56 45 52 49 46 59 
           F7B0 20 5B 54 5D 20 3C 
           F7B6 68 6F 73 74 20 64 
           F7BC 77 6E 6C 64 20 63 
           F7C2 6F 6D 6D 61 6E 64 
           F7C8 3E 20 20 4C 6F 61 
           F7CE 64 20 6F 72 20 76 
           F7D4 65 72 69 66 79 20 
           F7DA 53 2D 72 65 63 6F 
           F7E0 72 64 73 
 4194:     F7E3 0D                              FCB  $0D
 4195:     F7E4 4D 44 20 5B 3C 61               FCC  'MD [<addr1> [<addr2>]]  Memory dump'
           F7EA 64 64 72 31 3E 20 
           F7F0 5B 3C 61 64 64 72 
           F7F6 32 3E 5D 5D 20 20 
           F7FC 4D 65 6D 6F 72 79 
           F802 20 64 75 6D 70 
 4196:     F807 0D                              FCB  $0D
 4197:     F808 4D 4D 20 5B 3C 61               FCC  'MM [<addr>] or [<addr>]/  Memory Modify'
           F80E 64 64 72 3E 5D 20 
           F814 6F 72 20 5B 3C 61 
           F81A 64 64 72 3E 5D 2F 
           F820 20 20 4D 65 6D 6F 
           F826 72 79 20 4D 6F 64 
           F82C 69 66 79 
 4198:     F82F 0D                              FCB  $0D
 4199:     F830 20 20 5B 2F 2C 3D               FCC  '  [/,=]  Same addr,  [^,-,CTLH] Prev addr,  [+,CTLJ,SPACE] Next addr'
           F836 5D 20 20 53 61 6D 
           F83C 65 20 61 64 64 72 
           F842 2C 20 20 5B 5E 2C 
           F848 2D 2C 43 54 4C 48 
           F84E 5D 20 50 72 65 76 
           F854 20 61 64 64 72 2C 
           F85A 20 20 5B 2B 2C 43 
           F860 54 4C 4A 2C 53 50 
           F866 41 43 45 5D 20 4E 
           F86C 65 78 74 20 61 64 
           F872 64 72 
 4200:     F874 0D                              FCB  $0D
 4201:     F875 20 20 3C 61 64 64               FCC  '  <addr>O Compute offset,                   [CR]  Quit'
           F87B 72 3E 4F 20 43 6F 
           F881 6D 70 75 74 65 20 
           F887 6F 66 66 73 65 74 
           F88D 2C 20 20 20 20 20 
           F893 20 20 20 20 20 20 
           F899 20 20 20 20 20 20 
           F89F 20 20 5B 43 52 5D 
           F8A5 20 20 51 75 69 74 
 4202:     F8AB 0D                              FCB  $0D
 4203:     F8AC 4D 4F 56 45 20 3C               FCC  'MOVE <s1> <s2> [<d>]  Block move'
           F8B2 73 31 3E 20 3C 73 
           F8B8 32 3E 20 5B 3C 64 
           F8BE 3E 5D 20 20 42 6C 
           F8C4 6F 63 6B 20 6D 6F 
           F8CA 76 65 
 4204:     F8CC 0D                              FCB  $0D
 4205:     F8CD 4F 46 46 53 45 54               FCC  'OFFSET [-]<arg>  Offset for download'
           F8D3 20 5B 2D 5D 3C 61 
           F8D9 72 67 3E 20 20 4F 
           F8DF 66 66 73 65 74 20 
           F8E5 66 6F 72 20 64 6F 
           F8EB 77 6E 6C 6F 61 64 
 4206:     F8F1 0D                              FCB  $0D
 4207:     F8F2 52 4D 20 5B 50 2C               FCC  'RM [P,Y,X,A,B,C,S]  Register modify'
           F8F8 59 2C 58 2C 41 2C 
           F8FE 42 2C 43 2C 53 5D 
           F904 20 20 52 65 67 69 
           F90A 73 74 65 72 20 6D 
           F910 6F 64 69 66 79 
 4208:     F915 0D                              FCB  $0D
 4209:     F916 53 54 4F 50 41 54               FCC  'STOPAT <addr>  Trace until addr'
           F91C 20 3C 61 64 64 72 
           F922 3E 20 20 54 72 61 
           F928 63 65 20 75 6E 74 
           F92E 69 6C 20 61 64 64 
           F934 72 
 4210:     F935 0D                              FCB  $0D
 4211:     F936 54 20 5B 3C 6E 3E               FCC  'T [<n>]  Trace n instructions'
           F93C 5D 20 20 54 72 61 
           F942 63 65 20 6E 20 69 
           F948 6E 73 74 72 75 63 
           F94E 74 69 6F 6E 73 
 4212:     F953 0D                              FCB  $0D
 4213:     F954 54 4D 20 20 54 72               FCC  'TM  Transparent mode (CTLA = exit, CTLB = send brk)'
           F95A 61 6E 73 70 61 72 
           F960 65 6E 74 20 6D 6F 
           F966 64 65 20 28 43 54 
           F96C 4C 41 20 3D 20 65 
           F972 78 69 74 2C 20 43 
           F978 54 4C 42 20 3D 20 
           F97E 73 65 6E 64 20 62 
           F984 72 6B 29 
 4214:     F987 0D                              FCB  $0D
 4215:     F988 5B 43 54 4C 57 5D               FCC  '[CTLW]  Wait,          [CTLX,DEL] Abort         [CR] Repeat last cmd'
           F98E 20 20 57 61 69 74 
           F994 2C 20 20 20 20 20 
           F99A 20 20 20 20 20 5B 
           F9A0 43 54 4C 58 2C 44 
           F9A6 45 4C 5D 20 41 62 
           F9AC 6F 72 74 20 20 20 
           F9B2 20 20 20 20 20 20 
           F9B8 5B 43 52 5D 20 52 
           F9BE 65 70 65 61 74 20 
           F9C4 6C 61 73 74 20 63 
           F9CA 6D 64 
 4216:     F9CC 0D                              FCB  $0D
 4217:     F9CD 04                              FCB  4
 4218:                                 
 4219:                                 
 4220:                                 
 4221:                                 **********
 4222:                                 *   call [<addr>] - Execute a jsr to <addr> or user
 4223:                                 *pc value.  Return to monitor via  rts or breakpoint.
 4224:                                 **********
 4225:                                 *a = wskip();
 4226:                                 *if(a != cr)
 4227:                                 *     a = buffarg();
 4228:                                 *     a = wskip();
 4229:                                 *     if(a != cr) return(bad argument)
 4230:                                 *     pc = shftreg;
 4231:     F9CE BD E2FC                CALL     JSR  WSKIP
 4232:     F9D1 27 13                           BEQ  CALL3       ;jump if no arg
 4233:     F9D3 BD E234                         JSR  BUFFARG
 4234:     F9D6 BD E2FC                         JSR  WSKIP
 4235:     F9D9 27 07                           BEQ  CALL2       ;jump if cr
 4236:     F9DB CE E6CB                         LDX  #MSG9       ;"bad argument"
 4237:     F9DE BD E538                         JSR  OUTSTRG
 4238:     F9E1 39                              RTS
 4239:     F9E2 DE A9                  CALL2    LDX  SHFTREG
 4240:     F9E4 DF 73                           STX  REGS        ;pc = <addr>
 4241:                                 
 4242:                                 *put return address on user stack
 4243:                                 *setbps();
 4244:                                 *restack();     /* restack and go*/
 4245:     F9E6 DE 7C                  CALL3    LDX  SP
 4246:     F9E8 09                              DEX              ;user stack pointer
 4247:     F9E9 CC F9FA                         LDD  #RETURN     ;return address
 4248:     F9EC ED 00                           STD  0,X
 4249:     F9EE 09                              DEX
 4250:     F9EF DF 7C                           STX  SP          ;new user stack pointer
 4251:     F9F1 BD FA6B                         JSR  SETBPS
 4252:     F9F4 7F 00D4                         CLR  TMP2        ;1=go, 0=call
 4253:     F9F7 7E FB5B                         JMP  RESTACK     ;go to user code
 4254:                                 
 4255:                                 **********
 4256:                                 *   return() - Return here from rts after
 4257:                                 *call command.
 4258:                                 **********
 4259:     F9FA 36                     RETURN   PSHA             ;save a register
 4260:     F9FB 07                              TPA
 4261:     F9FC 97 7B                           STAA REGS+8      ;cc register
 4262:     F9FE 0F                              SEI              ;mask interrupts
 4263:     F9FF 32                              PULA
 4264:     FA00 DD 79                           STD  REGS+6      ;a and b registers
 4265:     FA02 DF 77                           STX  REGS+4      ;x register
 4266:     FA04 18DF 75                         STY  REGS+2      ;y register
 4267:     FA07 9F 7C                           STS  SP          ;user stack pointer
 4268:     FA09 9E C5                           LDS  PTR2        ;monitor stack pointer
 4269:     FA0B BD FA9B                         JSR  REMBPS      ;remove breakpoints
 4270:     FA0E BD E531                         JSR  OUTCRLF
 4271:     FA11 BD E1F3                         JSR  RPRINT      ;print user registers
 4272:     FA14 39                              RTS
 4273:                                 
 4274:                                 
 4275:                                 **********
 4276:                                 *   proceed - Same as go except it ignores
 4277:                                 *a breakpoint at the first opcode.  Calls
 4278:                                 *runone for the first instruction only.
 4279:                                 **********
 4280:          =0000FA15              PROCEED  EQU  *
 4281:     FA15 BD FB3E                         JSR  RUNONE      ;run one instruction
 4282:     FA18 BD E31F                         JSR  CHKABRT     ;check for abort
 4283:     FA1B 7F 00D4                         CLR  TMP2        ;flag for breakpoints
 4284:     FA1E 7C 00D4                         INC  TMP2        ;  1=go 0=call
 4285:     FA21 BD FA6B                         JSR  SETBPS
 4286:     FA24 7E FB5B                         JMP  RESTACK     ;go execute
 4287:                                 
 4288:                                 **********
 4289:                                 *   go [<addr>] - Execute starting at <addr> or
 4290:                                 *user's pc value.  Executes an rti to user code.
 4291:                                 *Returns to monitor via an swi through swiin.
 4292:                                 **********
 4293:                                 *a = wskip();
 4294:                                 *if(a != cr)
 4295:                                 *     a = buffarg();
 4296:                                 *     a = wskip();
 4297:                                 *     if(a != cr) return(bad argument)
 4298:                                 *     pc = shftreg;
 4299:                                 *setbps();
 4300:                                 *restack();     /* restack and go*/
 4301:     FA27 BD E2FC                GO       JSR  WSKIP
 4302:     FA2A 27 13                           BEQ  GO2         ;jump if no arg
 4303:     FA2C BD E234                         JSR  BUFFARG
 4304:     FA2F BD E2FC                         JSR  WSKIP
 4305:     FA32 27 07                           BEQ  GO1         ;jump if cr
 4306:     FA34 CE E6CB                         LDX  #MSG9       ;"bad argument"
 4307:     FA37 BD E538                         JSR  OUTSTRG
 4308:     FA3A 39                              RTS
 4309:     FA3B DE A9                  GO1      LDX  SHFTREG
 4310:     FA3D DF 73                           STX  REGS        ;pc = <addr>
 4311:     FA3F 7F 00D4                GO2      CLR  TMP2
 4312:     FA42 7C 00D4                         INC  TMP2        ;1=go, 0=call
 4313:     FA45 BD FA6B                         JSR  SETBPS
 4314:     FA48 7E FB5B                         JMP  RESTACK     ;go to user code
 4315:                                 
 4316:                                 *****
 4317:                                 ** SWIIN - Breakpoints from go or call commands enter here.
 4318:                                 *Remove breakpoints, save user registers, return
 4319:          =0000FA4B              SWIIN    EQU  *        ;swi entry point
 4320:     FA4B 30                              TSX           ;user sp -> x
 4321:     FA4C 9E C5                           LDS  PTR2     ;restore monitor sp
 4322:     FA4E BD FB7A                         JSR  SAVSTACK ;save user regs
 4323:     FA51 BD FA9B                         JSR  REMBPS   ;remove breakpoints from code
 4324:     FA54 DE 73                           LDX  REGS
 4325:     FA56 09                              DEX
 4326:     FA57 DF 73                           STX  REGS     ;save user pc value
 4327:                                 
 4328:                                 *if(call command) remove call return addr from user stack;
 4329:     FA59 7D 00D4                         TST  TMP2     ;1=go, 0=call
 4330:     FA5C 26 06                           BNE  GO3      ;jump if go command
 4331:     FA5E DE 7C                           LDX  SP       ;remove return address
 4332:     FA60 08                              INX            ; user stack pointer
 4333:     FA61 08                              INX
 4334:     FA62 DF 7C                           STX  SP
 4335:     FA64 BD E531                GO3      JSR  OUTCRLF  ;print register values
 4336:     FA67 BD E1F3                         JSR  RPRINT
 4337:     FA6A 39                              RTS           ;done
 4338:                                 
 4339:                                 **********
 4340:                                 *  setbps - Replace user code with swi's at
 4341:                                 *breakpoint addresses.
 4342:                                 **********
 4343:                                 *for(b=0; b=6; b =+ 2)
 4344:                                 *     x = brktabl[b];
 4345:                                 *     if(x != 0)
 4346:                                 *          optabl[b] = x[0];
 4347:                                 *          x[0] = $3F;
 4348:                                 *Put monitor SWI vector into jump table
 4349:                                 
 4350:     FA6B 5F                     SETBPS   CLRB
 4351:     FA6C CE 00AF                SETBPS1  LDX  #BRKTABL
 4352:     FA6F 18CE 00C9                       LDY  #PTR4
 4353:     FA73 3A                              ABX
 4354:     FA74 183A                            ABY
 4355:     FA76 EE 00                           LDX  0,X         ;breakpoint table entry
 4356:     FA78 27 0A                           BEQ  SETBPS2     ;jump if 0
 4357:     FA7A A6 00                           LDAA 0,X         ;save user opcode
 4358:     FA7C 18A7 00                         STAA 0,Y
 4359:     FA7F 86 3F                           LDAA #SWI
 4360:     FA81 BD E28A                         JSR  WRITE       ;insert swi into code
 4361:     FA84 CB 02                  SETBPS2  ADDB #$2
 4362:     FA86 C1 06                           CMPB #$6
 4363:     FA88 2F E2                           BLE  SETBPS1     ;loop 4 times
 4364:     FA8A FE 0108                         LDX  JSWI+1
 4365:     FA8D DF C7                           STX  PTR3        ;save user swi vector
 4366:     FA8F 86 7E                           LDAA #$7E        ;jmp opcode
 4367:     FA91 B7 0107                         STAA JSWI
 4368:     FA94 CE FA4B                         LDX  #SWIIN
 4369:     FA97 FF 0108                         STX  JSWI+1      ;monitor swi vector
 4370:     FA9A 39                              RTS
 4371:                                 
 4372:                                 **********
 4373:                                 *   rembps - Remove breakpoints from user code.
 4374:                                 **********
 4375:                                 *for(b=0; b=6; b =+ 2)
 4376:                                 *     x = brktabl[b];
 4377:                                 *     if(x != 0)
 4378:                                 *          x[0] = optabl[b];
 4379:                                 *Replace user's SWI vector
 4380:     FA9B 5F                     REMBPS   CLRB
 4381:     FA9C CE 00AF                REMBPS1  LDX  #BRKTABL
 4382:     FA9F 18CE 00C9                       LDY  #PTR4
 4383:     FAA3 3A                              ABX
 4384:     FAA4 183A                            ABY
 4385:     FAA6 EE 00                           LDX  0,X         ;breakpoint table entry
 4386:     FAA8 27 06                           BEQ  REMBPS2     ;jump if 0
 4387:     FAAA 18A6 00                         LDAA 0,Y
 4388:     FAAD BD E28A                         JSR  WRITE       ;restore user opcode
 4389:     FAB0 CB 02                  REMBPS2  ADDB #$2
 4390:     FAB2 C1 06                           CMPB #$6
 4391:     FAB4 2F E6                           BLE  REMBPS1     ;loop 4 times
 4392:     FAB6 DE C7                           LDX  PTR3        ;restore user swi vector
 4393:     FAB8 FF 0108                         STX  JSWI+1
 4394:     FABB 39                              RTS
 4395:                                 
 4396:                                 
 4397:                                 **********
 4398:                                 *   trace <n> - Trace n instructions starting
 4399:                                 *at user's pc value. n is a hex number less than
 4400:                                 *$FF (defaults to 1).
 4401:                                 **********
 4402:                                 *a = wskip();
 4403:                                 *if(a != cr)
 4404:                                 *     a = buffarg(); a = wskip();
 4405:                                 *     if(a != cr) return(bad argument);
 4406:                                 *     countt1 = n
 4407:     FABC 7F 00D6                TRACE    CLR  TMP4
 4408:     FABF 7C 00D6                         INC  TMP4        ;default count=1
 4409:     FAC2 7F 00BC                         CLR  CHRCNT      ;set up for display
 4410:     FAC5 BD E2FC                         JSR  WSKIP
 4411:     FAC8 27 13                           BEQ  TRACE2      ;jump if cr
 4412:     FACA BD E234                         JSR  BUFFARG
 4413:     FACD BD E2FC                         JSR  WSKIP
 4414:     FAD0 27 07                           BEQ  TRACE1      ;jump if cr
 4415:     FAD2 CE E6CB                         LDX  #MSG9       ;"bad argument"
 4416:     FAD5 BD E538                         JSR  OUTSTRG
 4417:     FAD8 39                              RTS
 4418:     FAD9 96 AA                  TRACE1   LDAA SHFTREG+1   ;n
 4419:     FADB 97 D6                           STAA TMP4
 4420:                                 
 4421:                                 *Disassemble the line about to be traced
 4422:          =0000FADD              TRACE2   EQU  *
 4423:     FADD D6 D6                           LDAB TMP4
 4424:     FADF 37                              PSHB
 4425:     FAE0 DE 73                           LDX  REGS
 4426:     FAE2 DF C3                           STX  PTR1        ;pc value for disass
 4427:     FAE4 BD F347                         JSR  DISASSM
 4428:     FAE7 33                              PULB
 4429:     FAE8 D7 D6                           STAB TMP4
 4430:                                 
 4431:                                 *run one instruction
 4432:                                 *rprint();
 4433:                                 *while(count > 0) continue trace;
 4434:     FAEA BD FB3E                         JSR  RUNONE
 4435:     FAED BD E31F                         JSR  CHKABRT     ;check for abort
 4436:     FAF0 BD E558                         JSR  TABTO       ;print registers for
 4437:     FAF3 BD E1F3                         JSR  RPRINT       ;   result of trace
 4438:     FAF6 7A 00D6                         DEC  TMP4
 4439:     FAF9 27 05                           BEQ  TRACDON     ;quit if count=0
 4440:     FAFB BD E531                TRACE3   JSR  OUTCRLF
 4441:     FAFE 20 DD                           BRA  TRACE2
 4442:     FB00 39                     TRACDON  RTS
 4443:                                 
 4444:                                 
 4445:                                 **********
 4446:                                 *   stopat <addr> - Trace instructions until <addr>
 4447:                                 *is reached.
 4448:                                 **********
 4449:                                 *if((a=wskip) != cr)
 4450:                                 *     a = buffarg(); a = wskip();
 4451:                                 *     if(a != cr) return(bad argument);
 4452:                                 *else return(bad argument);
 4453:          =0000FB01              STOPAT   EQU  *
 4454:     FB01 BD E2FC                         JSR  WSKIP
 4455:     FB04 27 18                           BEQ  STOPGO    ;jump if cr - no argument
 4456:     FB06 BD E234                         JSR  BUFFARG
 4457:     FB09 BD E2FC                         JSR  WSKIP
 4458:     FB0C 27 07                           BEQ  STOPAT1   ;jump if cr
 4459:     FB0E CE E6CB                         LDX  #MSG9     ;"bad argument"
 4460:     FB11 BD E538                         JSR  OUTSTRG
 4461:     FB14 39                              RTS
 4462:     FB15 7D 00BB                STOPAT1  TST  COUNT
 4463:     FB18 27 04                           BEQ  STOPGO    ;jump if no argument
 4464:     FB1A DE A9                           LDX  SHFTREG
 4465:     FB1C DF BD                           STX  PTRMEM    ;update "current location"
 4466:                                 
 4467:                                 *while(!(ptrmem <= userpc < ptrmem+10)) runone();
 4468:                                 *rprint();
 4469:     FB1E DC 73                  STOPGO   LDD  REGS      ;userpc
 4470:     FB20 1A93 BD                         CPD  PTRMEM
 4471:     FB23 25 0A                           BLO  STOPNEXT  ;if(userpc < ptrmem) runone
 4472:     FB25 DC BD                           LDD  PTRMEM
 4473:     FB27 C3 000A                         ADDD #10
 4474:     FB2A 1A93 73                         CPD  REGS
 4475:     FB2D 22 08                           BHI  STOPDON   ;quit if ptrmem+10 > userpc
 4476:     FB2F BD FB3E                STOPNEXT JSR  RUNONE
 4477:     FB32 BD E31F                         JSR  CHKABRT   ;check for abort
 4478:     FB35 20 E7                           BRA  STOPGO
 4479:     FB37 BD E531                STOPDON  JSR  OUTCRLF
 4480:     FB3A BD E1F3                         JSR  RPRINT    ;result of trace
 4481:     FB3D 39                              RTS            ;done
 4482:                                 
 4483:                                 
 4484:                                 *************************
 4485:                                 * runone - This routine is used by the trace and
 4486:                                 * execute commands to run one only one user instruction.
 4487:                                 *   Control is passed to the user code via an RTI.  OC5
 4488:                                 * is then used to trigger an XIRQ as soon as the first user
 4489:                                 * opcode is fetched.  Control then returns to the monitor
 4490:                                 * through XIRQIN.
 4491:                                 *  Externally, the OC5 pin must be wired to the XIRQ pin.
 4492:                                 ************************
 4493:                                 * Disable oc5 interrupts
 4494:                                 * Put monitor XIRQ vector into jump table
 4495:                                 * Unmask x bit in user ccr
 4496:                                 * Setup OC5 to go low when first user instruction executed
 4497:          =0000FB3E              RUNONE  EQU  *
 4498:     FB3E 86 7E                          LDAA #$7E        ;put "jmp xirqin" in jump table
 4499:     FB40 97 E6                          STAA JTOC5
 4500:     FB42 CE FB77                        LDX  #XIRQIN
 4501:     FB45 FF 0105                        STX  JXIRQ+1
 4502:     FB48 96 7B                          LDAA REGS+8      ;x bit will be cleared when
 4503:     FB4A 84 BF                          ANDA #$BF         ;   rti is executed below
 4504:     FB4C 97 7B                          STAA REGS+8
 4505:     FB4E C6 57                          LDAB #87        ;cycles to end of rti
 4506:     FB50 DE 0E                          LDX  TCNT
 4507:     FB52 3A                             ABX             ;                        3~ \
 4508:     FB53 DF 1E                          STX  TOC5       ;oc5 match register      5~  \
 4509:     FB55 96 20                          LDAA TCTL1      ;                        4~   \
 4510:     FB57 84 FE                          ANDA #$FE       ;set up oc5 low on match 2~    \
 4511:     FB59 97 20                          STAA TCTL1      ;enable oc5 interrupt    4~    / 86~
 4512:                                 
 4513:                                 ** RESTACK - Restore user stack and RTI to user code.
 4514:                                 * This code is the pathway to execution of user code.
 4515:                                 *(Force extended addressing to maintain cycle count)
 4516:                                 *Restore user stack and rti to user code
 4517:          =0000FB5B              RESTACK EQU  *                                 ;68~
 4518:     FB5B BF 00C5                        STS  >PTR2      ;save monitor sp
 4519:     FB5E BE 007C                        LDS  >SP        ;user stack pointer
 4520:     FB61 FE 0073                        LDX  >REGS
 4521:     FB64 3C                             PSHX            ;pc
 4522:     FB65 FE 0075                        LDX  >REGS+2
 4523:     FB68 3C                             PSHX            ;y
 4524:     FB69 FE 0077                        LDX  >REGS+4
 4525:     FB6C 3C                             PSHX            ;x
 4526:     FB6D FC 0079                        LDD  >REGS+6
 4527:     FB70 36                             PSHA            ;a
 4528:     FB71 37                             PSHB            ;b
 4529:     FB72 B6 007B                        LDAA >REGS+8
 4530:     FB75 36                             PSHA            ;ccr
 4531:     FB76 3B                             RTI
 4532:                                 
 4533:                                 ** Return here from run one line of user code.
 4534:          =0000FB77              XIRQIN  EQU  *
 4535:     FB77 30                             TSX             ;user sp -> x
 4536:     FB78 9E C5                          LDS  PTR2       ;restore monitor sp
 4537:                                 
 4538:                                 ** SAVSTACK - Save user's registers.
 4539:                                 * On entry - x points to top of user stack.
 4540:          =0000FB7A              SAVSTACK EQU *
 4541:     FB7A A6 00                          LDAA 0,X
 4542:     FB7C 97 7B                          STAA REGS+8      ;user ccr
 4543:     FB7E EC 01                          LDD  1,X
 4544:     FB80 97 7A                          STAA REGS+7      ;b
 4545:     FB82 D7 79                          STAB REGS+6      ;a
 4546:     FB84 EC 03                          LDD  3,X
 4547:     FB86 DD 77                          STD  REGS+4      ;x
 4548:     FB88 EC 05                          LDD  5,X
 4549:     FB8A DD 75                          STD  REGS+2      ;y
 4550:     FB8C EC 07                          LDD  7,X
 4551:     FB8E DD 73                          STD  REGS        ;pc
 4552:     FB90 C6 08                          LDAB #8
 4553:     FB92 3A                             ABX
 4554:     FB93 DF 7C                          STX  SP          ;user stack pointer
 4555:     FB95 96 20                          LDAA TCTL1       ;force oc5 pin high which
 4556:     FB97 8A 03                          ORAA #$03        ;  is tied to xirq line
 4557:     FB99 97 20                          STAA TCTL1
 4558:     FB9B 86 08                          LDAA #$08
 4559:     FB9D 97 0B                          STAA CFORC
 4560:     FB9F 39                             RTS
 4561:                                 
 4562:                                 
 4563:                                 **********
 4564:                                 *   HOST() - Establishes transparent link between
 4565:                                 *       terminal and host.  Port used for host is
 4566:                                 *       determined in the reset initialization routine
 4567:                                 *       and stored in HOSTDEV.
 4568:                                 *          To exit type control A.
 4569:                                 *          To send break to host type control B.
 4570:                                 *if(no external device) return;
 4571:                                 *initialize host port;
 4572:                                 *While( !(control A))
 4573:                                 *     input(terminal); output(host);
 4574:                                 *     input(host); output(terminal);
 4575:                                 
 4576:     FBA0 96 B9                  HOST      LDAA EXTDEV
 4577:     FBA2 26 07                            BNE  HOST0    ;jump if host port avail.
 4578:     FBA4 CE E6D8                          LDX  #MSG10   ;"no host port avail"
 4579:     FBA7 BD E538                          JSR  OUTSTRG
 4580:     FBAA 39                               RTS
 4581:     FBAB 7F 00B7                HOST0     CLR  AUTOLF    ;turn off autolf
 4582:     FBAE BD E33D                          JSR  HOSTCO    ;connect sci (evb board)
 4583:     FBB1 BD FC10                          JSR  HOSTINIT  ;initialize host port
 4584:     FBB4 BD E3A0                HOST1     JSR  INPUT     ;read terminal
 4585:     FBB7 4D                               TSTA
 4586:     FBB8 27 10                            BEQ  HOST3     ;jump if no char
 4587:     FBBA 81 01                            CMPA #CTLA
 4588:     FBBC 27 17                            BEQ  HOSTEND   ;jump if control a
 4589:     FBBE 81 02                            CMPA #CTLB
 4590:     FBC0 26 05                            BNE  HOST2     ;jump if not control b
 4591:     FBC2 BD FBDC                          JSR  TXBREAK   ;send break to host
 4592:     FBC5 20 03                            BRA  HOST3
 4593:     FBC7 BD FC28                HOST2     JSR  HOSTOUT   ;echo to host
 4594:     FBCA BD FC1C                HOST3     JSR  HOSTIN    ;read host
 4595:     FBCD 4D                               TSTA
 4596:     FBCE 27 E4                            BEQ  HOST1     ;jump if no char
 4597:     FBD0 BD E3F0                          JSR  OUTPUT    ;echo to terminal
 4598:     FBD3 20 DF                            BRA  HOST1
 4599:     FBD5 7C 00B7                HOSTEND   INC  AUTOLF    ;turn on autolf
 4600:     FBD8 BD E345                          JSR  TARGCO    ;disconnect sci (evb board)
 4601:     FBDB 39                               RTS            ;return
 4602:                                 
 4603:                                 **********
 4604:                                 * txbreak() - transmit break to host port.
 4605:                                 * The duration of the transmitted break is
 4606:                                 * approximately 200,000 E-clock cycles, or
 4607:                                 * 100ms at 2.0 MHz.
 4608:                                 ***********
 4609:          =0000FBDC              TXBREAK   EQU  *
 4610:     FBDC 96 BA                            LDAA HOSTDEV
 4611:     FBDE 81 03                            CMPA #$03
 4612:     FBE0 27 0D                            BEQ  TXBDU    ;jump if duartb is host
 4613:                                 
 4614:     FBE2 CE 002D                TXBSCI    LDX  #SCCR2   ;sci is host
 4615:     FBE5 1C 00 01                         BSET 0,X,#01  ;set send break bit
 4616:     FBE8 8D 1D                            BSR  TXBWAIT
 4617:     FBEA 1D 00 01                         BCLR 0,X,#01  ;clear send break bit
 4618:     FBED 20 0D                            BRA TXB1
 4619:                                 
 4620:     FBEF CE D008                TXBDU     LDX  #PORTB   ;duart host port
 4621:     FBF2 86 60                            LDAA #$60     ;start break cmd
 4622:     FBF4 A7 02                            STAA 2,X      ;port b command register
 4623:     FBF6 8D 0F                            BSR  TXBWAIT
 4624:     FBF8 86 70                            LDAA #$70     ;stop break cmd
 4625:     FBFA A7 02                            STAA 2,X      ;port b command register
 4626:                                 
 4627:     FBFC 86 0D                  TXB1      LDAA #$0D
 4628:     FBFE BD FC28                          JSR  HOSTOUT  ;send carriage return
 4629:     FC01 86 0A                            LDAA #$0A
 4630:     FC03 BD FC28                          JSR  HOSTOUT  ;send linefeed
 4631:     FC06 39                               RTS
 4632:                                 
 4633:     FC07 18CE 6F9B              TXBWAIT   LDY  #$6F9B   ;loop count = 28571
 4634:     FC0B 1809                   TXBWAIT1  DEY           ;7 cycle loop
 4635:     FC0D 26 FC                            BNE  TXBWAIT1
 4636:     FC0F 39                               RTS
 4637:                                 
 4638:                                 
 4639:                                 **********
 4640:                                 *   hostinit(), hostin(), hostout() - host i/o
 4641:                                 *routines.  Restores original terminal device.
 4642:                                 **********
 4643:     FC10 D6 B8                  HOSTINIT  LDAB IODEV    ;save terminal
 4644:     FC12 37                               PSHB
 4645:     FC13 D6 BA                            LDAB HOSTDEV
 4646:     FC15 D7 B8                            STAB IODEV    ;point to host
 4647:     FC17 BD E36E                          JSR  INIT     ;initialize host
 4648:     FC1A 20 16                            BRA  TERMRES  ;restore terminal
 4649:     FC1C D6 B8                  HOSTIN    LDAB IODEV    ;save terminal
 4650:     FC1E 37                               PSHB
 4651:     FC1F D6 BA                            LDAB HOSTDEV
 4652:     FC21 D7 B8                            STAB IODEV    ;point to host
 4653:     FC23 BD E3A0                          JSR  INPUT    ;read host
 4654:     FC26 20 0A                            BRA  TERMRES  ;restore terminal
 4655:     FC28 D6 B8                  HOSTOUT   LDAB IODEV    ;save terminal
 4656:     FC2A 37                               PSHB
 4657:     FC2B D6 BA                            LDAB HOSTDEV
 4658:     FC2D D7 B8                            STAB IODEV    ;point to host
 4659:     FC2F BD E3F0                          JSR  OUTPUT   ;write to host
 4660:     FC32 33                     TERMRES   PULB          ;restore terminal device
 4661:     FC33 D7 B8                            STAB IODEV
 4662:     FC35 39                               RTS
 4663:                                 
 4664:                                 
 4665:                                 **********
 4666:                                 *   load(ptrbuff[]) - Load s1/s9 records from
 4667:                                 *host to memory.  Ptrbuff[] points to string in
 4668:                                 *input buffer which is a command to output s1/s9
 4669:                                 *records from the host ("cat filename" for unix).
 4670:                                 *    Returns error and address if it can't write
 4671:                                 *to a particular location.
 4672:                                 **********
 4673:                                 *   verify(ptrbuff[]) - Verify memory from load
 4674:                                 *command.  Ptrbuff[] is same as for load.
 4675:                                 * tmp3 is used as an error indication, 0=no errors,
 4676:                                 * 1=receiver, 2=rom error, 3=checksum error.
 4677:                                 **********
 4678:     FC36 7F 00D4                VERIFY    CLR  TMP2
 4679:     FC39 7C 00D4                          INC  TMP2      ;TMP2=1=verify
 4680:     FC3C 20 03                            BRA  LOAD1
 4681:     FC3E 7F 00D4                LOAD      CLR  TMP2       ;    0=load
 4682:                                 
 4683:                                 *a=wskip();
 4684:                                 *if(a = cr) goto transparent mode;
 4685:                                 *if(t option) hostdev = iodev;
 4686:          =0000FC41              LOAD1     EQU  *
 4687:     FC41 7F 00D5                          CLR  TMP3      ;clear error flag
 4688:     FC44 BD E2FC                          JSR  WSKIP
 4689:     FC47 26 03                            BNE  LOAD2
 4690:     FC49 7E FBA0                          JMP  HOST      ;go to host if no args
 4691:     FC4C BD E1A7                LOAD2     JSR  UPCASE
 4692:     FC4F 81 54                            CMPA #'T'      ;look for t option
 4693:     FC51 26 16                            BNE  LOAD3     ;jump not t option
 4694:     FC53 BD E2EE                          JSR  INCBUFF
 4695:     FC56 BD E2E7                          JSR  READBUFF  ;get next character
 4696:     FC59 BD E2F4                          JSR  DECBUFF
 4697:     FC5C 81 0D                            CMPA #$0D
 4698:     FC5E 26 09                            BNE  LOAD3     ;jump if not t option
 4699:     FC60 7F 00B7                          CLR  AUTOLF
 4700:     FC63 96 B8                            LDAA IODEV
 4701:     FC65 97 BA                            STAA HOSTDEV   ;set host port = terminal
 4702:     FC67 20 1B                            BRA  LOAD10    ;go wait for s1 records
 4703:                                 
 4704:                                 *else while(not cr)
 4705:                                 *     read character from input buffer;
 4706:                                 *     send character to host;
 4707:     FC69 7F 00B7                LOAD3     CLR  AUTOLF
 4708:     FC6C BD E33D                          JSR  HOSTCO    ;connect sci (evb board)
 4709:     FC6F BD FC10                          JSR  HOSTINIT  ;initialize host port
 4710:     FC72 BD E2E7                LOAD4     JSR  READBUFF  ;get next char
 4711:     FC75 BD E2EE                          JSR  INCBUFF
 4712:     FC78 36                               PSHA           ;save char
 4713:     FC79 BD FC28                          JSR  HOSTOUT   ;output to host
 4714:     FC7C BD E3F0                          JSR  OUTPUT    ;echo to terminal
 4715:     FC7F 32                               PULA
 4716:     FC80 81 0D                            CMPA #$0D
 4717:     FC82 26 EE                            BNE  LOAD4     ;jump if not cr
 4718:                                 
 4719:                                 *repeat:                           /* look for s records */
 4720:                                 *      if(hostdev != iodev) check abort;
 4721:                                 *      a = hostin();
 4722:                                 *      if(a = 'S')
 4723:                                 *          a = hostin;
 4724:                                 *          if(a = '1')
 4725:                                 *              checksum = 0;
 4726:                                 *              get byte count in b;
 4727:                                 *              get base address in x;
 4728:                                 *              while(byte count > 0)
 4729:                                 *                  byte();
 4730:                                 *                  x++; b--;
 4731:                                 *                  if(tmp3=0)           /* no error */
 4732:                                 *                      if(load) x[0] = shftreg+1;
 4733:                                 *                      if(x[0] != shftreg+1)
 4734:                                 *                          tmp3 = 2;    /* rom error */
 4735:                                 *                          ptr3 = x;    /* save address */
 4736:                                 *              if(tmp3 = 0) do checksum;
 4737:                                 *              if(checksum err) tmp3 = 3; /* checksum error */
 4738:                                 ** Look for s-record header
 4739:          =0000FC84              LOAD10    EQU  *
 4740:     FC84 96 BA                            LDAA HOSTDEV
 4741:     FC86 91 B8                            CMPA IODEV
 4742:     FC88 27 03                            BEQ  LOAD11    ;jump if hostdev=iodev
 4743:     FC8A BD E31F                          JSR  CHKABRT   ;check for abort
 4744:     FC8D BD FC1C                LOAD11    JSR  HOSTIN    ;read host
 4745:     FC90 4D                               TSTA
 4746:     FC91 27 F1                            BEQ  LOAD10    ;jump if no input
 4747:     FC93 81 53                            CMPA #'S'
 4748:     FC95 26 ED                            BNE  LOAD10    ;jump if not S
 4749:     FC97 BD FC1C                LOAD12    JSR  HOSTIN    ;read host
 4750:     FC9A 4D                               TSTA
 4751:     FC9B 27 FA                            BEQ  LOAD12    ;jump if no input
 4752:     FC9D 81 39                            CMPA #'9'
 4753:     FC9F 27 4E                            BEQ  LOAD90    ;jump if S9 record
 4754:     FCA1 81 31                            CMPA #'1'
 4755:     FCA3 26 DF                            BNE  LOAD10    ;jump if not S1
 4756:     FCA5 7F 00D6                          CLR  TMP4      ;clear checksum
 4757:                                 ** Get Byte Count and Starting Address
 4758:     FCA8 BD FD35                          JSR  BYTE
 4759:     FCAB D6 AA                            LDAB SHFTREG+1
 4760:     FCAD C0 02                            SUBB #$2       ;b = byte count
 4761:     FCAF BD FD35                          JSR  BYTE
 4762:     FCB2 BD FD35                          JSR  BYTE
 4763:     FCB5 37                               PSHB           ;save byte count
 4764:     FCB6 DC A9                            LDD  SHFTREG
 4765:     FCB8 D3 BF                            ADDD LDOFFST   ;add offset
 4766:     FCBA 8F                               XGDX           ;x = address+offset
 4767:     FCBB 33                               PULB           ;restore byte count
 4768:     FCBC 09                               DEX            ;condition for loop
 4769:                                 ** Get and Store Incoming Data Byte
 4770:     FCBD BD FD35                LOAD20    JSR  BYTE      ;get next byte
 4771:     FCC0 08                               INX
 4772:     FCC1 5A                               DECB           ;check byte count
 4773:     FCC2 27 1B                            BEQ  LOAD30    ;if b=0, go do checksum
 4774:     FCC4 7D 00D5                          TST  TMP3
 4775:     FCC7 26 BB                            BNE  LOAD10    ;jump if error flagged
 4776:     FCC9 7D 00D4                          TST  TMP2
 4777:     FCCC 26 05                            BNE  LOAD21    ;jump if verify
 4778:     FCCE 96 AA                            LDAA SHFTREG+1
 4779:     FCD0 BD E28A                          JSR  WRITE     ;load only
 4780:     FCD3 A1 00                  LOAD21    CMPA 0,X       ;verify ram location
 4781:     FCD5 27 E6                            BEQ  LOAD20    ;jump if ram ok
 4782:     FCD7 86 02                            LDAA #$02
 4783:     FCD9 97 D5                            STAA TMP3      ;indicate rom error
 4784:     FCDB DF C7                            STX  PTR3      ;save error address
 4785:     FCDD 20 DE                            BRA  LOAD20    ;finish download
 4786:                                 ** Get and Test Checksum
 4787:     FCDF 7D 00D5                LOAD30    TST  TMP3
 4788:     FCE2 26 A0                            BNE  LOAD10    ;jump if error already
 4789:     FCE4 96 D6                            LDAA TMP4
 4790:     FCE6 4C                               INCA           ;do checksum
 4791:     FCE7 27 9B                            BEQ  LOAD10    ;jump if s1 record okay
 4792:     FCE9 86 03                            LDAA #$03
 4793:     FCEB 97 D5                            STAA TMP3      ;indicate checksum error
 4794:     FCED 20 95                            BRA  LOAD10
 4795:                                 
 4796:                                 *          if(a = '9')
 4797:                                 *              read rest of record;
 4798:                                 *              if(tmp3=2) return("[ptr3]");
 4799:                                 *              if(tmp3=1) return("rcv error");
 4800:                                 *              if(tmp3=3) return("checksum err");
 4801:                                 *              else return("done");
 4802:     FCEF BD FD35                LOAD90    JSR  BYTE
 4803:     FCF2 D6 AA                            LDAB SHFTREG+1 ;b = byte count
 4804:     FCF4 BD FD35                LOAD91    JSR  BYTE
 4805:     FCF7 5A                               DECB
 4806:     FCF8 26 FA                            BNE  LOAD91    ;loop until end of record
 4807:     FCFA C6 64                            LDAB #$64
 4808:     FCFC BD E2DB                LOAD91A   JSR  DLY10MS   ;delay 1 sec -let host finish
 4809:     FCFF 5A                               DECB
 4810:     FD00 26 FA                            BNE  LOAD91A
 4811:     FD02 BD E3A0                          JSR  INPUT     ;clear comm device
 4812:     FD05 CC 7E0D                          LDD  #$7E0D    ;put dummy command in inbuff
 4813:     FD08 DD 7E                            STD  INBUFF
 4814:     FD0A 7C 00B7                          INC  AUTOLF    ;turn on autolf
 4815:     FD0D BD E345                          JSR  TARGCO    ;disconnect sci (evb)
 4816:     FD10 CE E6E5                          LDX  #MSG11    ;"done" default msg
 4817:     FD13 96 D5                            LDAA TMP3
 4818:     FD15 81 02                            CMPA #$02
 4819:     FD17 26 08                            BNE  LOAD92    ;jump not rom error
 4820:     FD19 CE 00C7                          LDX  #PTR3
 4821:     FD1C BD E519                          JSR  OUT2BSP   ;address of rom error
 4822:     FD1F 20 13                            BRA  LOAD95
 4823:     FD21 81 01                  LOAD92    CMPA #$01
 4824:     FD23 26 05                            BNE  LOAD93    ;jump not rcv error
 4825:     FD25 CE E703                          LDX  #MSG14    ;"rcv error"
 4826:     FD28 20 07                            BRA  LOAD94
 4827:     FD2A 81 03                  LOAD93    CMPA #$03
 4828:     FD2C 26 03                            BNE  LOAD94    ;jump not checksum error
 4829:     FD2E CE E6EA                          LDX  #MSG12    ;"checksum error"
 4830:     FD31 BD E538                LOAD94    JSR  OUTSTRG
 4831:     FD34 39                     LOAD95    RTS
 4832:                                 
 4833:                                 
 4834:                                 **********
 4835:                                 *  byte() -  Read 2 ascii bytes from host and
 4836:                                 *convert to one hex byte.  Returns byte
 4837:                                 *shifted into shftreg and added to tmp4.
 4838:                                 **********
 4839:     FD35 37                     BYTE      PSHB
 4840:     FD36 3C                               PSHX
 4841:     FD37 BD FC1C                BYTE0     JSR  HOSTIN    ;read host (1st byte)
 4842:     FD3A 4D                               TSTA
 4843:     FD3B 27 FA                            BEQ  BYTE0     ;loop until input
 4844:     FD3D BD E201                          JSR  HEXBIN
 4845:     FD40 BD FC1C                BYTE1     JSR  HOSTIN    ;read host (2nd byte)
 4846:     FD43 4D                               TSTA
 4847:     FD44 27 FA                            BEQ  BYTE1     ;loop until input
 4848:     FD46 BD E201                          JSR  HEXBIN
 4849:     FD49 96 AA                            LDAA SHFTREG+1
 4850:     FD4B 9B D6                            ADDA TMP4
 4851:     FD4D 97 D6                            STAA TMP4      ;add to checksum
 4852:     FD4F 38                               PULX
 4853:     FD50 33                               PULB
 4854:     FD51 39                               RTS
 4855:                                 
 4856:                                 
 4857:                                 **********
 4858:                                 *   offset [<addr>]
 4859:                                 * Specify offset to be added to s-record address when
 4860:                                 * downloading from the host.
 4861:                                 *  OFFSET                -show the current offset
 4862:                                 *  OFFSET <data>         -current offset = data
 4863:                                 *  OFFSET -<data>        -current offset = 0 - data
 4864:                                 **********
 4865:                                 *if(<data>) then offset = data;
 4866:                                 *print(offset);
 4867:          =0000FD52              OFFSET   EQU  *
 4868:     FD52 7F 00D6                         CLR  TMP4      ;minus indicator
 4869:     FD55 BD E2FC                         JSR  WSKIP
 4870:     FD58 27 28                           BEQ  OFFST3    ;jump if cr (no argument)
 4871:     FD5A 81 2D                           CMPA #'-'
 4872:     FD5C 26 09                           BNE  OFFST1    ;jump not -
 4873:     FD5E 7C 00D6                         INC  TMP4      ;set minus sign flag
 4874:     FD61 BD E2EE                         JSR  INCBUFF   ;move buffer pointer
 4875:     FD64 BD E2FC                         JSR  WSKIP
 4876:     FD67 BD E234                OFFST1   JSR  BUFFARG   ;read argument
 4877:     FD6A 7D 00BB                         TST  COUNT
 4878:     FD6D 27 1D                           BEQ  OFFSTER  ;jump if bad argument
 4879:     FD6F BD E2FC                         JSR  WSKIP
 4880:     FD72 26 18                           BNE  OFFSTER   ;jump if not cr
 4881:     FD74 DC A9                           LDD  SHFTREG   ;get offset value
 4882:     FD76 7D 00D6                         TST  TMP4
 4883:     FD79 27 05                           BEQ  OFFST2    ;jump if positive
 4884:     FD7B CC 0000                         LDD  #$0000    ;negative - sub from 0
 4885:     FD7E 93 A9                           SUBD SHFTREG
 4886:     FD80 DD BF                  OFFST2   STD  LDOFFST
 4887:     FD82 BD E531                OFFST3   JSR  OUTCRLF   ;display current offset
 4888:     FD85 CE 00BF                         LDX  #LDOFFST
 4889:     FD88 BD E519                         JSR  OUT2BSP
 4890:     FD8B 39                              RTS
 4891:                                 
 4892:     FD8C CE E6CB                OFFSTER  LDX  #MSG9     ;"bad argument"
 4893:     FD8F BD E538                         JSR  OUTSTRG
 4894:     FD92 39                              RTS
 4895:                                 
 4896:                                 
 4897:                                 
 4898:                                 
 4899:                                 
 4900:                                 **********
 4901:                                 *   register [<name>]  - prints the user regs
 4902:                                 *and opens them for modification.  <name> is
 4903:                                 *the first register opened (default = P).
 4904:                                 *   Subcommands:
 4905:                                 * [<nn>]<space>  Opens the next register.
 4906:                                 * [<nn>]<cr>     Return.
 4907:                                 *    The register value is only changed if
 4908:                                 *    <nn> is entered before the subcommand.
 4909:                                 **********
 4910:                                 *x[] = reglist
 4911:                                 *a = wskip(); a = upcase(a);
 4912:                                 *if(a != cr)
 4913:                                 *     while( a != x[0] )
 4914:                                 *          if( x[0] = "s") return(bad argument);
 4915:                                 *          x[]++;
 4916:                                 *     incbuff(); a = wskip();
 4917:                                 *     if(a != cr) return(bad argument);
 4918:                                 
 4919:     FD93 CE E1BE                REGISTER LDX  #REGLIST
 4920:     FD96 BD E2FC                         JSR  WSKIP      ; a = first char of arg
 4921:     FD99 BD E1A7                         JSR  UPCASE      ;convert to upper case
 4922:     FD9C 81 0D                           CMPA #$D
 4923:     FD9E 27 1C                           BEQ  REG4        ;jump if no argument
 4924:     FDA0 A1 00                  REG1     CMPA 0,X
 4925:     FDA2 27 0E                           BEQ  REG3
 4926:     FDA4 E6 00                           LDAB 0,X
 4927:     FDA6 08                              INX
 4928:     FDA7 C1 53                           CMPB #'S'
 4929:     FDA9 26 F5                           BNE  REG1        ;jump if not "s"
 4930:     FDAB CE E6CB                REG2     LDX  #MSG9       ;"bad argument"
 4931:     FDAE BD E538                         JSR  OUTSTRG
 4932:     FDB1 39                              RTS
 4933:     FDB2 3C                     REG3     PSHX
 4934:     FDB3 BD E2EE                         JSR  INCBUFF
 4935:     FDB6 BD E2FC                         JSR  WSKIP       ;next char after arg
 4936:     FDB9 38                              PULX
 4937:     FDBA 26 EF                           BNE  REG2        ;jump if not cr
 4938:                                 
 4939:                                 *rprint();
 4940:                                 *     while(x[0] != "s")
 4941:                                 *          rprnt1(x);
 4942:                                 *          a = termarg();    /* read from terminal */
 4943:                                 *          if( ! dchek(a) ) return(bad argument);
 4944:                                 *          if(countu1 != 0)
 4945:                                 *               if(x[14] = 1)
 4946:                                 *                    regs[x[7]++ = shftreg;
 4947:                                 *               regs[x[7]] = shftreg+1;
 4948:                                 *          if(a = cr) break;
 4949:                                 *return;
 4950:                                 
 4951:     FDBC BD E1F3                REG4     JSR  RPRINT      ;print all registers
 4952:     FDBF BD E531                REG5     JSR  OUTCRLF
 4953:     FDC2 BD E1D3                         JSR  RPRNT1      ;print reg name
 4954:     FDC5 7F 00A9                         CLR  SHFTREG
 4955:     FDC8 7F 00AA                         CLR  SHFTREG+1
 4956:     FDCB BD E257                         JSR  TERMARG     ;read subcommand
 4957:     FDCE BD E317                         JSR  DCHEK
 4958:     FDD1 27 07                           BEQ  REG6        ;jump if delimeter
 4959:     FDD3 CE E6CB                         LDX  #MSG9       ;"bad argument"
 4960:     FDD6 BD E538                         JSR  OUTSTRG
 4961:     FDD9 39                              RTS
 4962:     FDDA 36                     REG6     PSHA
 4963:     FDDB 3C                              PSHX
 4964:     FDDC 7D 00BB                         TST  COUNT
 4965:     FDDF 27 14                           BEQ  REG8        ;jump if no input
 4966:     FDE1 E6 07                           LDAB 7,X         ;get reg offset
 4967:     FDE3 A6 0E                           LDAA 14,X        ;byte size
 4968:     FDE5 CE 0073                         LDX  #REGS       ;user registers
 4969:     FDE8 3A                              ABX
 4970:     FDE9 4D                              TSTA
 4971:     FDEA 27 05                           BEQ  REG7        ;jump if 1 byte reg
 4972:     FDEC 96 A9                           LDAA SHFTREG
 4973:     FDEE A7 00                           STAA 0,X         ;put in top byte
 4974:     FDF0 08                              INX
 4975:     FDF1 96 AA                  REG7     LDAA SHFTREG+1
 4976:     FDF3 A7 00                           STAA 0,X         ;put in bottom byte
 4977:     FDF5 38                     REG8     PULX
 4978:     FDF6 32                              PULA
 4979:     FDF7 E6 00                           LDAB 0,X         ;CHECK FOR REGISTER S
 4980:     FDF9 C1 53                           CMPB #'S'
 4981:     FDFB 27 05                           BEQ  REG9        ;jump if "s"
 4982:     FDFD 08                              INX              ;point to next register
 4983:     FDFE 81 0D                           CMPA #$D
 4984:     FE00 26 BD                           BNE  REG5        ;jump if not cr
 4985:     FE02 39                     REG9     RTS
 4986:                                 
 4987:                                 
 4988:                                 * Equates
 4989:          =00000008              JPORTD  EQU   $08
 4990:          =00000009              JDDRD   EQU   $09
 4991:          =0000002B              JBAUD   EQU   $2B
 4992:          =0000002C              JSCCR1  EQU   $2C
 4993:          =0000002D              JSCCR2  EQU   $2D
 4994:          =0000002E              JSCSR   EQU   $2E
 4995:          =0000002F              JSCDAT  EQU   $2F
 4996:                                 *
 4997:                                 
 4998:                                 ************
 4999:                                 *  xboot [<addr1> [<addr2>]] - Use SCI to talk to an 'hc11 in
 5000:                                 * boot mode.  Downloads bytes from addr1 thru addr2.
 5001:                                 * Default addr1 = $C000 and addr2 = $C0ff.
 5002:                                 *
 5003:                                 * IMPORTANT:
 5004:                                 * if talking to an 'A8 or 'A2: use either default addresses or ONLY
 5005:                                 *    addr1 - this sends 256 bytes
 5006:                                 * if talking to an 'E9: include BOTH addr1 and addr2 for variable
 5007:                                 *    length
 5008:                                 ************
 5009:                                 
 5010:                                 *Get arguments
 5011:                                 *If no args, default $C000
 5012:     FE03 BD E2FC                BOOT    JSR   WSKIP
 5013:     FE06 26 0B                          BNE   BOT1       ;jump if arguments
 5014:     FE08 CE C0FF                        LDX   #$C0FF     ;addr2 default
 5015:     FE0B DF CB                          STX   PTR5
 5016:     FE0D 18CE C000                      LDY   #$C000     ;addr1 default
 5017:     FE11 20 36                          BRA   BOT2       ;go - use default address
 5018:                                 
 5019:                                 *Else get arguments
 5020:     FE13 BD E234                BOT1    JSR   BUFFARG
 5021:     FE16 7D 00BB                        TST   COUNT
 5022:     FE19 27 27                          BEQ   BOTERR    ;jump if no address
 5023:     FE1B 18DE A9                        LDY   SHFTREG   ;start address (addr1)
 5024:     FE1E BD E2FC                        JSR   WSKIP
 5025:     FE21 26 0C                          BNE   BOT1A     ;go get addr2
 5026:     FE23 18DF CB                        STY   PTR5      ;default addr2...
 5027:     FE26 DC CB                          LDD   PTR5      ;...by taking addr1...
 5028:     FE28 C3 00FF                        ADDD  #$FF      ;...and adding 255 to it...
 5029:     FE2B DD CB                          STD   PTR5      ;...for a total download of 256
 5030:     FE2D 20 1A                          BRA   BOT2      ;continue
 5031:                                 *
 5032:     FE2F BD E234                BOT1A   JSR   BUFFARG
 5033:     FE32 7D 00BB                        TST   COUNT
 5034:     FE35 27 0B                          BEQ   BOTERR    ;jump if no address
 5035:     FE37 DE A9                          LDX   SHFTREG   ;end address (addr2)
 5036:     FE39 DF CB                          STX   PTR5
 5037:     FE3B BD E2FC                        JSR   WSKIP
 5038:     FE3E 26 02                          BNE   BOTERR    ;go use addr1 and addr2
 5039:     FE40 20 07                          BRA   BOT2
 5040:                                 
 5041:                                 *
 5042:     FE42 CE E6CB                BOTERR  LDX   #MSG9     ;"bad argument"
 5043:     FE45 BD E538                        JSR   OUTSTRG
 5044:     FE48 39                             RTS
 5045:                                 
 5046:                                 *Boot routine
 5047:     FE49 C6 FF                  BOT2    LDAB  #$FF       ;control character ($ff -> download)
 5048:     FE4B BD FE61                        JSR   BTSUB      ;set up SCI and send control char
 5049:                                 *                        initializes X as register pointer
 5050:                                 *Download block
 5051:     FE4E 18A6 00                BLOP    LDAA  0,Y
 5052:     FE51 A7 2F                          STAA  JSCDAT,X   ;write to transmitter
 5053:     FE53 1F 2E 50 FC                    BRCLR JSCSR,X,#80,*      ;wait for TDRE
 5054:     FE57 189C CB                        CPY   PTR5       ;if last...
 5055:     FE5A 27 04                          BEQ   BTDONE      ;    ...quit
 5056:     FE5C 1808                           INY              ;else...
 5057:     FE5E 20 EE                          BRA   BLOP        ;    ...send next
 5058:     FE60 39                     BTDONE  RTS
 5059:                                 
 5060:                                 ************************************************
 5061:                                 *Subroutine
 5062:                                 *  btsub   - sets up SCI and outputs control character
 5063:                                 * On entry, B = control character
 5064:                                 * On exit,  X = $1000
 5065:                                 *           A = $0C
 5066:                                 ***************************
 5067:                                 
 5068:          =0000FE61              BTSUB   EQU   *
 5069:     FE61 CE 1000                        LDX   #$1000    ;to use indexed addressing
 5070:     FE64 86 02                          LDAA  #$02
 5071:     FE66 A7 08                          STAA  JPORTD,X  ;drive transmitter line
 5072:     FE68 A7 09                          STAA  JDDRD,X   ;  high
 5073:     FE6A 6F 2D                          CLR   JSCCR2,X  ;turn off XMTR and RCVR
 5074:     FE6C 86 22                          LDAA  #$22      ;BAUD = /16
 5075:     FE6E A7 2B                          STAA  JBAUD,X
 5076:     FE70 86 0C                          LDAA  #$0C      ;TURN ON XMTR & RCVR
 5077:     FE72 A7 2D                          STAA  JSCCR2,X
 5078:     FE74 E7 2F                          STAB  JSCDAT,X
 5079:     FE76 1F 2E 50 FC                    BRCLR JSCSR,X,#80,*   ;wait for TDRE
 5080:     FE7A 39                             RTS
 5081:                                 
 5082:                                 
 5083:                                 ***********
 5084:                                 * TILDE - This command is put into the combuff by the
 5085:                                 * load command so that extraneous carriage returns after
 5086:                                 * the load will not hang up.
 5087:     FE7B 39                     TILDE   RTS
 5088:                                 
 5089:                                 ******************
 5090:                                 *
 5091:                                 *       EVBTEST - This routine makes it a little easier
 5092:                                 *       on us to test this board.
 5093:                                 *
 5094:                                 ******************
 5095:                                 
 5096:     FE7C 86 FF                  EVBTEST  LDAA  #$FF
 5097:     FE7E B7 1000                         STAA  $1000    ;Write ones to port A
 5098:     FE81 7F 00B7                         CLR  AUTOLF    ;Turn off auto lf
 5099:     FE84 BD E33D                         JSR  HOSTCO    ;Connect host
 5100:     FE87 BD FC10                         JSR  HOSTINIT  ;Initialize host
 5101:     FE8A 86 7F                           LDAA #$7f
 5102:     FE8C BD FC28                         JSR  HOSTOUT   ;Send Delete to Altos
 5103:     FE8F 86 0D                           LDAA #$0d
 5104:     FE91 BD FC28                         JSR  HOSTOUT   ;Send <CR>
 5105:     FE94 7C 00B7                         INC  AUTOLF    ;Turn on Auto LF
 5106:     FE97 CE 0083                         LDX  #INBUFF+5 ;Point at Load message
 5107:     FE9A DF C1                           STX  PTR0      ;Set pointer for load command
 5108:     FE9C 18CE FEBA                       LDY  #MSGEVB   ;Point at cat line
 5109:     FEA0 18A6 00                LOOP     LDAA 0,Y       ;Loop to xfer command line
 5110:     FEA3 81 04                           CMPA #04       ;Into buffalo line buffer
 5111:     FEA5 27 07                           BEQ  DONE      ;Quit on $04
 5112:     FEA7 A7 00                           STAA 0,X
 5113:     FEA9 08                              INX            ;next character
 5114:     FEAA 1808                            INY
 5115:     FEAC 20 F2                           BRA  LOOP
 5116:     FEAE 7F 00D4                DONE     CLR  TMP2      ;Set load vs. verify
 5117:     FEB1 BD FC69                         JSR  LOAD3     ;Jmp into middle of load
 5118:     FEB4 8E 0072                         LDS  #STACK    ;Reset Stack
 5119:     FEB7 7E C0B3                         JMP  $C0B3     ;Jump to Downloaded code
 5120:                                 
 5121:     FEBA 63 61 74 20 65 76      MSGEVB   FCC  /cat evbtest.out/
           FEC0 62 74 65 73 74 2E 
           FEC6 6F 75 74 
 5122:     FEC9 0D                              FCB  $0D
 5123:     FECA 04                              FCB  $04
 5124:                                 
 5125:                                 
 5126:                                 
 5127:                                 *** Jump table ***
 5128:          =0000FF7C                      ORG     ROMBS+$1F7C
 5129:     FF7C 7E E0C8                .WARMST JMP     MAIN        ;warm start
 5130:     FF7F 7E E1B2                .BPCLR  JMP     BPCLR       ;clear breakpoint table
 5131:     FF82 7E E1F3                .RPRINT JMP     RPRINT      ;display user registers
 5132:     FF85 7E E201                .HEXBIN JMP     HEXBIN      ;convert ascii hex char to binary
 5133:     FF88 7E E234                .BUFFAR JMP     BUFFARG     ;build hex argument from buffer
 5134:     FF8B 7E E257                .TERMAR JMP     TERMARG     ;read hex argument from terminal
 5135:     FF8E 7E E27F                .CHGBYT JMP     CHGBYT      ;modify memory at address in x
 5136:     FF91 7E E2E7                .READBU JMP     READBUFF    ;read character from buffer
 5137:     FF94 7E E2EE                .INCBUF JMP     INCBUFF     ;increment buffer pointer
 5138:     FF97 7E E2F4                .DECBUF JMP     DECBUFF     ;decrement buffer pointer
 5139:     FF9A 7E E2FC                .WSKIP  JMP     WSKIP       ;find non-whitespace char in buffer
 5140:     FF9D 7E E31F                .CHKABR JMP     CHKABRT     ;check for abort from terminal
 5141:                                 
 5142:          =0000FFA0                      ORG     ROMBS+$1FA0
 5143:     FFA0 7E E1A7                .UPCASE JMP     UPCASE      ;convert to upper case
 5144:     FFA3 7E E30C                .WCHEK  JMP     WCHEK       ;check for white space
 5145:     FFA6 7E E317                .DCHEK  JMP     DCHEK       ;check for delimeter
 5146:     FFA9 7E E36E                .INIT   JMP     INIT        ;initialize i/o device
 5147:     FFAC 7E E3A0                .INPUT  JMP     INPUT       ;low level input routine
 5148:     FFAF 7E E3F0                .OUTPUT JMP     OUTPUT      ;low level output routine
 5149:     FFB2 7E E4FB                .OUTLHL JMP     OUTLHLF     ;display top 4 bits as hex digit
 5150:     FFB5 7E E4FF                .OUTRHL JMP     OUTRHLF     ;display bottom 4 bits as hex digit
 5151:     FFB8 7E E509                .OUTA   JMP     OUTA        ;output ascii character in A
 5152:     FFBB 7E E50D                .OUT1BY JMP     OUT1BYT     ;display the hex value of byte at X
 5153:     FFBE 7E E51C                .OUT1BS JMP     OUT1BSP     ;out1byt followed by space
 5154:     FFC1 7E E519                .OUT2BS JMP     OUT2BSP     ;display 2 hex bytes at x and a space
 5155:     FFC4 7E E531                .OUTCRL JMP     OUTCRLF     ;carriage return, line feed to terminal
 5156:     FFC7 7E E538                .OUTSTR JMP     OUTSTRG     ;display string at X (term with $04)
 5157:     FFCA 7E E53B                .OUTST0 JMP     OUTSTRG0    ;outstrg with no initial carr ret
 5158:     FFCD 7E E564                .INCHAR JMP     INCHAR      ;wait for and input a char from term
 5159:     FFD0 7E E34D                .VECINT JMP     VECINIT     ;initialize RAM vector table
 5160:                                 
 5161:          =0000FFD6                       ORG    ROMBS+$1FD6
 5162:                                 *** Vectors ***
 5163:     FFD6 00D7                   VSCI     FDB    JSCI
 5164:     FFD8 00DA                   VSPI     FDB    JSPI
 5165:     FFDA 00DD                   VPAIE    FDB    JPAIE
 5166:     FFDC 00E0                   VPAO     FDB    JPAO
 5167:     FFDE 00E3                   VTOF     FDB    JTOF
 5168:     FFE0 00E6                   VTOC5    FDB    JTOC5
 5169:     FFE2 00E9                   VTOC4    FDB    JTOC4
 5170:     FFE4 00EC                   VTOC3    FDB    JTOC3
 5171:     FFE6 00EF                   VTOC2    FDB    JTOC2
 5172:     FFE8 00F2                   VTOC1    FDB    JTOC1
 5173:     FFEA 00F5                   VTIC3    FDB    JTIC3
 5174:     FFEC 00F8                   VTIC2    FDB    JTIC2
 5175:     FFEE 00FB                   VTIC1    FDB    JTIC1
 5176:     FFF0 00FE                   VRTI     FDB    JRTI
 5177:     FFF2 0101                   VIRQ     FDB    JIRQ
 5178:     FFF4 0104                   VXIRQ    FDB    JXIRQ
 5179:     FFF6 0107                   VSWI     FDB    JSWI
 5180:     FFF8 010A                   VILLOP   FDB    JILLOP
 5181:     FFFA 010D                   VCOP     FDB    JCOP
 5182:     FFFC 0110                   VCLM     FDB    JCLM
 5183:     FFFE E000                   VRST     FDB    BUFFALO
 5184:                                          END
