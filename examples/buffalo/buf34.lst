buf34.lst - generated by MGTEK Assembler ASM11 V1.17 Build 107 for Linux (x86) - Fri Sep  3 10:58:01 2021

    1:                                 *                  BUFFALO
    2:                                 * "Bit User's Fast Friendly Aid to Logical Operation"
    3:                                 *
    4:                                 * Rev 2.0 - 4/23/85 - added disassembler.
    5:                                 *                   - variables now PTRn and TMPn.
    6:                                 * Rev 2.1 - 4/29/85 - added byte erase to chgbyt routine.
    7:                                 * Rev 2.2 - 5/16/85 - added hooks for evb board - acia
    8:                                 *                     drivers, init and host routines.
    9:                                 *           7/8/85  - fixed dump wraparound problem.
   10:                                 *           7/10/85 - added evm board commands.
   11:                                 *                   - added fill instruction.
   12:                                 *           7/18/85 - added jump to EEPROM.
   13:                                 * Rev 2.3 - 8/22/85 - call targco to disconnect sci from host
   14:                                 *                     in reset routine for evb board.
   15:                                 *           10/3/85 - modified load for download through terminal.
   16:                                 * Rev 2.4 - 7/1/86  - Changed DFLOP address to fix conflicts with
   17:                                 *                     EEPROM.  (was at A000)
   18:                                 * Rev 2.5 - 9/8/86  - Modified to provide additional protection from
   19:                                 *                     program run-away on power down.  Also fixed bugs
   20:                                 *                     in MM and MOVE.  Changed to 1 stop bit from 2.
   21:                                 * Rev 2.6 - 9/25/86 - Modified boot routine for variable length download
   22:                                 *                     for use with 'HC11E8.
   23:                                 * Rev 3.0   1/15/87 - EEPROM programming routines consolidated into WRITE.
   24:                                 *                     Fill, Assem, and breakpoints will now do EEPROM.
   25:                                 *                   - Added compare a to $0D to WSKIP routine.
   26:                                 *           2/11/87 - Set up load to detect receiver error.
   27:                                 * Rev 3.2   7/7/87  - Add disassembly to trace.
   28:                                 *                   - Add entries to jump table.
   29:                                 *           9/20/87 - Rewrote trace to use XIRQ, added STOPAT Command
   30:                                 *           11/24/87- Write block protect reg for 'E9 version
   31:                                 *                   - Modified variable length download for use
   32:                                 *                       with 'E9 bootloader (XBOOT command)
   33:                                 * Rev 3.3   3/17/88 - Set I bit to block interrupts on Warm Start and
   34:                                 *                       return from CALL command.
   35:                                 *                   - Added EEMOD Command.
   36:                                 *                   - Rearranged source so that HELP command overlaps
   37:                                 *                       EEPROM in test mode.
   38:                                 *           3/24/88 - Added '+', '-', '=', '.' to MEM and ASM commands.
   39:                                 *                   - Added check for 16 byte boundary to MEM
   40:                                 *                       space sub-command.
   41:                                 *                   - LOAD command now puts dummy (~) command into
   42:                                 *                       inbuff so that any stray cr's won`t hang.
   43:                                 * Rev 3.4   8/15/88 - Changed WRITE subroutine so that config register
   44:                                 *                       gets byte erased before programmed.  The original
   45:                                 *                       value of config is used for EEBYTE so that config
   46:                                 *                       RAM value doesn't get changed in test mode.
   47:                                 *           8/17/88 - Fixed MOVE command so that it doesn't hang when move
   48:                                 *                       is done to a ROM location.
   49:                                 *                   - Added OFFSET command for download offset capability.
   50:                                 *
   51:                                 ****************************************************
   52:                                 *    Although the information contained herein,    *
   53:                                 *    as well as any information provided relative  *
   54:                                 *    thereto, has been carefully reviewed and is   *
   55:                                 *    believed accurate, Motorola assumes no        *
   56:                                 *    liability arising out of its application or   *
   57:                                 *    use, neither does it convey any license under *
   58:                                 *    its patent rights nor the rights of others.   *
   59:                                 ****************************************************
   60:                                 
   61:                                 ***************
   62:                                 *   EQUATES   *
   63:                                 ***************
   64:                                 *Author EQU  Tony Fourcroy
   65:          =00000000              RAMBS   EQU  $0000      ;start of ram
   66:          =00001000              REGBS   EQU  $1000      ;start of registers
   67:          =0000E000              ROMBS   EQU  $E000      ;start of rom
   68:          =0000B600              DSTREE  EQU  $B600      ;start of eeprom
   69:          =0000B7FF              DENDEE  EQU  $B7FF      ;end of eeprom
   70:          =0000100A              PORTE   EQU  REGBS+$0A  ;port e
   71:          =0000100B              CFORC   EQU  REGBS+$0B  ;force output compare
   72:          =0000100E              TCNT    EQU  REGBS+$0E  ;timer count
   73:          =0000101E              TOC5    EQU  REGBS+$1E  ;oc5 reg
   74:          =00001020              TCTL1   EQU  REGBS+$20  ;timer control 1
   75:          =00001022              TMSK1   EQU  REGBS+$22  ;timer mask 1
   76:          =00001023              TFLG1   EQU  REGBS+$23  ;timer flag 1
   77:          =00001024              TMSK2   EQU  REGBS+$24  ;timer mask 2
   78:          =0000102B              BAUD    EQU  REGBS+$2B  ;sci baud reg
   79:          =0000102C              SCCR1   EQU  REGBS+$2C  ;sci control1 reg
   80:          =0000102D              SCCR2   EQU  REGBS+$2D  ;sci control2 reg
   81:          =0000102E              SCSR    EQU  REGBS+$2E  ;sci status reg
   82:          =0000102F              SCDAT   EQU  REGBS+$2F  ;sci data reg
   83:          =00001035              BPROT   EQU  REGBS+$35  ;block protect reg
   84:          =00001039              OPTION  EQU  REGBS+$39  ;option reg
   85:          =0000103A              COPRST  EQU  REGBS+$3A  ;cop reset reg
   86:          =0000103B              PPROG   EQU  REGBS+$3B  ;ee prog reg
   87:          =0000103C              HPRIO   EQU  REGBS+$3C  ;hprio reg
   88:          =0000103F              CONFIG  EQU  REGBS+$3F  ;config register
   89:          =00004000              DFLOP   EQU  $4000      ;evb d flip flop
   90:          =0000D000              DUART   EQU  $D000      ;duart address
   91:          =0000D000              PORTA   EQU  DUART
   92:          =0000D008              PORTB   EQU  DUART+8
   93:          =00009800              ACIA    EQU  $9800      ;acia address
   94:          =0000003E              PROMPT  EQU  '>'
   95:          =00000023              BUFFLNG EQU  35
   96:          =00000001              CTLA    EQU  $01        ;exit host or assembler
   97:          =00000002              CTLB    EQU  $02        ;send break to host
   98:          =00000017              CTLW    EQU  $17        ;wait
   99:          =00000018              CTLX    EQU  $18        ;abort
  100:          =0000007F              DEL     EQU  $7F        ;abort
  101:          =00000004              EOT     EQU  $04        ;end of text/table
  102:          =0000003F              SWI     EQU  $3F
  103:                                 
  104:                                 ***************
  105:                                 *     RAM     *
  106:                                 ***************
  107:          =0000002D                      ORG  $2D
  108:                                 *** Buffalo ram space ***
  109:     002D +0014                          RMB  20    ;user stack area
  110:     0041 +001E                  USTACK  RMB  30    ;monitor stack area
  111:     005F +0001                  STACK   RMB  1
  112:     0060 +0009                  REGS    RMB  9     ;user's pc,y,x,a,b,c
  113:     0069 +0002                  SP      RMB  2     ;user's sp
  114:     006B +0023                  INBUFF  RMB  BUFFLNG    ;input buffer
  115:          =0000008E              ENDBUFF EQU  *
  116:     008E +0008                  COMBUFF RMB  8     ;command buffer
  117:     0096 +0002                  SHFTREG RMB  2     ;input shift register
  118:     0098 +0002                  STREE   RMB  2     ;eeprom start address
  119:     009A +0002                  ENDEE   RMB  2     ;eeprom end address
  120:     009C +0008                  BRKTABL RMB  8     ;breakpoint table
  121:     00A4 +0001                  AUTOLF  RMB  1     ;auto lf flag for i/o
  122:     00A5 +0001                  IODEV   RMB  1     ;0=sci,  1=acia, 2=duartA, 3=duartB
  123:     00A6 +0001                  EXTDEV  RMB  1     ;0=none, 1=acia, 2=duart,
  124:     00A7 +0001                  HOSTDEV RMB  1     ;0=sci,  1=acia,           3=duartB
  125:     00A8 +0001                  COUNT   RMB  1     ;# characters read
  126:     00A9 +0001                  CHRCNT  RMB  1     ;# characters output on current line
  127:     00AA +0002                  PTRMEM  RMB  2     ;current memory location
  128:     00AC +0002                  LDOFFST RMB  2     ;offset for download
  129:                                 
  130:                                 *** Buffalo variables - used by: ***
  131:     00AE +0002                  PTR0    RMB  2     ;main,readbuff,incbuff,AS
  132:     00B0 +0002                  PTR1    RMB  2     ;main,BR,DU,MO,AS,EX
  133:     00B2 +0002                  PTR2    RMB  2     ;EX,DU,MO,AS
  134:     00B4 +0002                  PTR3    RMB  2     ;EX,HO,MO,AS
  135:     00B6 +0002                  PTR4    RMB  2     ;EX,AS
  136:     00B8 +0002                  PTR5    RMB  2     ;EX,AS,BOOT
  137:     00BA +0002                  PTR6    RMB  2     ;EX,AS,BOOT
  138:     00BC +0002                  PTR7    RMB  2     ;EX,AS
  139:     00BE +0002                  PTR8    RMB  2     ;AS
  140:     00C0 +0001                  TMP1    RMB  1     ;main,hexbin,buffarg,termarg
  141:     00C1 +0001                  TMP2    RMB  1     ;GO,HO,AS,LOAD
  142:     00C2 +0001                  TMP3    RMB  1     ;AS,LOAD
  143:     00C3 +0001                  TMP4    RMB  1     ;TR,HO,ME,AS,LOAD
  144:                                 *** Vector jump table ***
  145:     00C4 +0003                  JSCI    RMB   3
  146:     00C7 +0003                  JSPI    RMB   3
  147:     00CA +0003                  JPAIE   RMB   3
  148:     00CD +0003                  JPAO    RMB   3
  149:     00D0 +0003                  JTOF    RMB   3
  150:     00D3 +0003                  JTOC5   RMB   3
  151:     00D6 +0003                  JTOC4   RMB   3
  152:     00D9 +0003                  JTOC3   RMB   3
  153:     00DC +0003                  JTOC2   RMB   3
  154:     00DF +0003                  JTOC1   RMB   3
  155:     00E2 +0003                  JTIC3   RMB   3
  156:     00E5 +0003                  JTIC2   RMB   3
  157:     00E8 +0003                  JTIC1   RMB   3
  158:     00EB +0003                  JRTI    RMB   3
  159:     00EE +0003                  JIRQ    RMB   3
  160:     00F1 +0003                  JXIRQ   RMB   3
  161:     00F4 +0003                  JSWI    RMB   3
  162:     00F7 +0003                  JILLOP  RMB   3
  163:     00FA +0003                  JCOP    RMB   3
  164:     00FD +0003                  JCLM    RMB   3
  165:                                 
  166:                                 *****************
  167:                                 *
  168:                                 * ROM starts here *
  169:                                 *
  170:                                 *****************
  171:                                 
  172:          =0000E000                      ORG  ROMBS
  173:                                 
  174:                                 *****************
  175:                                 **  BUFFALO - This is where Buffalo starts
  176:                                 ** out of reset.  All initialization is done
  177:                                 ** here including determination of where the
  178:                                 ** user terminal is (SCI,ACIA, or DUART).
  179:                                 *****************
  180:                                 
  181:     E000 CE 100A                BUFFALO  LDX  #PORTE
  182:     E003 1F 00 01 03                     BRCLR 0,X,#01,BUFISIT ;if bit 0 of port e is 1
  183:     E007 7E B600                         JMP  DSTREE      ;then jump to the start of EEPROM
  184:     E00A 86 93                  BUFISIT  LDAA #$93
  185:     E00C B7 1039                         STAA OPTION      ;adpu, dly, irqe, cop
  186:     E00F 86 00                           LDAA #$00
  187:     E011 B7 1024                         STAA TMSK2       ;timer pre = %1 for trace
  188:     E014 86 00                           LDAA #$00
  189:     E016 B7 1035                         STAA BPROT       ;clear 'E9 eeprom block protect
  190:     E019 CE B600                         LDX  #DSTREE     ;set up default eeprom address range
  191:     E01C DF 98                           STX  STREE
  192:     E01E CE B7FF                         LDX  #DENDEE
  193:     E021 DF 9A                           STX  ENDEE
  194:     E023 CE 0000                         LDX  #$0000      ;set up default download offset
  195:     E026 DF AC                           STX  LDOFFST
  196:     E028 8E 005F                         LDS  #STACK      ;monitor stack pointer
  197:     E02B BD E357                         JSR  VECINIT
  198:     E02E CE 0041                         LDX  #USTACK
  199:     E031 DF 69                           STX  SP          ;default user stack
  200:     E033 B6 1020                         LDAA TCTL1
  201:     E036 8A 03                           ORAA #$03
  202:     E038 B7 1020                         STAA TCTL1       ;force oc5 pin high for trace
  203:     E03B 86 D0                           LDAA #$D0
  204:     E03D 97 68                           STAA REGS+8      ;default user ccr
  205:     E03F CC 3F0D                         LDD  #$3F0D      ;initial command is ?
  206:     E042 DD 6B                           STD  INBUFF
  207:     E044 BD E1B8                         JSR  BPCLR       ;clear breakpoints
  208:     E047 7F 00A4                         CLR  AUTOLF
  209:     E04A 7C 00A4                         INC  AUTOLF      ;auto cr/lf = on
  210:                                 
  211:                                 * Determine type of external comm device - none, or acia *
  212:                                 
  213:     E04D 7F 00A6                         CLR  EXTDEV      ;default is none
  214:     E050 B6 103C                         LDAA HPRIO
  215:     E053 84 20                           ANDA #$20
  216:     E055 27 35                           BEQ  BUFF2       ;jump if single chip mode
  217:     E057 86 03                           LDAA #$03        ;see if external acia exists
  218:     E059 B7 9800                         STAA ACIA        ;master reset
  219:     E05C B6 9800                         LDAA ACIA
  220:     E05F 84 7F                           ANDA #$7F        ;mask irq bit from status register
  221:     E061 26 12                           BNE  BUFF1       ;jump if status reg not 0
  222:     E063 86 12                           LDAA #$12
  223:     E065 B7 9800                         STAA ACIA        ;turn on acia
  224:     E068 B6 9800                         LDAA ACIA
  225:     E06B 84 02                           ANDA #$02
  226:     E06D 27 06                           BEQ  BUFF1       ;jump if tdre not set
  227:     E06F 86 01                           LDAA #$01
  228:     E071 97 A6                           STAA EXTDEV      ;external device is acia
  229:     E073 20 17                           BRA  BUFF2
  230:                                 
  231:          =0000E075              BUFF1    EQU  *           ;see if duart exists
  232:     E075 B6 D00C                         LDAA  DUART+$0C  ;read IRQ vector register
  233:     E078 81 0F                           CMPA  #$0F       ;should be out of reset
  234:     E07A 26 10                           BNE   BUFF2
  235:     E07C 86 AA                           LDAA #$AA
  236:     E07E B7 D00C                         STAA DUART+$0C   ;write irq vector register
  237:     E081 B6 D00C                         LDAA DUART+$0C   ;read irq vector register
  238:     E084 81 AA                           CMPA #$AA
  239:     E086 26 04                           BNE  BUFF2
  240:     E088 86 02                           LDAA #$02
  241:     E08A 97 A6                           STAA EXTDEV      ;external device is duart A
  242:                                 
  243:                                 * Find terminal port - SCI or external. *
  244:                                 
  245:     E08C 7F 00A5                BUFF2    CLR  IODEV
  246:     E08F BD E34F                         JSR  TARGCO    ;disconnect sci for evb board
  247:     E092 BD E0B7                         JSR  SIGNON    ;initialize sci
  248:     E095 96 A6                           LDAA EXTDEV
  249:     E097 27 05                           BEQ  BUFF3     ;jump if no external device
  250:     E099 97 A5                           STAA IODEV
  251:     E09B BD E0B7                         JSR  SIGNON    ;initialize external device
  252:     E09E 7F 00A5                BUFF3    CLR  IODEV
  253:     E0A1 BD E39E                         JSR  INPUT     ;get input from sci port
  254:     E0A4 81 0D                           CMPA #$0D
  255:     E0A6 27 19                           BEQ  BUFF4     ;jump if cr - sci is terminal port
  256:     E0A8 96 A6                           LDAA EXTDEV
  257:     E0AA 27 F2                           BEQ  BUFF3     ;jump if no external device
  258:     E0AC 97 A5                           STAA IODEV
  259:     E0AE BD E39E                         JSR  INPUT     ;get input from external device
  260:     E0B1 81 0D                           CMPA #$0D
  261:     E0B3 27 0C                           BEQ  BUFF4     ;jump if cr - terminal found ext
  262:     E0B5 20 E7                           BRA  BUFF3
  263:                                 
  264:     E0B7 BD E378                SIGNON   JSR  INIT        ;initialize device
  265:     E0BA CE E640                         LDX  #MSG1       ;buffalo message
  266:     E0BD BD E518                         JSR  OUTSTRG
  267:     E0C0 39                              RTS
  268:                                 
  269:                                 * Determine where host port should be. *
  270:                                 
  271:     E0C1 7F 00A7                BUFF4    CLR  HOSTDEV     ;default - host = sci port
  272:     E0C4 96 A5                           LDAA IODEV
  273:     E0C6 81 01                           CMPA #$01
  274:     E0C8 27 04                           BEQ  BUFF5       ;default host if term = acia
  275:     E0CA 86 03                           LDAA #$03
  276:     E0CC 97 A7                           STAA HOSTDEV     ;else host is duart port b
  277:          =0000E0CE              BUFF5    EQU  *
  278:                                 
  279:                                 *****************
  280:                                 **  MAIN - This module reads the user's input into
  281:                                 ** a buffer called INBUFF.  The first field (assumed
  282:                                 ** to be the command field) is then parsed into a
  283:                                 ** second buffer called COMBUFF.  The command table
  284:                                 ** is then searched for the contents of COMBUFF and
  285:                                 ** if found, the address of the corresponding task
  286:                                 ** routine is fetched from the command table.  The
  287:                                 ** task is then called as a subroutine so that
  288:                                 ** control returns back to here upon completion of
  289:                                 ** the task.  Buffalo expects the following format
  290:                                 ** for commands:
  291:                                 **     <cmd>[<wsp><arg><wsp><arg>...]<cr>
  292:                                 ** [] implies contents optional.
  293:                                 ** <wsp> means whitespace character (space,comma,tab).
  294:                                 ** <cmd> = command string of 1-8 characters.
  295:                                 ** <arg> = Argument particular to the command.
  296:                                 ** <cr> = Carriage return signifying end of input string.
  297:                                 *****************
  298:                                 * Prompt user
  299:                                 *do
  300:                                 *   a=input();
  301:                                 *   if(a==(cntlx or del)) continue;
  302:                                 *   elseif(a==backspace)
  303:                                 *      b--;
  304:                                 *      if(b<0) b=0;
  305:                                 *   else
  306:                                 *      if(a==cr && buffer empty)
  307:                                 *         repeat last command;
  308:                                 *      else put a into buffer;
  309:                                 *         check if buffer full;
  310:                                 *while(a != (cr or /)
  311:     E0CE 0F                     MAIN     SEI            ;block interrupts
  312:     E0CF 8E 005F                         LDS  #STACK    ;initialize sp every time
  313:     E0D2 7F 00A4                         CLR  AUTOLF
  314:     E0D5 7C 00A4                         INC  AUTOLF    ;auto cr/lf = on
  315:     E0D8 BD E508                         JSR  OUTCRLF
  316:     E0DB 86 3E                           LDAA #PROMPT   ;prompt user
  317:     E0DD BD E3CA                         JSR  OUTPUT
  318:     E0E0 5F                              CLRB
  319:     E0E1 BD E544                MAIN1    JSR  INCHAR    ;read terminal
  320:     E0E4 CE 006B                         LDX  #INBUFF
  321:     E0E7 3A                              ABX            ;pointer into buffer
  322:     E0E8 81 18                           CMPA #CTLX
  323:     E0EA 27 E2                           BEQ  MAIN      ;jump if cntl X
  324:     E0EC 81 7F                           CMPA #DEL
  325:     E0EE 27 DE                           BEQ  MAIN      ;jump if del
  326:     E0F0 81 08                           CMPA #$08
  327:     E0F2 26 05                           BNE  MAIN2     ;jump if not bckspc
  328:     E0F4 5A                              DECB
  329:     E0F5 2D D7                           BLT  MAIN      ;jump if buffer empty
  330:     E0F7 20 E8                           BRA  MAIN1
  331:     E0F9 81 0D                  MAIN2    CMPA #$D
  332:     E0FB 26 07                           BNE  MAIN3     ;jump if not cr
  333:     E0FD 5D                              TSTB
  334:     E0FE 27 17                           BEQ  COMM0     ;jump if buffer empty
  335:     E100 A7 00                           STAA ,X        ;put a in buffer
  336:     E102 20 13                           BRA  COMM0
  337:     E104 A7 00                  MAIN3    STAA ,X        ;put a in buffer
  338:     E106 5C                              INCB
  339:     E107 C1 23                           CMPB #BUFFLNG
  340:     E109 2F 08                           BLE  MAIN4     ;jump if not long
  341:     E10B CE E68A                         LDX  #MSG3     ;"long"
  342:     E10E BD E518                         JSR  OUTSTRG
  343:     E111 20 BB                           BRA  MAIN
  344:     E113 81 2F                  MAIN4    CMPA #'/'
  345:     E115 26 CA                           BNE  MAIN1     ;jump if not "/"
  346:                                 *        *******************
  347:                                 
  348:                                 *****************
  349:                                 *  Parse out and evaluate the command field.
  350:                                 *****************
  351:                                 *Initialize
  352:                                 
  353:          =0000E117              COMM0    EQU  *
  354:     E117 7F 00C0                         CLR  TMP1        ;Enable "/" command
  355:     E11A 7F 0096                         CLR  SHFTREG
  356:     E11D 7F 0097                         CLR  SHFTREG+1
  357:     E120 5F                              CLRB
  358:     E121 CE 006B                         LDX  #INBUFF     ;ptrbuff[] = inbuff[]
  359:     E124 DF AE                           STX  PTR0
  360:     E126 BD E306                         JSR  WSKIP       ;find first char
  361:                                 
  362:                                 *while((a=readbuff) != (cr or wspace))
  363:                                 *     upcase(a);
  364:                                 *     buffptr[b] = a
  365:                                 *     b++
  366:                                 *     if (b > 8) error(too long);
  367:                                 *     if(a == "/")
  368:                                 *          if(enabled) mslash();
  369:                                 *          else error(command?);
  370:                                 *     else hexbin(a);
  371:                                 
  372:          =0000E129              COMM1    EQU  *
  373:     E129 BD E2F1                         JSR  READBUFF  ;read from buffer
  374:     E12C CE 008E                         LDX  #COMBUFF
  375:     E12F 3A                              ABX
  376:     E130 BD E1AD                         JSR  UPCASE    ;convert to upper case
  377:     E133 A7 00                           STAA ,X        ;put in command buffer
  378:     E135 81 0D                           CMPA #$0D
  379:     E137 27 36                           BEQ  SRCH      ;jump if cr
  380:     E139 BD E316                         JSR  WCHEK
  381:     E13C 27 31                           BEQ  SRCH      ;jump if wspac
  382:     E13E BD E2F8                         JSR  INCBUFF   ;move buffer pointer
  383:     E141 5C                              INCB
  384:     E142 C1 08                           CMPB #$8
  385:     E144 2F 09                           BLE  COMM2
  386:     E146 CE E68A                         LDX  #MSG3     ;"long"
  387:     E149 BD E518                         JSR  OUTSTRG
  388:     E14C 7E E0CE                         JMP  MAIN
  389:                                 
  390:          =0000E14F              COMM2    EQU  *
  391:     E14F 81 2F                           CMPA #'/'
  392:     E151 26 17                           BNE  COMM4       ;jump if not "/"
  393:     E153 7D 00C0                         TST  TMP1
  394:     E156 26 09                           BNE  COMM3       ;jump if not enabled
  395:     E158 5A                              DECB
  396:     E159 D7 A8                           STAB COUNT
  397:     E15B CE E917                         LDX  #MSLASH
  398:     E15E 7E E1A8                         JMP  EXEC        ;execute "/"
  399:     E161 CE E6A2                COMM3    LDX  #MSG8       ;"command?"
  400:     E164 BD E518                         JSR  OUTSTRG
  401:     E167 7E E0CE                         JMP  MAIN
  402:          =0000E16A              COMM4    EQU  *
  403:     E16A BD E207                         JSR  HEXBIN
  404:     E16D 20 BA                           BRA  COMM1
  405:                                 
  406:                                 *****************
  407:                                 *   Search tables for command.  At this point,
  408:                                 * COMBUFF holds the command field to be executed,
  409:                                 * and B = # of characters in the command field.
  410:                                 * The command table holds the whole command name
  411:                                 * but only the first n characters of the command
  412:                                 * must match what is in COMBUFF where n is the
  413:                                 * number of characters entered by the user.
  414:                                 *****************
  415:                                 *count = b;
  416:                                 *ptr1 = comtabl;
  417:                                 *while(ptr1[0] != end of table)
  418:                                 *   ptr1 = next entry
  419:                                 *   for(b=1; b=count; b++)
  420:                                 *      if(ptr1[b] == combuff[b]) continue;
  421:                                 *      else error(not found);
  422:                                 *   execute task;
  423:                                 *  return();
  424:                                 *return(command not found);
  425:                                 
  426:     E16F D7 A8                  SRCH    STAB COUNT     ;size of command entered
  427:     E171 CE E54E                        LDX  #COMTABL  ;pointer to table
  428:     E174 DF B0                          STX  PTR1      ;pointer to next entry
  429:     E176 DE B0                  SRCH1   LDX  PTR1
  430:     E178 18CE 008E                      LDY  #COMBUFF  ;pointer to command buffer
  431:     E17C E6 00                          LDAB 0,X
  432:     E17E C1 FF                          CMPB #$FF
  433:     E180 26 09                          BNE  SRCH2
  434:     E182 CE E684                        LDX  #MSG2     ;"command not found"
  435:     E185 BD E518                        JSR  OUTSTRG
  436:     E188 7E E0CE                        JMP  MAIN
  437:     E18B 3C                     SRCH2   PSHX            ;compute next table entry
  438:     E18C CB 03                          ADDB #$3
  439:     E18E 3A                             ABX
  440:     E18F DF B0                          STX  PTR1
  441:     E191 38                             PULX
  442:     E192 5F                             CLRB
  443:     E193 5C                     SRCHLP  INCB            ;match characters loop
  444:     E194 A6 01                          LDAA 1,X        ;read table
  445:     E196 18A1 00                        CMPA 0,Y        ;compare to combuff
  446:     E199 26 DB                          BNE  SRCH1      ;try next entry
  447:     E19B 08                             INX             ;move pointers
  448:     E19C 1808                           INY
  449:     E19E D1 A8                          CMPB COUNT
  450:     E1A0 2D F1                          BLT  SRCHLP     ;loop countu1 times
  451:     E1A2 DE B0                          LDX  PTR1
  452:     E1A4 09                             DEX
  453:     E1A5 09                             DEX
  454:     E1A6 EE 00                          LDX  0,X     ;jump address from table
  455:     E1A8 AD 00                  EXEC    JSR  0,X     ;call task as subroutine
  456:     E1AA 7E E0CE                        JMP  MAIN
  457:                                 *
  458:                                 *****************
  459:                                 *   UTILITY SUBROUTINES - These routines
  460:                                 * are called by any of the task routines.
  461:                                 *****************
  462:                                 *****************
  463:                                 *  UPCASE(a) - If the contents of A is alpha,
  464:                                 * returns a converted to uppercase.
  465:                                 *****************
  466:     E1AD 81 61                  UPCASE   CMPA #'a'
  467:     E1AF 2D 06                           BLT  UPCASE1      ;jump if < a
  468:     E1B1 81 7A                           CMPA #'z'
  469:     E1B3 2E 02                           BGT  UPCASE1      ;jump if > z
  470:     E1B5 80 20                           SUBA #$20         ;convert
  471:     E1B7 39                     UPCASE1  RTS
  472:                                 
  473:                                 *****************
  474:                                 *  BPCLR() - Clear all entries in the
  475:                                 * table of breakpoints.
  476:                                 *****************
  477:     E1B8 CE 009C                BPCLR    LDX  #BRKTABL
  478:     E1BB C6 08                           LDAB #8
  479:     E1BD 6F 00                  BPCLR1   CLR  0,X
  480:     E1BF 08                              INX
  481:     E1C0 5A                              DECB
  482:     E1C1 2E FA                           BGT  BPCLR1      ;loop 8 times
  483:     E1C3 39                              RTS
  484:                                 
  485:                                 *****************
  486:                                 *  RPRNT1(x) - Prints name and contents of a single
  487:                                 * user register. On entry X points to name of register
  488:                                 * in reglist.  On exit, a=register name.
  489:                                 *****************
  490:     E1C4 50 59 58 41 42 43      REGLIST  FCC  'PYXABCS'       ;names
           E1CA 53 
  491:     E1CB 00 02 04 06 07 08               FCB  0,2,4,6,7,8,9   ;offset
           E1D1 09 
  492:     E1D2 01 01 01 00 00 00               FCB  1,1,1,0,0,0,1   ;size
           E1D8 01 
  493:     E1D9 A6 00                  RPRNT1   LDAA 0,X
  494:     E1DB 36                              PSHA
  495:     E1DC 3C                              PSHX
  496:     E1DD BD E3CA                         JSR  OUTPUT      ;name
  497:     E1E0 86 2D                           LDAA #'-'
  498:     E1E2 BD E3CA                         JSR  OUTPUT      ;dash
  499:     E1E5 E6 07                           LDAB 7,X         ;contents offset
  500:     E1E7 A6 0E                           LDAA 14,X        ;bytesize
  501:     E1E9 CE 0060                         LDX  #REGS       ;address
  502:     E1EC 3A                              ABX
  503:     E1ED 4D                              TSTA
  504:     E1EE 27 03                           BEQ  RPRN2       ;jump if 1 byte
  505:     E1F0 BD E4F0                         JSR  OUT1BYT     ;2 bytes
  506:     E1F3 BD E4FF                RPRN2    JSR  OUT1BSP
  507:     E1F6 38                              PULX
  508:     E1F7 32                              PULA
  509:     E1F8 39                              RTS
  510:                                 
  511:                                 *****************
  512:                                 *  RPRINT() - Print the name and contents
  513:                                 * of all the user registers.
  514:                                 *****************
  515:     E1F9 3C                     RPRINT   PSHX
  516:     E1FA CE E1C4                         LDX  #REGLIST
  517:     E1FD BD E1D9                RPRI1    JSR  RPRNT1      ;print name
  518:     E200 08                              INX
  519:     E201 81 53                           CMPA #'S'        ;s is last register
  520:     E203 26 F8                           BNE  RPRI1       ;jump if not done
  521:     E205 38                              PULX
  522:     E206 39                              RTS
  523:                                 
  524:                                 *****************
  525:                                 *   HEXBIN(a) - Convert the ASCII character in a
  526:                                 * to binary and shift into shftreg.  Returns value
  527:                                 * in tmp1 incremented if a is not hex.
  528:                                 *****************
  529:     E207 36                     HEXBIN  PSHA
  530:     E208 37                             PSHB
  531:     E209 3C                             PSHX
  532:     E20A BD E1AD                        JSR  UPCASE     ;convert to upper case
  533:     E20D 81 30                          CMPA #'0'
  534:     E20F 2D 22                          BLT  HEXNOT     ;jump if a < $30
  535:     E211 81 39                          CMPA #'9'
  536:     E213 2F 0A                          BLE  HEXNMB     ;jump if 0-9
  537:     E215 81 41                          CMPA #'A'
  538:     E217 2D 1A                          BLT  HEXNOT     ;jump if $39> a <$41
  539:     E219 81 46                          CMPA #'F'
  540:     E21B 2E 16                          BGT  HEXNOT     ;jump if a > $46
  541:     E21D 8B 09                          ADDA #$9        ;convert $A-$F
  542:     E21F 84 0F                  HEXNMB  ANDA #$0F       ;convert to binary
  543:     E221 CE 0096                        LDX  #SHFTREG
  544:     E224 C6 04                          LDAB #4
  545:     E226 68 01                  HEXSHFT ASL  1,X        ;2 byte shift through
  546:     E228 69 00                          ROL  0,X        ;       carry bit
  547:     E22A 5A                             DECB
  548:     E22B 2E F9                          BGT  HEXSHFT    ;shift 4 times
  549:     E22D AA 01                          ORAA 1,X
  550:     E22F A7 01                          STAA 1,X
  551:     E231 20 03                          BRA  HEXRTS
  552:     E233 7C 00C0                HEXNOT  INC  TMP1       ;indicate not hex
  553:     E236 38                     HEXRTS  PULX
  554:     E237 33                             PULB
  555:     E238 32                             PULA
  556:     E239 39                             RTS
  557:                                 
  558:                                 *****************
  559:                                 *  BUFFARG() - Build a hex argument from the
  560:                                 * contents of the input buffer. Characters are
  561:                                 * converted to binary and shifted into shftreg
  562:                                 * until a non-hex character is found.  On exit
  563:                                 * shftreg holds the last four digits read, count
  564:                                 * holds the number of digits read, ptrbuff points
  565:                                 * to the first non-hex character read, and A holds
  566:                                 * that first non-hex character.
  567:                                 *****************
  568:                                 *Initialize
  569:                                 *while((a=readbuff()) not hex)
  570:                                 *     hexbin(a);
  571:                                 *return();
  572:                                 
  573:     E23A 7F 00C0                BUFFARG  CLR  TMP1        ;not hex indicator
  574:     E23D 7F 00A8                         CLR  COUNT       ;# or digits
  575:     E240 7F 0096                         CLR  SHFTREG
  576:     E243 7F 0097                         CLR  SHFTREG+1
  577:     E246 BD E306                         JSR  WSKIP
  578:     E249 BD E2F1                BUFFLP   JSR  READBUFF    ;read char
  579:     E24C BD E207                         JSR  HEXBIN
  580:     E24F 7D 00C0                         TST  TMP1
  581:     E252 26 08                           BNE  BUFFRTS     ;jump if not hex
  582:     E254 7C 00A8                         INC  COUNT
  583:     E257 BD E2F8                         JSR  INCBUFF     ;move buffer pointer
  584:     E25A 20 ED                           BRA  BUFFLP
  585:     E25C 39                     BUFFRTS  RTS
  586:                                 
  587:                                 *****************
  588:                                 *  TERMARG() - Build a hex argument from the
  589:                                 * terminal.  Characters are converted to binary
  590:                                 * and shifted into shftreg until a non-hex character
  591:                                 * is found.  On exit shftreg holds the last four
  592:                                 * digits read, count holds the number of digits
  593:                                 * read, and A holds the first non-hex character.
  594:                                 *****************
  595:                                 *initialize
  596:                                 *while((a=inchar()) == hex)
  597:                                 *     if(a = cntlx or del)
  598:                                 *          abort;
  599:                                 *     else
  600:                                 *          hexbin(a); countu1++;
  601:                                 *return();
  602:                                 
  603:     E25D 7F 00A8                TERMARG  CLR  COUNT
  604:     E260 7F 0096                         CLR  SHFTREG
  605:     E263 7F 0097                         CLR  SHFTREG+1
  606:     E266 BD E544                TERM0    JSR  INCHAR
  607:     E269 81 18                           CMPA #CTLX
  608:     E26B 27 04                           BEQ  TERM1     ;jump if controlx
  609:     E26D 81 7F                           CMPA #DEL
  610:     E26F 26 03                           BNE  TERM2     ;jump if not delete
  611:     E271 7E E0CE                TERM1    JMP  MAIN      ;abort
  612:     E274 7F 00C0                TERM2    CLR  TMP1      ;hex indicator
  613:     E277 BD E207                         JSR  HEXBIN
  614:     E27A 7D 00C0                         TST  TMP1
  615:     E27D 26 05                           BNE  TERM3     ;jump if not hex
  616:     E27F 7C 00A8                         INC  COUNT
  617:     E282 20 E2                           BRA  TERM0
  618:     E284 39                     TERM3    RTS
  619:                                 
  620:                                 *****************
  621:                                 *   CHGBYT() - If shftreg is not empty, put
  622:                                 * contents of shftreg at address in X.  If X
  623:                                 * is an address in EEPROM then program it.
  624:                                 *****************
  625:                                 *if(count != 0)
  626:                                 *   (x) = a;
  627:     E285 7D 00A8                CHGBYT   TST  COUNT
  628:     E288 27 05                           BEQ  CHGBYT4   ;quit if shftreg empty
  629:     E28A 96 97                           LDAA SHFTREG+1 ;get data into a
  630:     E28C BD E290                         JSR  WRITE
  631:     E28F 39                     CHGBYT4  RTS
  632:                                 
  633:                                 
  634:                                 *****************
  635:                                 * WRITE() - This routine is used to write the
  636:                                 *contents of A to the address of X.  If the
  637:                                 *address is in EEPROM, it will be programmed
  638:                                 *and if it is already programmed, it will be
  639:                                 *byte erased first.
  640:                                 ******************
  641:                                 *if(X == config) then
  642:                                 *   byte erase config;
  643:                                 *if(X is eeprom)then
  644:                                 *   if(not erased) then erase;
  645:                                 *   program (x) = A;
  646:                                 *write (x) = A;
  647:                                 *if((x) != A) error(rom);
  648:          =0000E290              WRITE   EQU  *
  649:     E290 8C 103F                        CPX  #CONFIG
  650:     E293 27 10                          BEQ  WRITE0     ;jump if config
  651:     E295 9C 98                          CPX  STREE      ;start of EE
  652:     E297 25 12                          BLO  WRITE2     ;jump if not EE
  653:     E299 9C 9A                          CPX  ENDEE      ;end of EE
  654:     E29B 22 0E                          BHI  WRITE2     ;jump if not EE
  655:     E29D 37                     WRITEE  PSHB            ;check if byte erased
  656:     E29E E6 00                          LDAB 0,X
  657:     E2A0 C1 FF                          CMPB #$FF
  658:     E2A2 33                             PULB
  659:     E2A3 27 03                          BEQ  WRITE1     ;jump if erased
  660:     E2A5 BD E2C6                WRITE0  JSR  EEBYTE     ;byte erase
  661:     E2A8 BD E2BA                WRITE1  JSR  EEWRIT     ;byte program
  662:     E2AB A7 00                  WRITE2  STAA 0,X        ;write for non EE
  663:     E2AD A1 00                          CMPA 0,X
  664:     E2AF 27 08                          BEQ  WRITE3     ;jump if write ok
  665:     E2B1 3C                             PSHX
  666:     E2B2 CE E69D                        LDX  #MSG6      ;"rom"
  667:     E2B5 BD E518                        JSR  OUTSTRG
  668:     E2B8 38                             PULX
  669:     E2B9 39                     WRITE3  RTS
  670:                                 
  671:                                 
  672:                                 *****************
  673:                                 *   EEWRIT(), EEBYTE(), EEBULK() -
  674:                                 * These routines are used to program and eeprom
  675:                                 *locations.  eewrite programs the address in X with
  676:                                 *the value in A, eebyte does a byte address at X,
  677:                                 *and eebulk does a bulk of eeprom.  Whether eebulk
  678:                                 *erases the config or not depends on the address it
  679:                                 *receives in X.
  680:                                 ****************
  681:          =0000E2BA              EEWRIT  EQU  *          ;program one byte at x
  682:     E2BA 37                             PSHB
  683:     E2BB C6 02                          LDAB #$02
  684:     E2BD F7 103B                        STAB PPROG
  685:     E2C0 A7 00                          STAA 0,X
  686:     E2C2 C6 03                          LDAB #$03
  687:     E2C4 20 18                          BRA  EEPROG
  688:                                 ***
  689:          =0000E2C6              EEBYTE  EQU  *          ;byte erase address x
  690:     E2C6 37                             PSHB
  691:     E2C7 C6 16                          LDAB #$16
  692:     E2C9 F7 103B                        STAB PPROG
  693:     E2CC C6 FF                          LDAB #$FF
  694:     E2CE E7 00                          STAB 0,X
  695:     E2D0 C6 17                          LDAB #$17
  696:     E2D2 20 0A                          BRA  EEPROG
  697:                                 ***
  698:          =0000E2D4              EEBULK  EQU  *          ;bulk erase eeprom
  699:     E2D4 37                             PSHB
  700:     E2D5 C6 06                          LDAB #$06
  701:     E2D7 F7 103B                        STAB PPROG
  702:     E2DA A7 00                          STAA 0,X        ;erase config or not ...
  703:     E2DC C6 07                          LDAB #$07       ;  ... depends on X addr
  704:     E2DE 26 01                  EEPROG  BNE  ACL1
  705:     E2E0 5F                             CLRB            ;fail safe
  706:     E2E1 F7 103B                ACL1    STAB PPROG
  707:     E2E4 33                             PULB
  708:                                 ***
  709:          =0000E2E5              DLY10MS EQU  *          ;delay 10ms at E = 2MHz
  710:     E2E5 3C                             PSHX
  711:     E2E6 CE 0D06                        LDX  #$0D06
  712:     E2E9 09                     DLYLP   DEX
  713:     E2EA 26 FD                          BNE  DLYLP
  714:     E2EC 38                             PULX
  715:     E2ED 7F 103B                        CLR  PPROG
  716:     E2F0 39                             RTS
  717:                                 
  718:                                 
  719:                                 *****************
  720:                                 *  READBUFF() -  Read the character in INBUFF
  721:                                 * pointed at by ptrbuff into A.  Returns ptrbuff
  722:                                 * unchanged.
  723:                                 *****************
  724:     E2F1 3C                     READBUFF PSHX
  725:     E2F2 DE AE                           LDX  PTR0
  726:     E2F4 A6 00                           LDAA 0,X
  727:     E2F6 38                              PULX
  728:     E2F7 39                              RTS
  729:                                 
  730:                                 *****************
  731:                                 *  INCBUFF(), DECBUFF() - Increment or decrement
  732:                                 * ptrbuff.
  733:                                 *****************
  734:     E2F8 3C                     INCBUFF  PSHX
  735:     E2F9 DE AE                           LDX  PTR0
  736:     E2FB 08                              INX
  737:     E2FC 20 04                           BRA  INCDEC
  738:     E2FE 3C                     DECBUFF  PSHX
  739:     E2FF DE AE                           LDX  PTR0
  740:     E301 09                              DEX
  741:     E302 DF AE                  INCDEC   STX  PTR0
  742:     E304 38                              PULX
  743:     E305 39                              RTS
  744:                                 
  745:                                 *****************
  746:                                 *  WSKIP() - Read from the INBUFF until a
  747:                                 * non whitespace (space, comma, tab) character
  748:                                 * is found.  Returns ptrbuff pointing to the
  749:                                 * first non-whitespace character and a holds
  750:                                 * that character.  WSKIP also compares a to
  751:                                 * $0D (CR) and cond codes indicating the
  752:                                 * results of that compare.
  753:                                 *****************
  754:     E306 BD E2F1                WSKIP    JSR  READBUFF  ;read character
  755:     E309 BD E316                         JSR  WCHEK
  756:     E30C 26 05                           BNE  WSKIP1    ;jump if not wspc
  757:     E30E BD E2F8                         JSR  INCBUFF   ;move pointer
  758:     E311 20 F3                           BRA  WSKIP     ;loop
  759:     E313 81 0D                  WSKIP1   CMPA #$0D
  760:     E315 39                              RTS
  761:                                 
  762:                                 *****************
  763:                                 *  WCHEK(a) - Returns z=1 if a holds a
  764:                                 * whitespace character, else z=0.
  765:                                 *****************
  766:     E316 81 2C                  WCHEK    CMPA #$2C      ;comma
  767:     E318 27 06                           BEQ  WCHEK1
  768:     E31A 81 20                           CMPA #$20      ;space
  769:     E31C 27 02                           BEQ  WCHEK1
  770:     E31E 81 09                           CMPA #$09      ;tab
  771:     E320 39                     WCHEK1   RTS
  772:                                 
  773:                                 *****************
  774:                                 *   DCHEK(a) - Returns Z=1 if a = whitespace
  775:                                 * or carriage return.  Else returns z=0.
  776:                                 *****************
  777:     E321 BD E316                DCHEK   JSR  WCHEK
  778:     E324 27 02                          BEQ  DCHEK1     ;jump if whitespace
  779:     E326 81 0D                          CMPA #$0D
  780:     E328 39                     DCHEK1  RTS
  781:                                 
  782:                                 *****************
  783:                                 *  CHKABRT() - Checks for a control x or delete
  784:                                 * from the terminal.  If found, the stack is
  785:                                 * reset and the control is transferred to main.
  786:                                 * Note that this is an abnormal termination.
  787:                                 *   If the input from the terminal is a control W
  788:                                 * then this routine keeps waiting until any other
  789:                                 * character is read.
  790:                                 *****************
  791:                                 *a=input();
  792:                                 *if(a=cntl w) wait until any other key;
  793:                                 *if(a = cntl x or del) abort;
  794:                                 
  795:     E329 BD E39E                CHKABRT  JSR  INPUT
  796:     E32C 27 18                           BEQ  CHK4      ;jump if no input
  797:     E32E 81 17                           CMPA #CTLW
  798:     E330 26 05                           BNE  CHK2      ;jump in not cntlw
  799:     E332 BD E39E                CHKABRT1 JSR  INPUT
  800:     E335 27 FB                           BEQ  CHKABRT1  ;jump if no input
  801:     E337 81 7F                  CHK2     CMPA #DEL
  802:     E339 27 08                           BEQ  CHK3      ;jump if delete
  803:     E33B 81 18                           CMPA #CTLX
  804:     E33D 27 04                           BEQ  CHK3      ;jump if control x
  805:     E33F 81 01                           CMPA #CTLA
  806:     E341 26 03                           BNE  CHK4      ;jump not control a
  807:     E343 7E E0CE                CHK3     JMP  MAIN      ;abort
  808:     E346 39                     CHK4     RTS            ;return
  809:                                 
  810:                                 ***********************
  811:                                 *  HOSTCO - connect sci to host for evb board.
  812:                                 *  TARGCO - connect sci to target for evb board.
  813:                                 ***********************
  814:     E347 36                     HOSTCO   PSHA
  815:     E348 86 01                           LDAA #$01
  816:     E34A B7 4000                         STAA DFLOP     ;send 1 to d-flop
  817:     E34D 32                              PULA
  818:     E34E 39                              RTS
  819:                                 
  820:     E34F 36                     TARGCO   PSHA
  821:     E350 86 00                           LDAA #$00
  822:     E352 B7 4000                         STAA DFLOP     ;send 0 to d-flop
  823:     E355 32                              PULA
  824:     E356 39                              RTS
  825:                                 
  826:                                 *
  827:                                 **********
  828:                                 *
  829:                                 *     VECINIT - This routine checks for
  830:                                 *        vectors in the RAM table.  All
  831:                                 *        uninitialized vectors are programmed
  832:                                 *        to JMP STOPIT
  833:                                 *
  834:                                 **********
  835:                                 *
  836:     E357 CE 00C4                VECINIT  LDX  #JSCI     ;Point to First RAM Vector
  837:     E35A 18CE E371                       LDY  #STOPIT   ;Pointer to STOPIT routine
  838:     E35E CC 7E03                         LDD  #$7E03    ;A=JMP opcode; B=offset
  839:     E361 A1 00                  VECLOOP  CMPA 0,X
  840:     E363 27 05                           BEQ  VECNEXT   ;If vector already in
  841:     E365 A7 00                           STAA 0,X       ;install JMP
  842:     E367 1AEF 01                         STY  1,X       ;to STOPIT routine
  843:     E36A 3A                     VECNEXT  ABX            ;Add 3 to point at next vector
  844:     E36B 8C 0100                         CPX  #JCLM+3   ;Done?
  845:     E36E 26 F1                           BNE  VECLOOP   ;If not, continue loop
  846:     E370 39                              RTS
  847:                                 *
  848:     E371 86 50                  STOPIT   LDAA #$50      ;Stop-enable; IRQ, XIRQ-Off
  849:     E373 06                              TAP
  850:     E374 CF                              STOP           ;You are lost!  Shut down
  851:     E375 7E E371                         JMP  STOPIT    ;In case continue by XIRQ
  852:                                 
  853:                                 **********
  854:                                 *
  855:                                 *   I/O MODULE
  856:                                 *     Communications with the outside world.
  857:                                 * 3 I/O routines (INIT, INPUT, and OUTPUT) call
  858:                                 * drivers specified by IODEV (0=SCI, 1=ACIA,
  859:                                 * 2=DUARTA, 3=DUARTB).
  860:                                 *
  861:                                 **********
  862:                                 *   INIT() - Initialize device specified by iodev.
  863:                                 *********
  864:                                 *
  865:          =0000E378              INIT     EQU  *
  866:     E378 36                              PSHA        ;save registers
  867:     E379 3C                              PSHX
  868:     E37A 96 A5                           LDAA IODEV
  869:     E37C 81 00                           CMPA #$00
  870:     E37E 26 05                           BNE  INIT1    ;jump not sci
  871:     E380 BD E449                         JSR  ONSCI     ;initialize sci
  872:     E383 20 16                           BRA  INIT4
  873:     E385 81 01                  INIT1    CMPA #$01
  874:     E387 26 05                           BNE  INIT2     ;jump not acia
  875:     E389 BD E488                         JSR  ONACIA    ;initialize acia
  876:     E38C 20 0D                           BRA  INIT4
  877:     E38E CE D000                INIT2    LDX  #PORTA
  878:     E391 81 02                           CMPA #$02
  879:     E393 27 03                           BEQ  INIT3     ;jump duart a
  880:     E395 CE D008                         LDX  #PORTB
  881:     E398 BD E3F3                INIT3    JSR  ONUART    ;initialize duart
  882:     E39B 38                     INIT4    PULX         ;restore registers
  883:     E39C 32                              PULA
  884:     E39D 39                              RTS
  885:                                 
  886:                                 **********
  887:                                 *  INPUT() - Read device. Returns a=char or 0.
  888:                                 *    This routine also disarms the cop.
  889:                                 **********
  890:          =0000E39E              INPUT    EQU  *
  891:     E39E 3C                              PSHX
  892:     E39F 86 55                           LDAA #$55    ;reset cop
  893:     E3A1 B7 103A                         STAA COPRST
  894:     E3A4 86 AA                           LDAA #$AA
  895:     E3A6 B7 103A                         STAA COPRST
  896:     E3A9 96 A5                           LDAA IODEV
  897:     E3AB 26 05                           BNE  INPUT1    ;jump not sci
  898:     E3AD BD E459                         JSR  INSCI     ;read sci
  899:     E3B0 20 16                           BRA  INPUT4
  900:     E3B2 81 01                  INPUT1   CMPA #$01
  901:     E3B4 26 05                           BNE  INPUT2    ;jump not acia
  902:     E3B6 BD E494                         JSR  INACIA    ;read acia
  903:     E3B9 20 0D                           BRA  INPUT4
  904:     E3BB CE D000                INPUT2   LDX  #PORTA
  905:     E3BE 81 02                           CMPA #$02
  906:     E3C0 27 03                           BEQ  INPUT3    ;jump if duart a
  907:     E3C2 CE D008                         LDX  #PORTB
  908:     E3C5 BD E41E                INPUT3   JSR  INUART    ;read uart
  909:     E3C8 38                     INPUT4   PULX
  910:     E3C9 39                              RTS
  911:                                 
  912:                                 **********
  913:                                 *   OUTPUT() - Output character in A.
  914:                                 * chrcnt indicates the current column on the
  915:                                 *output display.  It is incremented every time
  916:                                 *a character is outputted, and cleared whenever
  917:                                 *the subroutine outcrlf is called.
  918:                                 **********
  919:                                 
  920:          =0000E3CA              OUTPUT   EQU  *
  921:     E3CA 36                              PSHA         ;save registers
  922:     E3CB 37                              PSHB
  923:     E3CC 3C                              PSHX
  924:     E3CD D6 A5                           LDAB IODEV
  925:     E3CF 26 05                           BNE  OUTPUT1   ;jump not sci
  926:     E3D1 BD E466                         JSR  OUTSCI    ;write sci
  927:     E3D4 20 16                           BRA  OUTPUT4
  928:     E3D6 C1 01                  OUTPUT1  CMPB #$01
  929:     E3D8 26 05                           BNE  OUTPUT2   ;jump not acia
  930:     E3DA BD E4AE                         JSR  OUTACIA   ;write acia
  931:     E3DD 20 0D                           BRA  OUTPUT4
  932:     E3DF CE D000                OUTPUT2  LDX  #PORTA
  933:     E3E2 C1 02                           CMPB #$02
  934:     E3E4 27 03                           BEQ  OUTPUT3   ;jump if duart a
  935:     E3E6 CE D008                         LDX  #PORTB
  936:     E3E9 BD E429                OUTPUT3  JSR  OUTUART   ;write uart
  937:     E3EC 38                     OUTPUT4  PULX
  938:     E3ED 33                              PULB
  939:     E3EE 32                              PULA
  940:     E3EF 7C 00A9                         INC  CHRCNT    ;increment column count
  941:     E3F2 39                              RTS
  942:                                 
  943:                                 **********
  944:                                 *   ONUART(port) - Initialize a duart port.
  945:                                 * Sets duart to internal clock, divide by 16,
  946:                                 * 8 data + 1 stop bits.
  947:                                 **********
  948:                                 
  949:     E3F3 86 22                  ONUART   LDAA #$22
  950:     E3F5 A7 02                           STAA 2,X         ;reset receiver
  951:     E3F7 86 38                           LDAA #$38
  952:     E3F9 A7 02                           STAA 2,X         ;reset transmitter
  953:     E3FB 86 40                           LDAA #$40
  954:     E3FD A7 02                           STAA 2,X         ;reset error status
  955:     E3FF 86 10                           LDAA #$10
  956:     E401 A7 02                           STAA 2,X         ;reset pointer
  957:     E403 86 00                           LDAA #$00
  958:     E405 B7 D004                         STAA DUART+4     ;clock source
  959:     E408 86 00                           LDAA #$00
  960:     E40A B7 D005                         STAA DUART+5     ;interrupt mask
  961:     E40D 86 13                           LDAA #$13
  962:     E40F A7 00                           STAA 0,X         ;8 data, no parity
  963:     E411 86 07                           LDAA #$07
  964:     E413 A7 00                           STAA 0,X         ;1 stop bits
  965:     E415 86 BB                           LDAA #$BB        ;baud rate (9600)
  966:     E417 A7 01                           STAA 1,X         ;tx and rcv baud rate
  967:     E419 86 05                           LDAA #$05
  968:     E41B A7 02                           STAA 2,X         ;enable tx and rcv
  969:     E41D 39                              RTS
  970:                                 
  971:                                 **********
  972:                                 *   INUART(port) - Check duart for any input.
  973:                                 **********
  974:     E41E A6 01                  INUART   LDAA 1,X         ;read status
  975:     E420 84 01                           ANDA #$01        ;check rxrdy
  976:     E422 27 04                           BEQ  INUART1     ;jump if no data
  977:     E424 A6 03                           LDAA 3,X         ;read data
  978:     E426 84 7F                           ANDA #$7F        ;mask parity
  979:     E428 39                     INUART1  RTS
  980:                                 
  981:                                 **********
  982:                                 *   OUTUART(port) - Output the character in a.
  983:                                 *        if autolf=1, transmits cr or lf as crlf.
  984:                                 **********
  985:     E429 7D 00A4                OUTUART  TST  AUTOLF
  986:     E42C 27 10                           BEQ  OUTUART2    ;jump if no autolf
  987:     E42E 8D 0E                           BSR  OUTUART2
  988:     E430 81 0D                           CMPA #$0D
  989:     E432 26 04                           BNE  OUTUART1
  990:     E434 86 0A                           LDAA #$0A        ;if cr, output lf
  991:     E436 20 06                           BRA  OUTUART2
  992:     E438 81 0A                  OUTUART1 CMPA #$0A
  993:     E43A 26 0C                           BNE  OUTUART3
  994:     E43C 86 0D                           LDAA #$0D        ;if lf, output cr
  995:     E43E E6 01                  OUTUART2 LDAB 1,X         ;check status
  996:     E440 C4 04                           ANDB #$4
  997:     E442 27 FA                           BEQ  OUTUART2    ;loop until tdre=1
  998:     E444 84 7F                           ANDA #$7F        ;mask parity
  999:     E446 A7 03                           STAA 3,X         ;send character
 1000:     E448 39                     OUTUART3 RTS
 1001:                                 
 1002:                                 **********
 1003:                                 *   ONSCI() - Initialize the SCI for 9600
 1004:                                 *                 baud at 8 MHz Extal.
 1005:                                 **********
 1006:     E449 86 30                  ONSCI    LDAA #$30
 1007:     E44B B7 102B                         STAA BAUD        ;baud register
 1008:     E44E 86 00                           LDAA #$00
 1009:     E450 B7 102C                         STAA SCCR1
 1010:     E453 86 0C                           LDAA #$0C
 1011:     E455 B7 102D                         STAA SCCR2       ;enable
 1012:     E458 39                              RTS
 1013:                                 
 1014:                                 **********
 1015:                                 *   INSCI() - Read from SCI.  Return a=char or 0.
 1016:                                 **********
 1017:     E459 B6 102E                INSCI    LDAA SCSR      ;read status reg
 1018:     E45C 84 20                           ANDA #$20      ;check rdrf
 1019:     E45E 27 05                           BEQ  INSCI1    ;jump if no data
 1020:     E460 B6 102F                         LDAA SCDAT     ;read data
 1021:     E463 84 7F                           ANDA #$7F      ;mask parity
 1022:     E465 39                     INSCI1   RTS
 1023:                                 
 1024:                                 **********
 1025:                                 *  OUTSCI() - Output A to sci. IF autolf = 1,
 1026:                                 *               cr and lf sent as crlf.
 1027:                                 **********
 1028:     E466 7D 00A4                OUTSCI   TST  AUTOLF
 1029:     E469 27 10                           BEQ  OUTSCI2     ;jump if autolf=0
 1030:     E46B 8D 0E                           BSR  OUTSCI2
 1031:     E46D 81 0D                           CMPA #$0D
 1032:     E46F 26 04                           BNE  OUTSCI1
 1033:     E471 86 0A                           LDAA #$0A        ;if cr, send lf
 1034:     E473 20 06                           BRA  OUTSCI2
 1035:     E475 81 0A                  OUTSCI1  CMPA #$0A
 1036:     E477 26 0E                           BNE  OUTSCI3
 1037:     E479 86 0D                           LDAA #$0D        ;if lf, send cr
 1038:     E47B F6 102E                OUTSCI2  LDAB SCSR        ;read status
 1039:     E47E C5 80                           BITB #$80
 1040:     E480 27 F9                           BEQ  OUTSCI2     ;loop until tdre=1
 1041:     E482 84 7F                           ANDA #$7F        ;mask parity
 1042:     E484 B7 102F                         STAA SCDAT       ;send character
 1043:     E487 39                     OUTSCI3  RTS
 1044:                                 
 1045:                                 **********
 1046:                                 *   ONACIA - Initialize the ACIA for
 1047:                                 * 8 data bits, 1 stop bit, divide by 64 clock.
 1048:                                 **********
 1049:     E488 CE 9800                ONACIA   LDX  #ACIA
 1050:     E48B 86 03                           LDAA #$03
 1051:     E48D A7 00                           STAA 0,X       ;master reset
 1052:     E48F 86 16                           LDAA #$16
 1053:     E491 A7 00                           STAA 0,X       ;setup
 1054:     E493 39                              RTS
 1055:                                 
 1056:                                 **********
 1057:                                 *   INACIA - Read from the ACIA, Return a=char or 0.
 1058:                                 * Tmp3 is used to flag overrun or framing error.
 1059:                                 **********
 1060:     E494 CE 9800                INACIA   LDX  #ACIA
 1061:     E497 A6 00                           LDAA 0,X       ;read status register
 1062:     E499 36                              PSHA
 1063:     E49A 84 30                           ANDA #$30      ;check ov, fe
 1064:     E49C 32                              PULA
 1065:     E49D 27 06                           BEQ  INACIA1   ;jump - no error
 1066:     E49F 86 01                           LDAA #$01
 1067:     E4A1 97 C2                           STAA TMP3      ;flag reciever error
 1068:     E4A3 20 04                           BRA  INACIA2   ;read data to clear status
 1069:     E4A5 84 01                  INACIA1  ANDA #$01      ;check rdrf
 1070:     E4A7 27 04                           BEQ  INACIA3   ;jump if no data
 1071:     E4A9 A6 01                  INACIA2  LDAA 1,X       ;read data
 1072:     E4AB 84 7F                           ANDA #$7F      ;mask parity
 1073:     E4AD 39                     INACIA3  RTS
 1074:                                 
 1075:                                 **********
 1076:                                 *  OUTACIA - Output A to acia. IF autolf = 1,
 1077:                                 *               cr or lf sent as crlf.
 1078:                                 **********
 1079:     E4AE 8D 18                  OUTACIA  BSR  OUTACIA3  ;output char
 1080:     E4B0 7D 00A4                         TST  AUTOLF
 1081:     E4B3 27 12                           BEQ  OUTACIA2  ;jump no autolf
 1082:     E4B5 81 0D                           CMPA #$0D
 1083:     E4B7 26 06                           BNE  OUTACIA1
 1084:     E4B9 86 0A                           LDAA #$0A
 1085:     E4BB 8D 0B                           BSR  OUTACIA3  ;if cr, output lf
 1086:     E4BD 20 08                           BRA  OUTACIA2
 1087:     E4BF 81 0A                  OUTACIA1 CMPA #$0A
 1088:     E4C1 26 04                           BNE  OUTACIA2
 1089:     E4C3 86 0D                           LDAA #$0D
 1090:     E4C5 8D 01                           BSR  OUTACIA3  ;if lf, output cr
 1091:     E4C7 39                     OUTACIA2 RTS
 1092:                                 
 1093:     E4C8 CE 9800                OUTACIA3 LDX  #ACIA
 1094:     E4CB E6 00                           LDAB 0,X
 1095:     E4CD C5 02                           BITB #$2
 1096:     E4CF 27 F7                           BEQ  OUTACIA3  ;loop until tdre
 1097:     E4D1 84 7F                           ANDA #$7F      ;mask parity
 1098:     E4D3 A7 01                           STAA 1,X       ;output
 1099:     E4D5 39                              RTS
 1100:                                 *
 1101:                                 *        Space for modifying OUTACIA routine
 1102:                                 *
 1103:     E4D6 FFFF FFFF FFFF                  FDB  $FFFF,$FFFF,$FFFF,$FFFF
           E4DC FFFF 
 1104:                                 *******************************
 1105:                                 *** I/O UTILITY SUBROUTINES ***
 1106:                                 ***These subroutines perform the neccesary
 1107:                                 * data I/O operations.
 1108:                                 * OUTLHLF-Convert left 4 bits of A from binary
 1109:                                 *            to ASCII and output.
 1110:                                 * OUTRHLF-Convert right 4 bits of A from binary
 1111:                                 *            to ASCII and output.
 1112:                                 * OUT1BYT-Convert byte addresed by X from binary
 1113:                                 *           to ASCII and output.
 1114:                                 * OUT1BSP-Convert byte addressed by X from binary
 1115:                                 *           to ASCII and output followed by a space.
 1116:                                 * OUT2BSP-Convert 2 bytes addressed by X from binary
 1117:                                 *            to ASCII and  output followed by a space.
 1118:                                 * OUTSPAC-Output a space.
 1119:                                 *
 1120:                                 * OUTCRLF-Output a line feed and carriage return.
 1121:                                 *
 1122:                                 * OUTSTRG-Output the string of ASCII bytes addressed
 1123:                                 *            by X until $04.
 1124:                                 * OUTA-Output the ASCII character in A.
 1125:                                 *
 1126:                                 * TABTO-Output spaces until column 20 is reached.
 1127:                                 *
 1128:                                 * INCHAR-Input to A and echo one character.  Loops
 1129:                                 *            until character read.
 1130:                                 *        *******************
 1131:                                 
 1132:                                 **********
 1133:                                 *  OUTRHLF(), OUTLHLF(), OUTA()
 1134:                                 *Convert A from binary to ASCII and output.
 1135:                                 *Contents of A are destroyed..
 1136:                                 **********
 1137:     E4DE 44                     OUTLHLF  LSRA           ; shift data to right
 1138:     E4DF 44                              LSRA
 1139:     E4E0 44                              LSRA
 1140:     E4E1 44                              LSRA
 1141:     E4E2 84 0F                  OUTRHLF  ANDA #$0F       ;mask top half
 1142:     E4E4 8B 30                           ADDA #$30       ;convert to ascii
 1143:     E4E6 81 39                           CMPA #$39
 1144:     E4E8 2F 02                           BLE  OUTA       ;jump if 0-9
 1145:     E4EA 8B 07                           ADDA #$07       ;convert to hex A-F
 1146:     E4EC BD E3CA                OUTA     JSR  OUTPUT     ;output character
 1147:     E4EF 39                              RTS
 1148:                                 
 1149:                                 **********
 1150:                                 *  OUT1BYT(x) - Convert the byte at X to two
 1151:                                 * ASCII characters and output. Return X pointing
 1152:                                 * to next byte.
 1153:                                 **********
 1154:     E4F0 36                     OUT1BYT  PSHA
 1155:     E4F1 A6 00                           LDAA 0,X        ;get data in a
 1156:     E4F3 36                              PSHA            ;save copy
 1157:     E4F4 8D E8                           BSR  OUTLHLF    ;output left half
 1158:     E4F6 32                              PULA            ;retrieve copy
 1159:     E4F7 8D E9                           BSR  OUTRHLF    ;output right half
 1160:     E4F9 32                              PULA
 1161:     E4FA 08                              INX
 1162:     E4FB 39                              RTS
 1163:                                 
 1164:                                 **********
 1165:                                 *  OUT1BSP(x), OUT2BSP(x) - Output 1 or 2 bytes
 1166:                                 * at x followed by a space.  Returns x pointing to
 1167:                                 * next byte.
 1168:                                 **********
 1169:     E4FC BD E4F0                OUT2BSP  JSR  OUT1BYT      ;do first byte
 1170:     E4FF BD E4F0                OUT1BSP  JSR  OUT1BYT      ;do next byte
 1171:     E502 86 20                  OUTSPAC  LDAA #$20         ;output a space
 1172:     E504 BD E3CA                         JSR  OUTPUT
 1173:     E507 39                              RTS
 1174:                                 
 1175:                                 **********
 1176:                                 *  OUTCRLF() - Output a Carriage return and
 1177:                                 * a line feed.  Returns a = cr.
 1178:                                 **********
 1179:     E508 86 0D                  OUTCRLF  LDAA #$0D      ;cr
 1180:     E50A BD E3CA                         JSR  OUTPUT    ;output a
 1181:     E50D 86 00                           LDAA #$00
 1182:     E50F BD E3CA                         JSR  OUTPUT    ;output padding
 1183:     E512 86 0D                           LDAA #$0D
 1184:     E514 7F 00A9                         CLR  CHRCNT    ;zero the column counter
 1185:     E517 39                              RTS
 1186:                                 
 1187:                                 **********
 1188:                                 *  OUTSTRG(x) - Output string of ASCII bytes
 1189:                                 * starting at x until end of text ($04).  Can
 1190:                                 * be paused by control w (any char restarts).
 1191:                                 **********
 1192:     E518 BD E508                OUTSTRG  JSR  OUTCRLF
 1193:     E51B 36                     OUTSTRG0 PSHA
 1194:     E51C A6 00                  OUTSTRG1 LDAA 0,X          ;read char into a
 1195:     E51E 81 04                           CMPA #EOT
 1196:     E520 27 14                           BEQ  OUTSTRG3     ;jump if eot
 1197:     E522 BD E3CA                         JSR  OUTPUT       ;output character
 1198:     E525 08                              INX
 1199:     E526 BD E39E                         JSR  INPUT
 1200:     E529 27 F1                           BEQ  OUTSTRG1     ;jump if no input
 1201:     E52B 81 17                           CMPA #CTLW
 1202:     E52D 26 ED                           BNE  OUTSTRG1     ;jump if not cntlw
 1203:     E52F BD E39E                OUTSTRG2 JSR  INPUT
 1204:     E532 27 FB                           BEQ  OUTSTRG2     ;jump if any input
 1205:     E534 20 E6                           BRA  OUTSTRG1
 1206:     E536 32                     OUTSTRG3 PULA
 1207:     E537 39                              RTS
 1208:                                 
 1209:                                 
 1210:                                 *********
 1211:                                 *  TABTO() - move cursor over to column 20.
 1212:                                 *while(chrcnt < 16) outspac.
 1213:          =0000E538              TABTO   EQU  *
 1214:     E538 36                             PSHA
 1215:     E539 BD E502                TABTOLP JSR  OUTSPAC
 1216:     E53C 96 A9                          LDAA CHRCNT
 1217:     E53E 81 14                          CMPA #20
 1218:     E540 2F F7                          BLE  TABTOLP
 1219:     E542 32                             PULA
 1220:     E543 39                             RTS
 1221:                                 
 1222:                                 **********
 1223:                                 *  INCHAR() - Reads input until character sent.
 1224:                                 *    Echoes char and returns with a = char.
 1225:     E544 BD E39E                INCHAR   JSR  INPUT
 1226:     E547 4D                              TSTA
 1227:     E548 27 FA                           BEQ  INCHAR      ;jump if no input
 1228:     E54A BD E3CA                         JSR  OUTPUT      ;echo
 1229:     E54D 39                              RTS
 1230:                                 
 1231:                                 *********************
 1232:                                 *** COMMAND TABLE ***
 1233:          =0000E54E              COMTABL  EQU  *
 1234:     E54E 05                              FCB  5
 1235:     E54F 41 53 53 45 4D                  FCC  'ASSEM'
 1236:     E554 EB24                            FDB  ASSEM
 1237:     E556 05                              FCB  5
 1238:     E557 42 52 45 41 4B                  FCC  'BREAK'
 1239:     E55C E6EE                            FDB  BREAK
 1240:     E55E 04                              FCB  4
 1241:     E55F 42 55 4C 4B                     FCC  'BULK'
 1242:     E563 E7A9                            FDB  BULK
 1243:     E565 07                              FCB  7
 1244:     E566 42 55 4C 4B 41 4C               FCC  'BULKALL'
           E56C 4C 
 1245:     E56D E7AD                            FDB  BULKALL
 1246:     E56F 04                              FCB  4
 1247:     E570 43 41 4C 4C                     FCC  'CALL'
 1248:     E574 F9FD                            FDB  CALL
 1249:     E576 04                              FCB  4
 1250:     E577 44 55 4D 50                     FCC  'DUMP'
 1251:     E57B E7B6                            FDB  DUMP
 1252:     E57D 05                              FCB  5
 1253:     E57E 45 45 4D 4F 44                  FCC  'EEMOD'
 1254:     E583 E84B                            FDB  EEMOD
 1255:     E585 04                              FCB  4
 1256:     E586 46 49 4C 4C                     FCC  'FILL'
 1257:     E58A E89B                            FDB  FILL
 1258:     E58C 02                              FCB  2
 1259:     E58D 47 4F                           FCC  'GO'
 1260:     E58F FA56                            FDB  GO
 1261:     E591 04                              FCB  4
 1262:     E592 48 45 4C 50                     FCC  'HELP'
 1263:     E596 F604                            FDB  HELP
 1264:     E598 04                              FCB  4
 1265:     E599 48 4F 53 54                     FCC  'HOST'
 1266:     E59D FBD1                            FDB  HOST
 1267:     E59F 04                              FCB  4
 1268:     E5A0 4C 4F 41 44                     FCC  'LOAD'
 1269:     E5A4 FC6F                            FDB  LOAD
 1270:     E5A6 06                              FCB  6          ;LENGTH OF COMMAND
 1271:     E5A7 4D 45 4D 4F 52 59               FCC  'MEMORY'   ;ASCII COMMAND
 1272:     E5AD E903                            FDB  MEMORY    ;COMMAND ADDRESS
 1273:     E5AF 04                              FCB  4
 1274:     E5B0 4D 4F 56 45                     FCC  'MOVE'
 1275:     E5B4 E9D7                            FDB  MOVE
 1276:     E5B6 06                              FCB  6
 1277:     E5B7 4F 46 46 53 45 54               FCC  'OFFSET'
 1278:     E5BD FD83                            FDB  OFFSET
 1279:     E5BF 07                              FCB  7
 1280:     E5C0 50 52 4F 43 45 45               FCC  'PROCEED'
           E5C6 44 
 1281:     E5C7 FA44                            FDB  PROCEED
 1282:     E5C9 08                              FCB  8
 1283:     E5CA 52 45 47 49 53 54               FCC  'REGISTER'
           E5D0 45 52 
 1284:     E5D2 FDC4                            FDB  REGISTER
 1285:     E5D4 06                              FCB  6
 1286:     E5D5 53 54 4F 50 41 54               FCC  'STOPAT'
 1287:     E5DB FB2C                            FDB  STOPAT
 1288:     E5DD 05                              FCB  5
 1289:     E5DE 54 52 41 43 45                  FCC  'TRACE'
 1290:     E5E3 FAE7                            FDB  TRACE
 1291:     E5E5 06                              FCB  6
 1292:     E5E6 56 45 52 49 46 59               FCC  'VERIFY'
 1293:     E5EC FC67                            FDB  VERIFY
 1294:     E5EE 01                              FCB  1
 1295:     E5EF 3F                              FCC  '?'       ;initial command
 1296:     E5F0 F604                            FDB  HELP
 1297:     E5F2 05                              FCB  5
 1298:     E5F3 58 42 4F 4F 54                  FCC  'XBOOT'
 1299:     E5F8 FE34                            FDB  BOOT
 1300:     E5FA 01                              FCB  1         ;dummy command for load
 1301:     E5FB 7E                              FCC  '~'
 1302:     E5FC FEAC                            FDB  TILDE
 1303:                                 *
 1304:                                 *** Command names for evm compatability ***
 1305:                                 *
 1306:     E5FE 03                              FCB  3
 1307:     E5FF 41 53 4D                        FCC  'ASM'
 1308:     E602 EB24                            FDB  ASSEM
 1309:     E604 02                              FCB  2
 1310:     E605 42 46                           FCC  'BF'
 1311:     E607 E89B                            FDB  FILL
 1312:     E609 04                              FCB  4
 1313:     E60A 43 4F 50 59                     FCC  'COPY'
 1314:     E60E E9D7                            FDB  MOVE
 1315:     E610 05                              FCB  5
 1316:     E611 45 52 41 53 45                  FCC  'ERASE'
 1317:     E616 E7A9                            FDB  BULK
 1318:     E618 02                              FCB  2
 1319:     E619 4D 44                           FCC  'MD'
 1320:     E61B E7B6                            FDB  DUMP
 1321:     E61D 02                              FCB  2
 1322:     E61E 4D 4D                           FCC  'MM'
 1323:     E620 E903                            FDB  MEMORY
 1324:     E622 02                              FCB  2
 1325:     E623 52 44                           FCC  'RD'
 1326:     E625 FDC4                            FDB  REGISTER
 1327:     E627 02                              FCB  2
 1328:     E628 52 4D                           FCC  'RM'
 1329:     E62A FDC4                            FDB  REGISTER
 1330:     E62C 04                              FCB  4
 1331:     E62D 52 45 41 44                     FCC  'READ'
 1332:     E631 E9D7                            FDB  MOVE
 1333:     E633 02                              FCB  2
 1334:     E634 54 4D                           FCC  'TM'
 1335:     E636 FBD1                            FDB  HOST
 1336:     E638 04                              FCB  4
 1337:     E639 54 45 53 54                     FCC  'TEST'
 1338:     E63D FEAD                            FDB  EVBTEST
 1339:     E63F FF                              FCB  $FF
 1340:                                 
 1341:                                 *******************
 1342:                                 *** TEXT TABLES ***
 1343:                                 
 1344:     E640 42 55 46 46 41 4C      MSG1    FCC   'BUFFALO 3.4 (ext) - Bit User Fast Friendly Aid to Logical Operation'
           E646 4F 20 33 2E 34 20 
           E64C 28 65 78 74 29 20 
           E652 2D 20 42 69 74 20 
           E658 55 73 65 72 20 46 
           E65E 61 73 74 20 46 72 
           E664 69 65 6E 64 6C 79 
           E66A 20 41 69 64 20 74 
           E670 6F 20 4C 6F 67 69 
           E676 63 61 6C 20 4F 70 
           E67C 65 72 61 74 69 6F 
           E682 6E 
 1345:     E683 04                             FCB   EOT
 1346:     E684 57 68 61 74 3F         MSG2    FCC   'What?'
 1347:     E689 04                             FCB   EOT
 1348:     E68A 54 6F 6F 20 4C 6F      MSG3    FCC   'Too Long'
           E690 6E 67 
 1349:     E692 04                             FCB   EOT
 1350:     E693 46 75 6C 6C            MSG4    FCC   'Full'
 1351:     E697 04                             FCB   EOT
 1352:     E698 4F 70 2D 20            MSG5    FCC   'Op- '
 1353:     E69C 04                             FCB   EOT
 1354:     E69D 72 6F 6D 2D            MSG6    FCC   'rom-'
 1355:     E6A1 04                             FCB   EOT
 1356:     E6A2 43 6F 6D 6D 61 6E      MSG8    FCC   'Command?'
           E6A8 64 3F 
 1357:     E6AA 04                             FCB   EOT
 1358:     E6AB 42 61 64 20 61 72      MSG9    FCC   'Bad argument'
           E6B1 67 75 6D 65 6E 74 
 1359:     E6B7 04                             FCB   EOT
 1360:     E6B8 4E 6F 20 68 6F 73      MSG10   FCC   'No host port'
           E6BE 74 20 70 6F 72 74 
 1361:     E6C4 04                             FCB   EOT
 1362:     E6C5 64 6F 6E 65            MSG11   FCC   'done'
 1363:     E6C9 04                             FCB   EOT
 1364:     E6CA 63 68 6B 73 75 6D      MSG12   FCC   'chksum error'
           E6D0 20 65 72 72 6F 72 
 1365:     E6D6 04                             FCB   EOT
 1366:     E6D7 65 72 72 6F 72 20      MSG13   FCC   'error addr '
           E6DD 61 64 64 72 20 
 1367:     E6E2 04                             FCB   EOT
 1368:     E6E3 72 63 76 72 20 65      MSG14   FCC   'rcvr error'
           E6E9 72 72 6F 72 
 1369:     E6ED 04                             FCB   EOT
 1370:                                 
 1371:                                 **********
 1372:                                 *   break [-][<addr>] . . .
 1373:                                 * Modifies the breakpoint table.  More than
 1374:                                 * one argument can be entered on the command
 1375:                                 * line but the table will hold only 4 entries.
 1376:                                 * 4 types of arguments are implied above:
 1377:                                 * break           Prints table contents.
 1378:                                 * break <addr>    Inserts <addr>.
 1379:                                 * break -<addr>   Deletes <addr>.
 1380:                                 * break -         Clears all entries.
 1381:                                 **********
 1382:                                 * while 1
 1383:                                 *     a = wskip();
 1384:                                 *     switch(a)
 1385:                                 *          case(cr):
 1386:                                 *               bprint(); return;
 1387:                                 
 1388:     E6EE BD E306                BREAK   JSR  WSKIP
 1389:     E6F1 26 04                          BNE  BRKDEL     ;jump if not cr
 1390:     E6F3 BD E785                        JSR  BPRINT     ;print table
 1391:     E6F6 39                             RTS
 1392:                                 
 1393:                                 *          case("-"):
 1394:                                 *               incbuff(); readbuff();
 1395:                                 *               if(dchek(a))          /* look for wspac or cr */
 1396:                                 *                    bpclr();
 1397:                                 *                    breaksw;
 1398:                                 *               a = buffarg();
 1399:                                 *               if( !dchek(a) ) return(bad argument);
 1400:                                 *               b = bpsrch();
 1401:                                 *               if(b >= 0)
 1402:                                 *                    brktabl[b] = 0;
 1403:                                 *               breaksw;
 1404:                                 
 1405:     E6F7 81 2D                  BRKDEL  CMPA #'-'
 1406:     E6F9 26 31                          BNE  BRKDEF     ;jump if not -
 1407:     E6FB BD E2F8                        JSR  INCBUFF
 1408:     E6FE BD E2F1                        JSR  READBUFF
 1409:     E701 BD E321                        JSR  DCHEK
 1410:     E704 26 06                          BNE  BRKDEL1    ;jump if not delimeter
 1411:     E706 BD E1B8                        JSR  BPCLR      ;clear table
 1412:     E709 7E E6EE                        JMP  BREAK      ;do next argument
 1413:     E70C BD E23A                BRKDEL1 JSR  BUFFARG    ;get address to delete
 1414:     E70F BD E321                        JSR  DCHEK
 1415:     E712 27 07                          BEQ  BRKDEL2    ;jump if delimeter
 1416:     E714 CE E6AB                        LDX  #MSG9      ;"bad argument"
 1417:     E717 BD E518                        JSR  OUTSTRG
 1418:     E71A 39                             RTS
 1419:     E71B BD E794                BRKDEL2 JSR  BPSRCH     ;look for addr in table
 1420:     E71E 5D                             TSTB
 1421:     E71F 2B 08                          BMI  BRKDEL3    ;jump if not found
 1422:     E721 CE 009C                        LDX  #BRKTABL
 1423:     E724 3A                             ABX
 1424:     E725 6F 00                          CLR  0,X        ;clear entry
 1425:     E727 6F 01                          CLR  1,X
 1426:     E729 7E E6EE                BRKDEL3 JMP  BREAK      ;do next argument
 1427:                                 
 1428:                                 *          default:
 1429:                                 *               a = buffarg();
 1430:                                 *               if( !dchek(a) ) return(bad argument);
 1431:                                 *               b = bpsrch();
 1432:                                 *               if(b < 0)            /* not already in table */
 1433:                                 *                    x = shftreg;
 1434:                                 *                    shftreg = 0;
 1435:                                 *                    a = x[0]; x[0] = $3F
 1436:                                 *                    b = x[0]; x[0] = a;
 1437:                                 *                    if(b != $3F) return(rom);
 1438:                                 *                    b = bpsrch();   /* look for hole */
 1439:                                 *                    if(b >= 0) return(table full);
 1440:                                 *                    brktabl[b] = x;
 1441:                                 *               breaksw;
 1442:                                 
 1443:     E72C BD E23A                BRKDEF  JSR  BUFFARG    ;get argument
 1444:     E72F BD E321                        JSR  DCHEK
 1445:     E732 27 07                          BEQ  BRKDEF1    ;jump if delimiter
 1446:     E734 CE E6AB                        LDX  #MSG9      ;"bad argument"
 1447:     E737 BD E518                        JSR  OUTSTRG
 1448:     E73A 39                             RTS
 1449:     E73B BD E794                BRKDEF1 JSR  BPSRCH     ;look for entry in table
 1450:     E73E 5D                             TSTB
 1451:     E73F 2C AD                          BGE  BREAK      ;jump if already in table
 1452:                                 
 1453:     E741 DE 96                          LDX  SHFTREG     ;x = new entry addr
 1454:     E743 A6 00                          LDAA 0,X         ;save original contents
 1455:     E745 36                             PSHA
 1456:     E746 86 3F                          LDAA #SWI
 1457:     E748 BD E290                        JSR  WRITE       ;write to entry addr
 1458:     E74B E6 00                          LDAB 0,X         ;read back
 1459:     E74D 32                             PULA
 1460:     E74E BD E290                        JSR  WRITE       ;restore original
 1461:     E751 C1 3F                          CMPB #SWI
 1462:     E753 27 0C                          BEQ  BRKDEF2    ;jump if writes ok
 1463:     E755 DF B0                          STX  PTR1       ;save address
 1464:     E757 CE 00B0                        LDX  #PTR1
 1465:     E75A BD E4FC                        JSR  OUT2BSP     ;print address
 1466:     E75D BD E785                        JSR  BPRINT
 1467:     E760 39                             RTS
 1468:     E761 7F 0096                BRKDEF2 CLR  SHFTREG
 1469:     E764 7F 0097                        CLR  SHFTREG+1
 1470:     E767 3C                             PSHX
 1471:     E768 BD E794                        JSR  BPSRCH     ;look for 0 entry
 1472:     E76B 38                             PULX
 1473:     E76C 5D                             TSTB
 1474:     E76D 2A 0A                          BPL  BRKDEF3    ;jump if table not full
 1475:     E76F CE E693                        LDX  #MSG4      ;"full"
 1476:     E772 BD E518                        JSR  OUTSTRG
 1477:     E775 BD E785                        JSR  BPRINT
 1478:     E778 39                             RTS
 1479:     E779 18CE 009C              BRKDEF3 LDY  #BRKTABL
 1480:     E77D 183A                           ABY
 1481:     E77F CDEF 00                        STX  0,Y        ;put new entry in
 1482:     E782 7E E6EE                        JMP  BREAK      ;do next argument
 1483:                                 
 1484:                                 **********
 1485:                                 *   bprint() - print the contents of the table.
 1486:                                 **********
 1487:     E785 BD E508                BPRINT   JSR  OUTCRLF
 1488:     E788 CE 009C                         LDX  #BRKTABL
 1489:     E78B C6 04                           LDAB #4
 1490:     E78D BD E4FC                BPRINT1  JSR  OUT2BSP
 1491:     E790 5A                              DECB
 1492:     E791 2E FA                           BGT  BPRINT1     ;loop 4 times
 1493:     E793 39                              RTS
 1494:                                 
 1495:                                 **********
 1496:                                 *   bpsrch() - search table for address in
 1497:                                 * shftreg. Returns b = index to entry or
 1498:                                 * b = -1 if not found.
 1499:                                 **********
 1500:                                 *for(b=0; b=6; b=+2)
 1501:                                 *     x[] = brktabl + b;
 1502:                                 *     if(x[0] = shftreg)
 1503:                                 *          return(b);
 1504:                                 *return(-1);
 1505:                                 
 1506:     E794 5F                     BPSRCH   CLRB
 1507:     E795 CE 009C                BPSRCH1  LDX  #BRKTABL
 1508:     E798 3A                              ABX
 1509:     E799 EE 00                           LDX  0,X       ;get table entry
 1510:     E79B 9C 96                           CPX  SHFTREG
 1511:     E79D 26 01                           BNE  BPSRCH2   ;jump if no match
 1512:     E79F 39                              RTS
 1513:     E7A0 5C                     BPSRCH2  INCB
 1514:     E7A1 5C                              INCB
 1515:     E7A2 C1 06                           CMPB #$6
 1516:     E7A4 2F EF                           BLE  BPSRCH1  ;loop 4 times
 1517:     E7A6 C6 FF                           LDAB #$FF
 1518:     E7A8 39                              RTS
 1519:                                 
 1520:                                 
 1521:                                 **********
 1522:                                 *  bulk  - Bulk erase the eeprom not config.
 1523:                                 * bulkall - Bulk erase eeprom and config.
 1524:                                 *********
 1525:          =0000E7A9              BULK    EQU  *
 1526:     E7A9 DE 98                          LDX  STREE
 1527:     E7AB 20 03                          BRA  BULK1
 1528:     E7AD CE 103F                BULKALL LDX  #CONFIG
 1529:     E7B0 86 FF                  BULK1   LDAA #$FF
 1530:     E7B2 BD E2D4                        JSR  EEBULK
 1531:     E7B5 39                             RTS
 1532:                                 
 1533:                                 
 1534:                                 
 1535:                                 **********
 1536:                                 *  dump [<addr1> [<addr2>]]  - Dump memory
 1537:                                 * in 16 byte lines from <addr1> to <addr2>.
 1538:                                 *   Default starting address is "current
 1539:                                 * location" and default number of lines is 8.
 1540:                                 **********
 1541:                                 *ptr1 = ptrmem;        /* default start address */
 1542:                                 *ptr2 = ptr1 + $80;    /* default end address */
 1543:                                 *a = wskip();
 1544:                                 *if(a != cr)
 1545:                                 *     a = buffarg();
 1546:                                 *     if(countu1 = 0) return(bad argument);
 1547:                                 *     if( !dchek(a) ) return(bad argument);
 1548:                                 *     ptr1 = shftreg;
 1549:                                 *     ptr2 = ptr1 + $80;  /* default end address */
 1550:                                 *     a = wskip();
 1551:                                 *     if(a != cr)
 1552:                                 *          a = buffarg();
 1553:                                 *          if(countu1 = 0) return(bad argument);
 1554:                                 *          a = wskip();
 1555:                                 *          if(a != cr) return(bad argument);
 1556:                                 *          ptr2 = shftreg;
 1557:                                 
 1558:     E7B6 DE AA                  DUMP     LDX  PTRMEM    ;current location
 1559:     E7B8 DF B0                           STX  PTR1      ;default start
 1560:     E7BA C6 80                           LDAB #$80
 1561:     E7BC 3A                              ABX
 1562:     E7BD DF B2                           STX  PTR2      ;default end
 1563:     E7BF BD E306                         JSR  WSKIP
 1564:     E7C2 27 35                           BEQ  DUMP1     ;jump - no arguments
 1565:     E7C4 BD E23A                         JSR  BUFFARG   ;read argument
 1566:     E7C7 7D 00A8                         TST  COUNT
 1567:     E7CA 27 26                           BEQ  DUMPERR   ;jump if no argument
 1568:     E7CC BD E321                         JSR  DCHEK
 1569:     E7CF 26 21                           BNE  DUMPERR   ;jump if delimiter
 1570:     E7D1 DE 96                           LDX  SHFTREG
 1571:     E7D3 DF B0                           STX  PTR1
 1572:     E7D5 C6 80                           LDAB #$80
 1573:     E7D7 3A                              ABX
 1574:     E7D8 DF B2                           STX  PTR2      ;default end address
 1575:     E7DA BD E306                         JSR  WSKIP
 1576:     E7DD 27 1A                           BEQ  DUMP1     ;jump - 1 argument
 1577:     E7DF BD E23A                         JSR  BUFFARG   ;read argument
 1578:     E7E2 7D 00A8                         TST  COUNT
 1579:     E7E5 27 0B                           BEQ  DUMPERR   ;jump if no argument
 1580:     E7E7 BD E306                         JSR  WSKIP
 1581:     E7EA 26 06                           BNE  DUMPERR   ;jump if not cr
 1582:     E7EC DE 96                           LDX  SHFTREG
 1583:     E7EE DF B2                           STX  PTR2
 1584:     E7F0 20 07                           BRA  DUMP1     ;jump - 2 arguments
 1585:     E7F2 CE E6AB                DUMPERR  LDX  #MSG9     ;"bad argument"
 1586:     E7F5 BD E518                         JSR  OUTSTRG
 1587:     E7F8 39                              RTS
 1588:                                 
 1589:                                 *ptrmem = ptr1;
 1590:                                 *ptr1 = ptr1 & $fff0;
 1591:                                 
 1592:     E7F9 DC B0                  DUMP1    LDD  PTR1
 1593:     E7FB DD AA                           STD  PTRMEM    ;new current location
 1594:     E7FD C4 F0                           ANDB #$F0
 1595:     E7FF DD B0                           STD  PTR1      ;start dump at 16 byte boundary
 1596:                                 
 1597:                                 *** dump loop starts here ***
 1598:                                 *do:
 1599:                                 *     output address of first byte;
 1600:                                 
 1601:     E801 BD E508                DUMPLP   JSR  OUTCRLF
 1602:     E804 CE 00B0                         LDX  #PTR1
 1603:     E807 BD E4FC                         JSR  OUT2BSP   ;first address
 1604:                                 
 1605:                                 *     x = ptr1;
 1606:                                 *     for(b=0; b=16; b++)
 1607:                                 *          output contents;
 1608:                                 
 1609:     E80A DE B0                           LDX  PTR1      ;base address
 1610:     E80C 5F                              CLRB           ;loop counter
 1611:     E80D BD E4FF                DUMPDAT  JSR  OUT1BSP   ;hex value loop
 1612:     E810 5C                              INCB
 1613:     E811 C1 10                           CMPB #$10
 1614:     E813 2D F8                           BLT  DUMPDAT    ;loop 16 times
 1615:                                 
 1616:                                 *     x = ptr1;
 1617:                                 *     for(b=0; b=16; b++)
 1618:                                 *          a = x[b];
 1619:                                 *          if($7A < a < $20)  a = $20;
 1620:                                 *          output ascii contents;
 1621:                                 
 1622:     E815 5F                              CLRB           ;loop counter
 1623:     E816 DE B0                  DUMPASC  LDX  PTR1      ;base address
 1624:     E818 3A                              ABX
 1625:     E819 A6 00                           LDAA ,X        ;ascii value loop
 1626:     E81B 81 20                           CMPA #$20
 1627:     E81D 25 04                           BLO  DUMP3     ;jump if non printable
 1628:     E81F 81 7A                           CMPA #$7A
 1629:     E821 23 02                           BLS  DUMP4     ;jump if printable
 1630:     E823 86 20                  DUMP3    LDAA #$20      ;space for non printables
 1631:     E825 BD E3CA                DUMP4    JSR  OUTPUT    ;output ascii value
 1632:     E828 5C                              INCB
 1633:     E829 C1 10                           CMPB #$10
 1634:     E82B 2D E9                           BLT  DUMPASC   ;loop 16 times
 1635:                                 
 1636:                                 *     chkabrt();
 1637:                                 *     ptr1 = ptr1 + $10;
 1638:                                 *while(ptr1 <= ptr2);
 1639:                                 *return;
 1640:                                 
 1641:     E82D BD E329                         JSR  CHKABRT   ;check abort or wait
 1642:     E830 DC B0                           LDD  PTR1
 1643:     E832 C3 0010                         ADDD #$10      ;point to next 16 byte bound
 1644:     E835 DD B0                           STD  PTR1      ;update ptr1
 1645:     E837 1A93 B2                         CPD  PTR2
 1646:     E83A 22 0E                           BHI  DUMP5     ;quit if ptr1 > ptr2
 1647:     E83C 1A83 0000                       CPD  #$00      ;check wraparound at $ffff
 1648:     E840 26 BF                           BNE  DUMPLP    ;jump - no wraparound
 1649:     E842 DC B2                           LDD  PTR2
 1650:     E844 1A83 FFF0                       CPD  #$FFF0
 1651:     E848 25 B7                           BLO  DUMPLP    ;upper bound not at top
 1652:     E84A 39                     DUMP5    RTS            ;quit
 1653:                                 
 1654:                                 
 1655:                                 
 1656:                                 **********
 1657:                                 *   eemod [<addr1> [<addr2>]]
 1658:                                 * Modifies the eeprom address range.
 1659:                                 *  EEMOD                 -show ee address range
 1660:                                 *  EEMOD <addr1>         -set range to addr1 -> addr1+2k
 1661:                                 *  EEMOD <addr1> <addr2> -set range to addr1 -> addr2
 1662:                                 **********
 1663:                                 *if(<addr1>)
 1664:                                 *    stree = addr1;
 1665:                                 *    endee = addr1 + 2k bytes;
 1666:                                 *if(<addr2>)
 1667:                                 *    endee = addr2;
 1668:                                 *print(stree,endee);
 1669:          =0000E84B              EEMOD    EQU  *
 1670:     E84B BD E306                         JSR  WSKIP
 1671:     E84E 27 34                           BEQ  EEMOD2    ;jump - no arguments
 1672:     E850 BD E23A                         JSR  BUFFARG   ;read argument
 1673:     E853 7D 00A8                         TST  COUNT
 1674:     E856 27 3C                           BEQ  EEMODER   ;jump if no argument
 1675:     E858 BD E321                         JSR  DCHEK
 1676:     E85B 26 37                           BNE  EEMODER   ;jump if no delimeter
 1677:     E85D DC 96                           LDD  SHFTREG
 1678:     E85F DD B0                           STD  PTR1
 1679:     E861 C3 07FF                         ADDD #$07FF    ;add 2k bytes to stree
 1680:     E864 DD B2                           STD  PTR2      ;default endee address
 1681:     E866 BD E306                         JSR  WSKIP
 1682:     E869 27 11                           BEQ  EEMOD1    ;jump - 1 argument
 1683:     E86B BD E23A                         JSR  BUFFARG   ;read argument
 1684:     E86E 7D 00A8                         TST  COUNT
 1685:     E871 27 21                           BEQ  EEMODER   ;jump if no argument
 1686:     E873 BD E306                         JSR  WSKIP
 1687:     E876 26 1C                           BNE  EEMODER   ;jump if not cr
 1688:     E878 DE 96                           LDX  SHFTREG
 1689:     E87A DF B2                           STX  PTR2
 1690:     E87C DE B0                  EEMOD1   LDX  PTR1
 1691:     E87E DF 98                           STX  STREE     ;new stree address
 1692:     E880 DE B2                           LDX  PTR2
 1693:     E882 DF 9A                           STX  ENDEE     ;new endee address
 1694:     E884 BD E508                EEMOD2   JSR  OUTCRLF   ;display ee range
 1695:     E887 CE 0098                         LDX  #STREE
 1696:     E88A BD E4FC                         JSR  OUT2BSP
 1697:     E88D CE 009A                         LDX  #ENDEE
 1698:     E890 BD E4FC                         JSR  OUT2BSP
 1699:     E893 39                              RTS
 1700:                                 
 1701:     E894 CE E6AB                EEMODER  LDX  #MSG9     ;"bad argument"
 1702:     E897 BD E518                         JSR  OUTSTRG
 1703:     E89A 39                              RTS
 1704:                                 
 1705:                                 
 1706:                                 
 1707:                                 
 1708:                                 **********
 1709:                                 *  fill <addr1> <addr2> [<data>]  - Block fill
 1710:                                 *memory from addr1 to addr2 with data.  Data
 1711:                                 *defaults to $FF.
 1712:                                 **********
 1713:                                 *get addr1 and addr2
 1714:          =0000E89B              FILL    EQU  *
 1715:     E89B BD E306                        JSR  WSKIP
 1716:     E89E BD E23A                        JSR  BUFFARG
 1717:     E8A1 7D 00A8                        TST  COUNT
 1718:     E8A4 27 4F                          BEQ  FILLERR    ;jump if no argument
 1719:     E8A6 BD E316                        JSR  WCHEK
 1720:     E8A9 26 4A                          BNE  FILLERR    ;jump if bad argument
 1721:     E8AB DE 96                          LDX  SHFTREG
 1722:     E8AD DF B0                          STX  PTR1       ;address1
 1723:     E8AF BD E306                        JSR  WSKIP
 1724:     E8B2 BD E23A                        JSR  BUFFARG
 1725:     E8B5 7D 00A8                        TST  COUNT
 1726:     E8B8 27 3B                          BEQ  FILLERR    ;jump if no argument
 1727:     E8BA BD E321                        JSR  DCHEK
 1728:     E8BD 26 36                          BNE  FILLERR    ;jump if bad argument
 1729:     E8BF DE 96                          LDX  SHFTREG
 1730:     E8C1 DF B2                          STX  PTR2       ;address2
 1731:                                 
 1732:                                 *Get data if it exists
 1733:     E8C3 86 FF                          LDAA #$FF
 1734:     E8C5 97 C1                          STAA TMP2       ;default data
 1735:     E8C7 BD E306                        JSR  WSKIP
 1736:     E8CA 27 11                          BEQ  FILL1      ;jump if default data
 1737:     E8CC BD E23A                        JSR  BUFFARG
 1738:     E8CF 7D 00A8                        TST  COUNT
 1739:     E8D2 27 21                          BEQ  FILLERR    ;jump if no argument
 1740:     E8D4 BD E306                        JSR  WSKIP
 1741:     E8D7 26 1C                          BNE  FILLERR    ;jump if bad argument
 1742:     E8D9 96 97                          LDAA SHFTREG+1
 1743:     E8DB 97 C1                          STAA TMP2
 1744:                                 
 1745:                                 *while(ptr1 <= ptr2)
 1746:                                 *   *ptr1 = data
 1747:                                 *   if(*ptr1 != data) abort
 1748:                                 
 1749:          =0000E8DD              FILL1   EQU  *
 1750:     E8DD BD E329                        JSR  CHKABRT    ;check for abort
 1751:     E8E0 DE B0                          LDX  PTR1       ;starting address
 1752:     E8E2 96 C1                          LDAA TMP2       ;data
 1753:     E8E4 BD E290                        JSR  WRITE      ;write the data to x
 1754:     E8E7 A1 00                          CMPA 0,X
 1755:     E8E9 26 11                          BNE  FILLBAD    ;jump if no write
 1756:     E8EB 9C B2                          CPX  PTR2
 1757:     E8ED 27 05                          BEQ  FILL2      ;quit yet?
 1758:     E8EF 08                             INX
 1759:     E8F0 DF B0                          STX  PTR1
 1760:     E8F2 20 E9                          BRA  FILL1      ;loop
 1761:     E8F4 39                     FILL2   RTS
 1762:                                 
 1763:     E8F5 CE E6AB                FILLERR LDX  #MSG9     ;"bad argument"
 1764:     E8F8 BD E518                        JSR  OUTSTRG
 1765:     E8FB 39                             RTS
 1766:                                 
 1767:          =0000E8FC              FILLBAD EQU  *
 1768:     E8FC CE 00B0                        LDX  #PTR1     ;output bad address
 1769:     E8FF BD E4FC                        JSR  OUT2BSP
 1770:     E902 39                             RTS
 1771:                                 
 1772:                                 
 1773:                                 
 1774:                                 *******************************************
 1775:                                 *   MEMORY [<addr>]
 1776:                                 *   [<addr>]/
 1777:                                 * Opens memory and allows user to modify the
 1778:                                 *contents at <addr> or the last opened location.
 1779:                                 *    Subcommands:
 1780:                                 * [<data>]<cr>       - Close current location and exit.
 1781:                                 * [<data>]<lf><+>    - Close current and open next.
 1782:                                 * [<data>]<^><-><bs> - Close current and open previous.
 1783:                                 * [<data>]<sp>       - Close current and open next.
 1784:                                 * [<data>]</><=>     - Reopen current location.
 1785:                                 *     The contents of the current location is only
 1786:                                 *  changed if valid data is entered before each
 1787:                                 *  subcommand.
 1788:                                 * [<addr>]O - Compute relative offset from current
 1789:                                 *     location to <addr>.  The current location must
 1790:                                 *     be the address of the offset byte.
 1791:                                 **********
 1792:                                 *a = wskip();
 1793:                                 *if(a != cr)
 1794:                                 *     a = buffarg();
 1795:                                 *     if(a != cr) return(bad argument);
 1796:                                 *     if(countu1 != 0) ptrmem[] = shftreg;
 1797:                                 
 1798:     E903 BD E306                MEMORY   JSR  WSKIP
 1799:     E906 27 18                           BEQ  MEM1      ;jump if cr
 1800:     E908 BD E23A                         JSR  BUFFARG
 1801:     E90B BD E306                         JSR  WSKIP
 1802:     E90E 27 07                           BEQ  MSLASH    ;jump if cr
 1803:     E910 CE E6AB                         LDX  #MSG9     ;"bad argument"
 1804:     E913 BD E518                         JSR  OUTSTRG
 1805:     E916 39                              RTS
 1806:     E917 7D 00A8                MSLASH   TST  COUNT
 1807:     E91A 27 04                           BEQ  MEM1      ;jump if no argument
 1808:     E91C DE 96                           LDX  SHFTREG
 1809:     E91E DF AA                           STX  PTRMEM    ;update "current location"
 1810:                                 
 1811:                                 **********
 1812:                                 * Subcommands
 1813:                                 **********
 1814:                                 *outcrlf();
 1815:                                 *out2bsp(ptrmem[]);
 1816:                                 *out1bsp(ptrmem[0]);
 1817:                                 
 1818:     E920 BD E508                MEM1     JSR  OUTCRLF
 1819:     E923 CE 00AA                MEM2     LDX  #PTRMEM
 1820:     E926 BD E4FC                         JSR  OUT2BSP   ;output address
 1821:     E929 DE AA                  MEM3     LDX  PTRMEM
 1822:     E92B BD E4FF                         JSR  OUT1BSP   ;output contents
 1823:     E92E 7F 0096                         CLR  SHFTREG
 1824:     E931 7F 0097                         CLR  SHFTREG+1
 1825:                                 *while 1
 1826:                                 *a = termarg();
 1827:                                 *     switch(a)
 1828:                                 *          case(space):
 1829:                                 *             chgbyt();
 1830:                                 *             ptrmem[]++;
 1831:                                 *             if(ptrmem%16 == 0) start new line;
 1832:                                 *          case(linefeed | +):
 1833:                                 *             chgbyt();
 1834:                                 *             ptrmem[]++;
 1835:                                 *          case(up arrow | backspace | -):
 1836:                                 *               chgbyt();
 1837:                                 *               ptrmem[]--;
 1838:                                 *          case('/' | '='):
 1839:                                 *               chgbyt();
 1840:                                 *               outcrlf();
 1841:                                 *          case(O):
 1842:                                 *               d = ptrmem[0] - (shftreg);
 1843:                                 *               if($80 < d < $ff81)
 1844:                                 *                    print(out of range);
 1845:                                 *               countt1 = d-1;
 1846:                                 *               out1bsp(countt1);
 1847:                                 *          case(carriage return):
 1848:                                 *               chgbyt();
 1849:                                 *               return;
 1850:                                 *          default: return(command?)
 1851:                                 
 1852:     E934 BD E25D                MEM4     JSR  TERMARG
 1853:     E937 BD E1AD                         JSR  UPCASE
 1854:     E93A DE AA                           LDX  PTRMEM
 1855:     E93C 81 20                           CMPA #$20
 1856:     E93E 27 31                           BEQ  MEMSP     ;jump if space
 1857:     E940 81 0A                           CMPA #$0A
 1858:     E942 27 3E                           BEQ  MEMLF     ;jump if linefeed
 1859:     E944 81 2B                           CMPA #$2B
 1860:     E946 27 43                           BEQ  MEMPLUS   ;jump if +
 1861:     E948 81 5E                           CMPA #$5E
 1862:     E94A 27 48                           BEQ  MEMUA     ;jump if up arrow
 1863:     E94C 81 2D                           CMPA #$2D
 1864:     E94E 27 44                           BEQ  MEMUA     ;jump if -
 1865:     E950 81 08                           CMPA #$08
 1866:     E952 27 40                           BEQ  MEMUA     ;jump if backspace
 1867:     E954 81 2F                           CMPA #'/'
 1868:     E956 27 45                           BEQ  MEMSL     ;jump if /
 1869:     E958 81 3D                           CMPA #'='
 1870:     E95A 27 41                           BEQ  MEMSL     ;jump if =
 1871:     E95C 81 4F                           CMPA #'O'
 1872:     E95E 27 43                           BEQ  MEMOFF    ;jump if O
 1873:     E960 81 0D                           CMPA #$0D
 1874:     E962 27 6F                           BEQ  MEMCR     ;jump if carriage ret
 1875:     E964 81 2E                           CMPA #'.'
 1876:     E966 27 6E                           BEQ  MEMEND    ;jump if .
 1877:     E968 CE E6A2                         LDX  #MSG8     ;"command?"
 1878:     E96B BD E518                         JSR  OUTSTRG
 1879:     E96E 7E E920                         JMP  MEM1
 1880:     E971 BD E285                MEMSP    JSR  CHGBYT
 1881:     E974 08                              INX
 1882:     E975 DF AA                           STX  PTRMEM
 1883:     E977 8F                              XGDX
 1884:     E978 C4 0F                           ANDB #$0F
 1885:     E97A 27 03                           BEQ  MEMSP1    ;jump if mod16=0
 1886:     E97C 7E E929                         JMP  MEM3      ;continue same line
 1887:     E97F 7E E920                MEMSP1   JMP  MEM1      ;.. else start new line
 1888:     E982 BD E285                MEMLF    JSR  CHGBYT
 1889:     E985 08                              INX
 1890:     E986 DF AA                           STX  PTRMEM
 1891:     E988 7E E923                         JMP  MEM2      ;output next address
 1892:     E98B BD E285                MEMPLUS  JSR  CHGBYT
 1893:     E98E 08                              INX
 1894:     E98F DF AA                           STX  PTRMEM
 1895:     E991 7E E920                         JMP  MEM1      ;output cr, next address
 1896:     E994 BD E285                MEMUA    JSR  CHGBYT
 1897:     E997 09                              DEX
 1898:     E998 DF AA                           STX  PTRMEM
 1899:     E99A 7E E920                         JMP  MEM1      ;output cr, previous address
 1900:     E99D BD E285                MEMSL    JSR  CHGBYT
 1901:     E9A0 7E E920                         JMP  MEM1      ;output cr, same address
 1902:     E9A3 DC 96                  MEMOFF   LDD  SHFTREG   ;destination addr
 1903:     E9A5 93 AA                           SUBD PTRMEM
 1904:     E9A7 81 00                           CMPA #$0
 1905:     E9A9 26 06                           BNE  MEMOFF1   ;jump if not 0
 1906:     E9AB C1 80                           CMPB #$80
 1907:     E9AD 23 13                           BLS  MEMOFF3   ;jump if in range
 1908:     E9AF 20 08                           BRA  MEMOFF2   ;out of range
 1909:     E9B1 81 FF                  MEMOFF1  CMPA #$FF
 1910:     E9B3 26 04                           BNE  MEMOFF2   ;out of range
 1911:     E9B5 C1 81                           CMPB #$81
 1912:     E9B7 24 09                           BHS  MEMOFF3   ;in range
 1913:     E9B9 CE E68A                MEMOFF2  LDX  #MSG3     ;"Too long"
 1914:     E9BC BD E518                         JSR  OUTSTRG
 1915:     E9BF 7E E920                         JMP  MEM1      ;output cr, addr, contents
 1916:     E9C2 83 0001                MEMOFF3  SUBD #$1       ;b now has offset
 1917:     E9C5 D7 C3                           STAB TMP4
 1918:     E9C7 BD E502                         JSR  OUTSPAC
 1919:     E9CA CE 00C3                         LDX  #TMP4
 1920:     E9CD BD E4FF                         JSR  OUT1BSP   ;output offset
 1921:     E9D0 7E E920                         JMP  MEM1      ;output cr, addr, contents
 1922:     E9D3 BD E285                MEMCR    JSR  CHGBYT
 1923:     E9D6 39                     MEMEND   RTS            ;exit task
 1924:                                 
 1925:                                 
 1926:                                 **********
 1927:                                 *   move <src1> <src2> [<dest>]  - move
 1928:                                 *block at <src1> to <src2> to <dest>.
 1929:                                 *  Moves block 1 byte up if no <dest>.
 1930:                                 **********
 1931:                                 *a = buffarg();
 1932:                                 *if(countu1 = 0) return(bad argument);
 1933:                                 *if( !wchek(a) ) return(bad argument);
 1934:                                 *ptr1 = shftreg;         /* src1 */
 1935:                                 
 1936:          =0000E9D7              MOVE     EQU  *
 1937:     E9D7 BD E23A                         JSR  BUFFARG
 1938:     E9DA 7D 00A8                         TST  COUNT
 1939:     E9DD 27 2B                           BEQ  MOVERR    ;jump if no arg
 1940:     E9DF BD E316                         JSR  WCHEK
 1941:     E9E2 26 26                           BNE  MOVERR    ;jump if no delim
 1942:     E9E4 DE 96                           LDX  SHFTREG   ;src1
 1943:     E9E6 DF B0                           STX  PTR1
 1944:                                 
 1945:                                 *a = buffarg();
 1946:                                 *if(countu1 = 0) return(bad argument);
 1947:                                 *if( !dchek(a) ) return(bad argument);
 1948:                                 *ptr2 = shftreg;         /* src2 */
 1949:                                 
 1950:     E9E8 BD E23A                         JSR  BUFFARG
 1951:     E9EB 7D 00A8                         TST  COUNT
 1952:     E9EE 27 1A                           BEQ  MOVERR    ;jump if no arg
 1953:     E9F0 BD E321                         JSR  DCHEK
 1954:     E9F3 26 15                           BNE  MOVERR    ;jump if no delim
 1955:     E9F5 DE 96                           LDX  SHFTREG   ;src2
 1956:     E9F7 DF B2                           STX  PTR2
 1957:                                 
 1958:                                 *a = buffarg();
 1959:                                 *a = wskip();
 1960:                                 *if(a != cr) return(bad argument);
 1961:                                 *if(countu1 != 0) tmp2 = shftreg;  /* dest */
 1962:                                 *else tmp2 = ptr1 + 1;
 1963:                                 
 1964:     E9F9 BD E23A                         JSR  BUFFARG
 1965:     E9FC BD E306                         JSR  WSKIP
 1966:     E9FF 26 09                           BNE  MOVERR    ;jump if not cr
 1967:     EA01 7D 00A8                         TST  COUNT
 1968:     EA04 27 0B                           BEQ  MOVE1     ;jump if no arg
 1969:     EA06 DE 96                           LDX  SHFTREG   ;dest
 1970:     EA08 20 0A                           BRA  MOVE2
 1971:     EA0A CE E6AB                MOVERR   LDX  #MSG9     ;"bad argument"
 1972:     EA0D BD E518                         JSR  OUTSTRG
 1973:     EA10 39                              RTS
 1974:                                 
 1975:     EA11 DE B0                  MOVE1    LDX  PTR1
 1976:     EA13 08                              INX            ;default dest
 1977:     EA14 DF B4                  MOVE2    STX  PTR3
 1978:                                 
 1979:                                 *if(src1 < dest <= src2)
 1980:                                 *     dest = dest+(src2-src1);
 1981:                                 *     for(x = src2; x = src1; x--)
 1982:                                 *          dest[0]-- = x[0]--;
 1983:     EA16 DE B4                           LDX  PTR3        ;dest
 1984:     EA18 9C B0                           CPX  PTR1        ;src1
 1985:     EA1A 23 28                           BLS  MOVE3       ;jump if dest =< src1
 1986:     EA1C 9C B2                           CPX  PTR2        ;src2
 1987:     EA1E 22 24                           BHI  MOVE3       ;jump if dest > src2
 1988:     EA20 DC B2                           LDD  PTR2
 1989:     EA22 93 B0                           SUBD PTR1
 1990:     EA24 D3 B4                           ADDD PTR3
 1991:     EA26 DD B4                           STD  PTR3        ;dest = dest+(src2-src1)
 1992:     EA28 DE B2                           LDX  PTR2
 1993:     EA2A BD E329                MOVELP1  JSR  CHKABRT     ;check for abort
 1994:     EA2D A6 00                           LDAA ,X          ;char at src2
 1995:     EA2F 3C                              PSHX
 1996:     EA30 DE B4                           LDX  PTR3
 1997:     EA32 BD E290                         JSR  WRITE       ;write a to x
 1998:     EA35 A1 00                           CMPA 0,X
 1999:     EA37 26 28                           BNE  MOVEBAD     ;jump if no write
 2000:     EA39 09                              DEX
 2001:     EA3A DF B4                           STX  PTR3
 2002:     EA3C 38                              PULX
 2003:     EA3D 9C B0                           CPX  PTR1
 2004:     EA3F 27 1F                           BEQ  MOVRTS
 2005:     EA41 09                              DEX
 2006:     EA42 20 E6                           BRA  MOVELP1    ;Loop SRC2 - SRC1 times
 2007:                                 *
 2008:                                 * else
 2009:                                 *     for(x=src1; x=src2; x++)
 2010:                                 *          dest[0]++ = x[0]++;
 2011:                                 
 2012:                                 
 2013:     EA44 DE B0                  MOVE3    LDX  PTR1        ;srce1
 2014:     EA46 BD E329                MOVELP2  JSR  CHKABRT     ;check for abort
 2015:     EA49 A6 00                           LDAA ,X
 2016:     EA4B 3C                              PSHX
 2017:     EA4C DE B4                           LDX  PTR3        ;dest
 2018:     EA4E BD E290                         JSR  WRITE       ;write a to x
 2019:     EA51 A1 00                           CMPA 0,X
 2020:     EA53 26 0C                           BNE  MOVEBAD     ;jump if no write
 2021:     EA55 08                              INX
 2022:     EA56 DF B4                           STX  PTR3
 2023:     EA58 38                              PULX
 2024:     EA59 9C B2                           CPX  PTR2
 2025:     EA5B 27 03                           BEQ  MOVRTS
 2026:     EA5D 08                              INX
 2027:     EA5E 20 E6                           BRA  MOVELP2      ;Loop SRC2-SRC1 times
 2028:     EA60 39                     MOVRTS   RTS
 2029:                                 
 2030:     EA61 38                     MOVEBAD  PULX              ;restore stack
 2031:     EA62 CE 00B4                         LDX  #PTR3
 2032:     EA65 BD E4FC                         JSR  OUT2BSP      ;output bad address
 2033:     EA68 39                              RTS
 2034:                                 
 2035:                                 
 2036:                                 ****************
 2037:                                 *  assem(addr) -68HC11 line assembler/disassembler.
 2038:                                 *       This routine will disassemble the opcode at
 2039:                                 *<addr> and then allow the user to enter a line for
 2040:                                 *assembly. Rules for assembly are as follows:
 2041:                                 * -A '#' sign indicates immediate addressing.
 2042:                                 * -A ',' (comma) indicates indexed addressing
 2043:                                 *       and the next character must be X or Y.
 2044:                                 * -All arguments are assumed to be hex and the
 2045:                                 *       '$' sign shouldn't be used.
 2046:                                 * -Arguments should be separated by 1 or more
 2047:                                 *       spaces or tabs.
 2048:                                 * -Any input after the required number of
 2049:                                 *       arguments is ignored.
 2050:                                 * -Upper or lower case makes no difference.
 2051:                                 *
 2052:                                 *       To signify end of input line, the following
 2053:                                 *commands are available and have the indicated action:
 2054:                                 *   <cr>      - Finds the next opcode for
 2055:                                 *          assembly.  If there was no assembly input,
 2056:                                 *          the next opcode disassembled is retrieved
 2057:                                 *          from the disassembler.
 2058:                                 *   <lf><+>   - Works the same as carriage return
 2059:                                 *          except if there was no assembly input, the
 2060:                                 *          <addr> is incremented and the next <addr> is
 2061:                                 *          disassembled.
 2062:                                 *    <^><->   - Decrements <addr> and the previous
 2063:                                 *          address is then disassembled.
 2064:                                 *    </><=>   - Redisassembles the current address.
 2065:                                 *
 2066:                                 *       To exit the assembler use CONTROL A or . (period).
 2067:                                 *Of course control X and DEL will also allow you to abort.
 2068:                                 *** Equates for assembler ***
 2069:          =00000000              PAGE1   EQU  $00     ;values for page opcodes
 2070:          =00000018              PAGE2   EQU  $18
 2071:          =0000001A              PAGE3   EQU  $1A
 2072:          =000000CD              PAGE4   EQU  $CD
 2073:          =00000000              IMMED   EQU  $0      ;addressing modes
 2074:          =00000001              INDX    EQU  $1
 2075:          =00000002              INDY    EQU  $2
 2076:          =00000003              LIMMED  EQU  $3      ;(long immediate)
 2077:          =00000004              OTHER   EQU  $4
 2078:                                 
 2079:                                 *** Rename variables for assem/disassem ***
 2080:          =000000C1              AMODE   EQU  TMP2    ;addressing mode
 2081:          =000000C2              YFLAG   EQU  TMP3
 2082:          =000000C3              PNORM   EQU  TMP4    ;page for normal opcode
 2083:          =000000BE              OLDPC   EQU  PTR8
 2084:          =000000B0              PC      EQU  PTR1    ;program counter
 2085:          =000000B2              PX      EQU  PTR2    ;page for x indexed
 2086:          =000000B3              PY      EQU  PTR2+1  ;page for y indexed
 2087:          =000000B4              BASEOP  EQU  PTR3    ;base opcode
 2088:          =000000B5              CLASS   EQU  PTR3+1  ;class
 2089:          =000000B6              DISPC   EQU  PTR4    ;pc for disassembler
 2090:          =000000B8              BRADDR  EQU  PTR5    ;relative branch offset
 2091:          =000000BA              MNEPTR  EQU  PTR6    ;pointer to table for dis
 2092:          =000000BC              ASSCOMM EQU  PTR7    ;subcommand for assembler
 2093:                                 
 2094:                                 *** Error messages for assembler ***
 2095:     EA69 EA7B                   MSGDIR  FDB  MSGA1   ;message table index
 2096:     EA6B EA8E                           FDB  MSGA2
 2097:     EA6D EAA1                           FDB  MSGA3
 2098:     EA6F EAB0                           FDB  MSGA4
 2099:     EA71 EABD                           FDB  MSGA5
 2100:     EA73 EAD0                           FDB  MSGA6
 2101:     EA75 EAE8                           FDB  MSGA7
 2102:     EA77 EB03                           FDB  MSGA8
 2103:     EA79 EB10                           FDB  MSGA9
 2104:     EA7B 49 6D 6D 65 64 20      MSGA1   FCC  'Immed mode illegal'
           EA81 6D 6F 64 65 20 69 
           EA87 6C 6C 65 67 61 6C 
 2105:     EA8D 04                             FCB  EOT
 2106:     EA8E 45 72 72 6F 72 20      MSGA2   FCC  'Error in Mne table'
           EA94 69 6E 20 4D 6E 65 
           EA9A 20 74 61 62 6C 65 
 2107:     EAA0 04                             FCB  EOT
 2108:     EAA1 49 6C 6C 65 67 61      MSGA3   FCC  'Illegal bit op'
           EAA7 6C 20 62 69 74 20 
           EAAD 6F 70 
 2109:     EAAF 04                             FCB  EOT
 2110:     EAB0 42 61 64 20 61 72      MSGA4   FCC  'Bad argument'
           EAB6 67 75 6D 65 6E 74 
 2111:     EABC 04                             FCB  EOT
 2112:     EABD 4D 6E 65 6D 6F 6E      MSGA5   FCC  'Mnemonic not found'
           EAC3 69 63 20 6E 6F 74 
           EAC9 20 66 6F 75 6E 64 
 2113:     EACF 04                             FCB  EOT
 2114:     EAD0 55 6E 6B 6E 6F 77      MSGA6   FCC  'Unknown addressing mode'
           EAD6 6E 20 61 64 64 72 
           EADC 65 73 73 69 6E 67 
           EAE2 20 6D 6F 64 65 
 2115:     EAE7 04                             FCB  EOT
 2116:     EAE8 49 6E 64 65 78 65      MSGA7   FCC  'Indexed addressing assumed'
           EAEE 64 20 61 64 64 72 
           EAF4 65 73 73 69 6E 67 
           EAFA 20 61 73 73 75 6D 
           EB00 65 64 
 2117:     EB02 04                             FCB  EOT
 2118:     EB03 53 79 6E 74 61 78      MSGA8   FCC  'Syntax error'
           EB09 20 65 72 72 6F 72 
 2119:     EB0F 04                             FCB  EOT
 2120:     EB10 42 72 61 6E 63 68      MSGA9   FCC  'Branch out of range'
           EB16 20 6F 75 74 20 6F 
           EB1C 66 20 72 61 6E 67 
           EB22 65 
 2121:     EB23 04                             FCB  EOT
 2122:                                 
 2123:                                 **********
 2124:                                 *oldpc = rambase;
 2125:                                 *a = wskip();
 2126:                                 *if (a != cr)
 2127:                                 *   buffarg()
 2128:                                 *   a = wskip();
 2129:                                 *   if ( a != cr ) return(error);
 2130:                                 *   oldpc = a;
 2131:          =0000EB24              ASSEM   EQU  *
 2132:     EB24 CE 0000                        LDX  #RAMBS
 2133:     EB27 DF BE                          STX  OLDPC
 2134:     EB29 BD E306                        JSR  WSKIP
 2135:     EB2C 27 13                          BEQ  ASSLOOP ;jump if no argument
 2136:     EB2E BD E23A                        JSR  BUFFARG
 2137:     EB31 BD E306                        JSR  WSKIP
 2138:     EB34 27 07                          BEQ  ASSEM1  ;jump if argument ok
 2139:     EB36 CE EAB0                        LDX  #MSGA4  ;"bad argument"
 2140:     EB39 BD E518                        JSR  OUTSTRG
 2141:     EB3C 39                             RTS
 2142:     EB3D DE 96                  ASSEM1  LDX  SHFTREG
 2143:     EB3F DF BE                          STX  OLDPC
 2144:                                 
 2145:                                 *repeat
 2146:                                 *  pc = oldpc;
 2147:                                 *  out2bsp(pc);
 2148:                                 *  disassem();
 2149:                                 *  a=readln();
 2150:                                 *  asscomm = a;  /* save command */
 2151:                                 *  if(a == [^,+,-,/,=]) outcrlf;
 2152:                                 *  if(a == 0) return(error);
 2153:                                 
 2154:     EB41 DE BE                  ASSLOOP LDX  OLDPC
 2155:     EB43 DF B0                          STX  PC
 2156:     EB45 BD E508                        JSR  OUTCRLF
 2157:     EB48 CE 00B0                        LDX  #PC
 2158:     EB4B BD E4FC                        JSR  OUT2BSP   ;output the address
 2159:     EB4E BD F376                        JSR  DISASSM   ;disassemble opcode
 2160:     EB51 BD E538                        JSR  TABTO
 2161:     EB54 86 3E                          LDAA #PROMPT   ;prompt user
 2162:     EB56 BD E4EC                        JSR  OUTA      ;output prompt character
 2163:     EB59 BD EC05                        JSR  READLN    ;read input for assembly
 2164:     EB5C 97 BC                          STAA ASSCOMM
 2165:     EB5E 81 5E                          CMPA #'^'
 2166:     EB60 27 15                          BEQ  ASSLP0    ;jump if '^'
 2167:     EB62 81 2B                          CMPA #'+'
 2168:     EB64 27 11                          BEQ  ASSLP0    ;jump if '+'
 2169:     EB66 81 2D                          CMPA #'-'
 2170:     EB68 27 0D                          BEQ  ASSLP0    ;jump if '-'
 2171:     EB6A 81 2F                          CMPA #'/'
 2172:     EB6C 27 09                          BEQ  ASSLP0    ;jump if '/'
 2173:     EB6E 81 3D                          CMPA #'='
 2174:     EB70 27 05                          BEQ  ASSLP0    ;jump if '='
 2175:     EB72 81 00                          CMPA #$00
 2176:     EB74 26 04                          BNE  ASSLP1    ;jump if none of above
 2177:     EB76 39                             RTS            ;return if bad input
 2178:     EB77 BD E508                ASSLP0  JSR  OUTCRLF
 2179:          =0000EB7A              ASSLP1  EQU  *         ;come here for cr or lf
 2180:     EB7A BD E502                        JSR  OUTSPAC
 2181:     EB7D BD E502                        JSR  OUTSPAC
 2182:     EB80 BD E502                        JSR  OUTSPAC
 2183:     EB83 BD E502                        JSR  OUTSPAC
 2184:     EB86 BD E502                        JSR  OUTSPAC
 2185:                                 
 2186:                                 *  b = parse(input); /* get mnemonic */
 2187:                                 *  if(b > 5) print("not found"); asscomm='/';
 2188:                                 *  elseif(b >= 1)
 2189:                                 *     msrch();
 2190:                                 *     if(class==$FF)
 2191:                                 *        print("not found"); asscomm='/';
 2192:                                 *     else
 2193:                                 *        a = doop(opcode,class);
 2194:                                 *        if(a == 0) dispc=0;
 2195:                                 *        else process error; asscomm='/';
 2196:                                 
 2197:     EB89 BD EC4E                        JSR  PARSE
 2198:     EB8C C1 05                          CMPB #$5
 2199:     EB8E 2F 08                          BLE  ASSLP2  ;jump if mnemonic <= 5 chars
 2200:     EB90 CE EABD                        LDX  #MSGA5  ;"mnemonic not found"
 2201:     EB93 BD E518                        JSR  OUTSTRG
 2202:     EB96 20 2F                          BRA  ASSLP5
 2203:          =0000EB98              ASSLP2  EQU  *
 2204:     EB98 C1 00                          CMPB #$0
 2205:     EB9A 27 2E                          BEQ  ASSLP10 ;jump if no input
 2206:     EB9C BD EC95                        JSR  MSRCH
 2207:     EB9F 96 B5                          LDAA CLASS
 2208:     EBA1 81 FF                          CMPA #$FF
 2209:     EBA3 26 08                          BNE  ASSLP3
 2210:     EBA5 CE EABD                        LDX  #MSGA5  ;"mnemonic not found"
 2211:     EBA8 BD E518                        JSR  OUTSTRG
 2212:     EBAB 20 1A                          BRA  ASSLP5
 2213:     EBAD BD ECCD                ASSLP3  JSR  DOOP
 2214:     EBB0 81 00                          CMPA #$00
 2215:     EBB2 26 07                          BNE  ASSLP4  ;jump if doop error
 2216:     EBB4 CE 0000                        LDX  #$00
 2217:     EBB7 DF B6                          STX  DISPC   ;indicate good assembly
 2218:     EBB9 20 0F                          BRA  ASSLP10
 2219:     EBBB 4A                     ASSLP4  DECA         ;a = error message index
 2220:     EBBC 16                             TAB
 2221:     EBBD CE EA69                        LDX  #MSGDIR
 2222:     EBC0 3A                             ABX
 2223:     EBC1 3A                             ABX
 2224:     EBC2 EE 00                          LDX  0,X
 2225:     EBC4 BD E518                        JSR  OUTSTRG ;output error message
 2226:     EBC7 7F 00BC                ASSLP5  CLR  ASSCOMM ;error command
 2227:                                 
 2228:                                 *  /* compute next address - asscomm holds subcommand
 2229:                                 *     and dispc indicates if valid assembly occured. */
 2230:                                 *  if(asscomm== ^ or -) oldpc--;
 2231:                                 *  if(asscomm==(lf or + or cr)
 2232:                                 *     if(dispc==0) oldpc=pc;   /* good assembly */
 2233:                                 *     else
 2234:                                 *        if(asscomm==lf or +) dispc= ++oldpc;
 2235:                                 *        oldpc=dispc;
 2236:                                 *until(eot)
 2237:          =0000EBCA              ASSLP10 EQU  *
 2238:     EBCA 96 BC                          LDAA ASSCOMM
 2239:     EBCC 81 5E                          CMPA #'^'
 2240:     EBCE 27 04                          BEQ  ASSLPA     ;jump if '^'
 2241:     EBD0 81 2D                          CMPA #'-'
 2242:     EBD2 26 07                          BNE  ASSLP11    ;jump not '-'
 2243:     EBD4 DE BE                  ASSLPA  LDX  OLDPC      ;back up for '^' or '-'
 2244:     EBD6 09                             DEX
 2245:     EBD7 DF BE                          STX  OLDPC
 2246:     EBD9 20 27                          BRA  ASSLP15
 2247:     EBDB 81 0A                  ASSLP11 CMPA #$0A
 2248:     EBDD 27 08                          BEQ  ASSLP12    ;jump if linefeed
 2249:     EBDF 81 2B                          CMPA #'+'
 2250:     EBE1 27 04                          BEQ  ASSLP12    ;jump if '+'
 2251:     EBE3 81 0D                          CMPA #$0D
 2252:     EBE5 26 1B                          BNE  ASSLP15    ;jump if not cr
 2253:     EBE7 DE B6                  ASSLP12 LDX  DISPC
 2254:     EBE9 26 06                          BNE  ASSLP13    ;jump if dispc != 0
 2255:     EBEB DE B0                          LDX  PC
 2256:     EBED DF BE                          STX  OLDPC
 2257:     EBEF 20 11                          BRA  ASSLP15
 2258:     EBF1 81 0A                  ASSLP13 CMPA #$0A
 2259:     EBF3 27 04                          BEQ  ASSLPB    ;jump not lf
 2260:     EBF5 81 2B                          CMPA #'+'
 2261:     EBF7 26 05                          BNE  ASSLP14   ;jump not lf or '+'
 2262:     EBF9 DE BE                  ASSLPB  LDX  OLDPC
 2263:     EBFB 08                             INX
 2264:     EBFC DF B6                          STX  DISPC
 2265:     EBFE DE B6                  ASSLP14 LDX  DISPC
 2266:     EC00 DF BE                          STX  OLDPC
 2267:     EC02 7E EB41                ASSLP15 JMP  ASSLOOP
 2268:                                 
 2269:                                 ****************
 2270:                                 *  readln() --- Read input from terminal into buffer
 2271:                                 * until a command character is read (cr,lf,/,^).
 2272:                                 * If more chars are typed than the buffer will hold,
 2273:                                 * the extra characters are overwritten on the end.
 2274:                                 *  On exit: b=number of chars read, a=0 if quit,
 2275:                                 * else a=next command.
 2276:                                 ****************
 2277:                                 *for(b==0;b<=bufflng;b++) inbuff[b] = cr;
 2278:                                 
 2279:     EC05 5F                     READLN  CLRB
 2280:     EC06 86 0D                          LDAA #$0D    ;carriage ret
 2281:     EC08 CE 006B                RLN0    LDX  #INBUFF
 2282:     EC0B 3A                             ABX
 2283:     EC0C A7 00                          STAA 0,X     ;initialize input buffer
 2284:     EC0E 5C                             INCB
 2285:     EC0F C1 23                          CMPB #BUFFLNG
 2286:     EC11 2D F5                          BLT  RLN0
 2287:                                 *b=0;
 2288:                                 *repeat
 2289:                                 *  if(a == (ctla, cntlc, cntld, cntlx, del))
 2290:                                 *     return(a=0);
 2291:                                 *  if(a == backspace)
 2292:                                 *     if(b > 0) b--;
 2293:                                 *     else b=0;
 2294:                                 *  else  inbuff[b] = upcase(a);
 2295:                                 *  if(b < bufflng) b++;
 2296:                                 *until (a == [cr,lf,+,^,-,/,=])
 2297:                                 *return(a);
 2298:                                 
 2299:     EC13 5F                             CLRB
 2300:     EC14 BD E544                RLN1    JSR  INCHAR
 2301:     EC17 81 7F                          CMPA #DEL    ;Delete
 2302:     EC19 27 31                          BEQ  RLNQUIT
 2303:     EC1B 81 18                          CMPA #CTLX   ;Control X
 2304:     EC1D 27 2D                          BEQ  RLNQUIT
 2305:     EC1F 81 01                          CMPA #CTLA   ;Control A
 2306:     EC21 27 29                          BEQ  RLNQUIT
 2307:     EC23 81 2E                          CMPA #$2E    ;Period
 2308:     EC25 27 25                          BEQ  RLNQUIT
 2309:     EC27 81 03                          CMPA #$03    ;Control C
 2310:     EC29 27 21                          BEQ  RLNQUIT
 2311:     EC2B 81 04                          CMPA #$04    ;Control D
 2312:     EC2D 27 1D                          BEQ  RLNQUIT
 2313:     EC2F 81 08                          CMPA #$08    ;backspace
 2314:     EC31 26 05                          BNE  RLN2
 2315:     EC33 5A                             DECB
 2316:     EC34 2E DE                          BGT  RLN1
 2317:     EC36 20 CD                          BRA  READLN  ;start over
 2318:     EC38 CE 006B                RLN2    LDX  #INBUFF
 2319:     EC3B 3A                             ABX
 2320:     EC3C BD E1AD                        JSR  UPCASE
 2321:     EC3F A7 00                          STAA 0,X     ;put char in buffer
 2322:     EC41 C1 23                          CMPB #BUFFLNG        ;max buffer length
 2323:     EC43 2C 01                          BGE  RLN3    ;jump if buffer full
 2324:     EC45 5C                             INCB         ;move buffer pointer
 2325:     EC46 BD EC7A                RLN3    JSR  ASSCHEK ;check for subcommand
 2326:     EC49 26 C9                          BNE  RLN1
 2327:     EC4B 39                             RTS
 2328:     EC4C 4F                     RLNQUIT CLRA         ;quit
 2329:     EC4D 39                             RTS          ;return
 2330:                                 
 2331:                                 
 2332:                                 **********
 2333:                                 *  parse() -parse out the mnemonic from INBUFF
 2334:                                 * to COMBUFF. on exit: b=number of chars parsed.
 2335:                                 **********
 2336:                                 *combuff[3] = <space>;   initialize 4th character to space.
 2337:                                 *ptrbuff[] = inbuff[];
 2338:                                 *a=wskip();
 2339:                                 *for (b = 0; b = 5; b++)
 2340:                                 *   a=readbuff(); incbuff();
 2341:                                 *   if (a = (cr,lf,^,/,wspace)) return(b);
 2342:                                 *   combuff[b] = upcase(a);
 2343:                                 *return(b);
 2344:                                 
 2345:     EC4E 86 20                  PARSE   LDAA #$20
 2346:     EC50 97 91                          STAA COMBUFF+3
 2347:     EC52 CE 006B                        LDX  #INBUFF         ;initialize buffer ptr
 2348:     EC55 DF AE                          STX  PTR0
 2349:     EC57 BD E306                        JSR  WSKIP           ;find first character
 2350:     EC5A 5F                             CLRB
 2351:     EC5B BD E2F1                PARSLP  JSR  READBUFF        ;read character
 2352:     EC5E BD E2F8                        JSR  INCBUFF
 2353:     EC61 BD E316                        JSR  WCHEK
 2354:     EC64 27 13                          BEQ  PARSRT          ;jump if whitespace
 2355:     EC66 BD EC7A                        JSR  ASSCHEK
 2356:     EC69 27 0E                          BEQ  PARSRT          ;jump if end of line
 2357:     EC6B BD E1AD                        JSR  UPCASE          ;convert to upper case
 2358:     EC6E CE 008E                        LDX  #COMBUFF
 2359:     EC71 3A                             ABX
 2360:     EC72 A7 00                          STAA 0,X             ;store in combuff
 2361:     EC74 5C                             INCB
 2362:     EC75 C1 05                          CMPB #$5
 2363:     EC77 2F E2                          BLE  PARSLP          ;loop 6 times
 2364:     EC79 39                     PARSRT  RTS
 2365:                                 
 2366:                                 
 2367:                                 ****************
 2368:                                 *  asschek() -perform compares for
 2369:                                 * lf, cr, ^, /, +, -, =
 2370:                                 ****************
 2371:     EC7A 81 0A                  ASSCHEK CMPA #$0A    ;linefeed
 2372:     EC7C 27 16                          BEQ  ASSCHK1
 2373:     EC7E 81 0D                          CMPA #$0D    ;carriage ret
 2374:     EC80 27 12                          BEQ  ASSCHK1
 2375:     EC82 81 5E                          CMPA #'^'    ;up arrow
 2376:     EC84 27 0E                          BEQ  ASSCHK1
 2377:     EC86 81 2F                          CMPA #'/'    ;slash
 2378:     EC88 27 0A                          BEQ  ASSCHK1
 2379:     EC8A 81 2B                          CMPA #'+'    ;plus
 2380:     EC8C 27 06                          BEQ  ASSCHK1
 2381:     EC8E 81 2D                          CMPA #'-'    ;minus
 2382:     EC90 27 02                          BEQ  ASSCHK1
 2383:     EC92 81 3D                          CMPA #'='    ;equals
 2384:     EC94 39                     ASSCHK1 RTS
 2385:                                 
 2386:                                 
 2387:                                 *********
 2388:                                 *  msrch() --- Search MNETABL for mnemonic in COMBUFF.
 2389:                                 *stores base opcode at baseop and class at class.
 2390:                                 *  Class = FF if not found.
 2391:                                 **********
 2392:                                 *while ( != EOF )
 2393:                                 *   if (COMBUFF[0-3] = MNETABL[0-3])
 2394:                                 *      return(MNETABL[4],MNETABL[5]);
 2395:                                 *   else *MNETABL =+ 6
 2396:                                 
 2397:     EC95 CE EFF7                MSRCH   LDX  #MNETABL        ;pointer to mnemonic table
 2398:     EC98 18CE 008E                      LDY  #COMBUFF        ;pointer to string
 2399:     EC9C 20 03                          BRA  MSRCH1
 2400:          =0000EC9E              MSNEXT  EQU  *
 2401:     EC9E C6 06                          LDAB #6
 2402:     ECA0 3A                             ABX                  ;point to next table entry
 2403:     ECA1 A6 00                  MSRCH1  LDAA 0,X             ;read table
 2404:     ECA3 81 04                          CMPA #EOT
 2405:     ECA5 26 05                          BNE  MSRCH2          ;jump if not end of table
 2406:     ECA7 86 FF                          LDAA #$FF
 2407:     ECA9 97 B5                          STAA CLASS           ;FF = not in table
 2408:     ECAB 39                             RTS
 2409:     ECAC 18A1 00                MSRCH2  CMPA 0,Y             ;op[0] = tabl[0] ?
 2410:     ECAF 26 ED                          BNE  MSNEXT
 2411:     ECB1 A6 01                          LDAA 1,X
 2412:     ECB3 18A1 01                        CMPA 1,Y             ;op[1] = tabl[1] ?
 2413:     ECB6 26 E6                          BNE  MSNEXT
 2414:     ECB8 A6 02                          LDAA 2,X
 2415:     ECBA 18A1 02                        CMPA 2,Y             ;op[2] = tabl[2] ?
 2416:     ECBD 26 DF                          BNE  MSNEXT
 2417:     ECBF A6 03                          LDAA 3,X
 2418:     ECC1 18A1 03                        CMPA 3,Y             ;op[2] = tabl[2] ?
 2419:     ECC4 26 D8                          BNE  MSNEXT
 2420:     ECC6 EC 04                          LDD  4,X             ;opcode, class
 2421:     ECC8 97 B4                          STAA BASEOP
 2422:     ECCA D7 B5                          STAB CLASS
 2423:     ECCC 39                             RTS
 2424:                                 
 2425:                                 **********
 2426:                                 **   doop(baseop,class) --- process mnemonic.
 2427:                                 **   on exit: a=error code corresponding to error
 2428:                                 **                                     messages.
 2429:                                 **********
 2430:                                 *amode = OTHER; /* addressing mode */
 2431:                                 *yflag = 0;     /* ynoimm, nlimm, and cpd flag */
 2432:                                 *x[] = ptrbuff[]
 2433:                                 
 2434:          =0000ECCD              DOOP    EQU  *
 2435:     ECCD 86 04                          LDAA #OTHER
 2436:     ECCF 97 C1                          STAA AMODE   ;mode
 2437:     ECD1 7F 00C2                        CLR  YFLAG
 2438:     ECD4 DE AE                          LDX  PTR0
 2439:                                 
 2440:                                 *while (*x != end of buffer)
 2441:                                 *   if (x[0]++ == ',')
 2442:                                 *      if (x[0] == 'y') amode = INDY;
 2443:                                 *      else amod = INDX;
 2444:                                 *      break;
 2445:                                 *a = wskip()
 2446:                                 *if( a == '#' ) amode = IMMED;
 2447:                                 
 2448:     ECD6 8C 008E                DOPLP1  CPX  #ENDBUFF ;(end of buffer)
 2449:     ECD9 27 1B                          BEQ  DOOP1   ;jump if end of buffer
 2450:     ECDB EC 00                          LDD  0,X     ;read 2 chars from buffer
 2451:     ECDD 08                             INX          ;move pointer
 2452:     ECDE 81 2C                          CMPA #','
 2453:     ECE0 26 F4                          BNE  DOPLP1
 2454:     ECE2 C1 59                          CMPB #'Y'    ;look for ",y"
 2455:     ECE4 26 06                          BNE  DOPLP2
 2456:     ECE6 86 02                          LDAA #INDY
 2457:     ECE8 97 C1                          STAA AMODE
 2458:     ECEA 20 0A                          BRA  DOOP1
 2459:     ECEC C1 58                  DOPLP2  CMPB #'X'    ;look for ",x"
 2460:     ECEE 26 06                          BNE  DOOP1   ;jump if not x
 2461:     ECF0 86 01                          LDAA #INDX
 2462:     ECF2 97 C1                          STAA AMODE
 2463:     ECF4 20 00                          BRA  DOOP1
 2464:     ECF6 BD E306                DOOP1   JSR  WSKIP
 2465:     ECF9 81 23                          CMPA #'#'    ;look for immediate mode
 2466:     ECFB 26 07                          BNE  DOOP2
 2467:     ECFD BD E2F8                        JSR  INCBUFF ;point at argument
 2468:     ED00 86 00                          LDAA #IMMED
 2469:     ED02 97 C1                          STAA AMODE
 2470:          =0000ED04              DOOP2   EQU  *
 2471:                                 
 2472:                                 *switch(class)
 2473:     ED04 D6 B5                          LDAB CLASS
 2474:     ED06 C1 02                          CMPB #P2INH
 2475:     ED08 26 03                          BNE  DOSW1
 2476:     ED0A 7E ED6B                        JMP  DOP2I
 2477:     ED0D C1 01                  DOSW1   CMPB #INH
 2478:     ED0F 26 03                          BNE  DOSW2
 2479:     ED11 7E ED70                        JMP  DOINH
 2480:     ED14 C1 05                  DOSW2   CMPB #REL
 2481:     ED16 26 03                          BNE  DOSW3
 2482:     ED18 7E ED77                        JMP  DOREL
 2483:     ED1B C1 08                  DOSW3   CMPB #LIMM
 2484:     ED1D 26 03                          BNE  DOSW4
 2485:     ED1F 7E EDA6                        JMP  DOLIM
 2486:     ED22 C1 07                  DOSW4   CMPB #NIMM
 2487:     ED24 26 03                          BNE  DOSW5
 2488:     ED26 7E EDB0                        JMP  DONOI
 2489:     ED29 C1 03                  DOSW5   CMPB #GEN
 2490:     ED2B 26 03                          BNE  DOSW6
 2491:     ED2D 7E EDB9                        JMP  DOGENE
 2492:     ED30 C1 04                  DOSW6   CMPB #GRP2
 2493:     ED32 26 03                          BNE  DOSW7
 2494:     ED34 7E EDC7                        JMP  DOGRP
 2495:     ED37 C1 15                  DOSW7   CMPB #CPD
 2496:     ED39 26 03                          BNE  DOSW8
 2497:     ED3B 7E EDF9                        JMP  DOCPD
 2498:     ED3E C1 10                  DOSW8   CMPB #XNIMM
 2499:     ED40 26 03                          BNE  DOSW9
 2500:     ED42 7E EE1A                        JMP  DOXNOI
 2501:     ED45 C1 09                  DOSW9   CMPB #XLIMM
 2502:     ED47 26 03                          BNE  DOSW10
 2503:     ED49 7E EE23                        JMP  DOXLI
 2504:     ED4C C1 12                  DOSW10  CMPB #YNIMM
 2505:     ED4E 26 03                          BNE  DOSW11
 2506:     ED50 7E EE3B                        JMP  DOYNOI
 2507:     ED53 C1 11                  DOSW11  CMPB #YLIMM
 2508:     ED55 26 03                          BNE  DOSW12
 2509:     ED57 7E EE44                        JMP  DOYLI
 2510:     ED5A C1 13                  DOSW12  CMPB #BTB
 2511:     ED5C 26 03                          BNE  DOSW13
 2512:     ED5E 7E EE63                        JMP  DOBTB
 2513:     ED61 C1 14                  DOSW13  CMPB #SETCLR
 2514:     ED63 26 03                          BNE  DODEF
 2515:     ED65 7E EE63                        JMP  DOSET
 2516:                                 
 2517:                                 *   default: return("error in mnemonic table");
 2518:                                 
 2519:     ED68 86 02                  DODEF   LDAA #$2
 2520:     ED6A 39                             RTS
 2521:                                 
 2522:                                 *  case P2INH: emit(PAGE2)
 2523:                                 
 2524:     ED6B 86 18                  DOP2I   LDAA #PAGE2
 2525:     ED6D BD EFEC                        JSR  EMIT
 2526:                                 
 2527:                                 *  case INH: emit(baseop);
 2528:                                 *       return(0);
 2529:                                 
 2530:     ED70 96 B4                  DOINH   LDAA BASEOP
 2531:     ED72 BD EFEC                        JSR  EMIT
 2532:     ED75 4F                             CLRA
 2533:     ED76 39                             RTS
 2534:                                 
 2535:                                 *  case REL: a = assarg();
 2536:                                 *            if(a=4) return(a);
 2537:                                 *            d = address - pc + 2;
 2538:                                 *            if ($7f >= d >= $ff82)
 2539:                                 *               return (out of range);
 2540:                                 *            emit(opcode);
 2541:                                 *            emit(offset);
 2542:                                 *            return(0);
 2543:                                 
 2544:     ED77 BD EFCE                DOREL   JSR  ASSARG
 2545:     ED7A 81 04                          CMPA #$04
 2546:     ED7C 26 01                          BNE  DOREL1  ;jump if arg ok
 2547:     ED7E 39                             RTS
 2548:     ED7F DC 96                  DOREL1  LDD  SHFTREG ;get branch address
 2549:     ED81 DE B0                          LDX  PC      ;get program counter
 2550:     ED83 08                             INX
 2551:     ED84 08                             INX          ;point to end of opcode
 2552:     ED85 DF B8                          STX  BRADDR
 2553:     ED87 93 B8                          SUBD BRADDR  ;calculate offset
 2554:     ED89 DD B8                          STD  BRADDR  ;save result
 2555:     ED8B 1A83 007F                      CPD #$7F    ;in range ?
 2556:     ED8F 23 09                          BLS  DOREL2  ;jump if in range
 2557:     ED91 1A83 FF80                      CPD #$FF80
 2558:     ED95 24 03                          BHS  DOREL2  ;jump if in range
 2559:     ED97 86 09                          LDAA #$09    ;'Out of range'
 2560:     ED99 39                             RTS
 2561:     ED9A 96 B4                  DOREL2  LDAA BASEOP
 2562:     ED9C BD EFEC                        JSR  EMIT    ;emit opcode
 2563:     ED9F 96 B9                          LDAA BRADDR+1
 2564:     EDA1 BD EFEC                        JSR  EMIT    ;emit offset
 2565:     EDA4 4F                             CLRA         ;normal return
 2566:     EDA5 39                             RTS
 2567:                                 
 2568:                                 *  case LIMM: if (amode == IMMED) amode = LIMMED;
 2569:                                 
 2570:     EDA6 96 C1                  DOLIM   LDAA AMODE
 2571:     EDA8 81 00                          CMPA #IMMED
 2572:     EDAA 26 04                          BNE  DONOI
 2573:     EDAC 86 03                          LDAA #LIMMED
 2574:     EDAE 97 C1                          STAA AMODE
 2575:                                 
 2576:                                 *  case NIMM: if (amode == IMMED)
 2577:                                 *                return("Immediate mode illegal");
 2578:                                 
 2579:     EDB0 96 C1                  DONOI   LDAA AMODE
 2580:     EDB2 81 00                          CMPA #IMMED
 2581:     EDB4 26 03                          BNE  DOGENE  ;jump if not immediate
 2582:     EDB6 86 01                          LDAA #$1     ;"immediate mode illegal"
 2583:     EDB8 39                             RTS
 2584:                                 
 2585:                                 *  case GEN: dogen(baseop,amode,PAGE1,PAGE1,PAGE2);
 2586:                                 *            return;
 2587:                                 
 2588:     EDB9 86 00                  DOGENE  LDAA #PAGE1
 2589:     EDBB 97 C3                          STAA PNORM
 2590:     EDBD 97 B2                          STAA PX
 2591:     EDBF 86 18                          LDAA #PAGE2
 2592:     EDC1 97 B3                          STAA PY
 2593:     EDC3 BD EEFF                        JSR  DOGEN
 2594:     EDC6 39                             RTS
 2595:                                 
 2596:                                 *  case GRP2: if (amode == INDY)
 2597:                                 *                emit(PAGE2);
 2598:                                 *                amode = INDX;
 2599:                                 *             if( amode == INDX )
 2600:                                 *                doindx(baseop);
 2601:                                 *             else a = assarg();
 2602:                                 *                if(a=4) return(a);
 2603:                                 *                emit(opcode+0x10);
 2604:                                 *                emit(extended address);
 2605:                                 *             return;
 2606:                                 
 2607:     EDC7 96 C1                  DOGRP   LDAA AMODE
 2608:     EDC9 81 02                          CMPA #INDY
 2609:     EDCB 26 09                          BNE  DOGRP1
 2610:     EDCD 86 18                          LDAA #PAGE2
 2611:     EDCF BD EFEC                        JSR  EMIT
 2612:     EDD2 86 01                          LDAA #INDX
 2613:     EDD4 97 C1                          STAA AMODE
 2614:          =0000EDD6              DOGRP1  EQU  *
 2615:     EDD6 96 C1                          LDAA AMODE
 2616:     EDD8 81 01                          CMPA #INDX
 2617:     EDDA 26 04                          BNE  DOGRP2
 2618:     EDDC BD EF9F                        JSR  DOINDEX
 2619:     EDDF 39                             RTS
 2620:          =0000EDE0              DOGRP2  EQU  *
 2621:     EDE0 96 B4                          LDAA BASEOP
 2622:     EDE2 8B 10                          ADDA #$10
 2623:     EDE4 BD EFEC                        JSR  EMIT
 2624:     EDE7 BD EFCE                        JSR  ASSARG
 2625:     EDEA 81 04                          CMPA #$04
 2626:     EDEC 27 0A                          BEQ  DOGRPRT ;jump if bad arg
 2627:     EDEE DC 96                          LDD  SHFTREG ;extended address
 2628:     EDF0 BD EFEC                        JSR  EMIT
 2629:     EDF3 17                             TBA
 2630:     EDF4 BD EFEC                        JSR  EMIT
 2631:     EDF7 4F                             CLRA
 2632:     EDF8 39                     DOGRPRT RTS
 2633:                                 
 2634:                                 *  case CPD: if (amode == IMMED)
 2635:                                 *               amode = LIMMED; /* cpd */
 2636:                                 *            if( amode == INDY ) yflag = 1;
 2637:                                 *            dogen(baseop,amode,PAGE3,PAGE3,PAGE4);
 2638:                                 *            return;
 2639:                                 
 2640:     EDF9 96 C1                  DOCPD   LDAA AMODE
 2641:     EDFB 81 00                          CMPA #IMMED
 2642:     EDFD 26 04                          BNE  DOCPD1
 2643:     EDFF 86 03                          LDAA #LIMMED
 2644:     EE01 97 C1                          STAA AMODE
 2645:     EE03 96 C1                  DOCPD1  LDAA AMODE
 2646:     EE05 81 02                          CMPA #INDY
 2647:     EE07 26 03                          BNE  DOCPD2
 2648:     EE09 7C 00C2                        INC  YFLAG
 2649:     EE0C 86 1A                  DOCPD2  LDAA #PAGE3
 2650:     EE0E 97 C3                          STAA PNORM
 2651:     EE10 97 B2                          STAA PX
 2652:     EE12 86 CD                          LDAA #PAGE4
 2653:     EE14 97 B3                          STAA PY
 2654:     EE16 BD EEFF                        JSR  DOGEN
 2655:     EE19 39                             RTS
 2656:                                 
 2657:                                 *  case XNIMM: if (amode == IMMED)      /* stx */
 2658:                                 *                 return("Immediate mode illegal");
 2659:                                 
 2660:     EE1A 96 C1                  DOXNOI  LDAA AMODE
 2661:     EE1C 81 00                          CMPA #IMMED
 2662:     EE1E 26 03                          BNE  DOXLI
 2663:     EE20 86 01                          LDAA #$1     ;"immediate mode illegal"
 2664:     EE22 39                             RTS
 2665:                                 
 2666:                                 *  case XLIMM: if (amode == IMMED)  /* cpx, ldx */
 2667:                                 *                 amode = LIMMED;
 2668:                                 *              dogen(baseop,amode,PAGE1,PAGE1,PAGE4);
 2669:                                 *              return;
 2670:                                 
 2671:     EE23 96 C1                  DOXLI   LDAA AMODE
 2672:     EE25 81 00                          CMPA #IMMED
 2673:     EE27 26 04                          BNE  DOXLI1
 2674:     EE29 86 03                          LDAA #LIMMED
 2675:     EE2B 97 C1                          STAA AMODE
 2676:     EE2D 86 00                  DOXLI1  LDAA #PAGE1
 2677:     EE2F 97 C3                          STAA PNORM
 2678:     EE31 97 B2                          STAA PX
 2679:     EE33 86 CD                          LDAA #PAGE4
 2680:     EE35 97 B3                          STAA PY
 2681:     EE37 BD EEFF                        JSR  DOGEN
 2682:     EE3A 39                             RTS
 2683:                                 
 2684:                                 *  case YNIMM: if (amode == IMMED)      /* sty */
 2685:                                 *                 return("Immediate mode illegal");
 2686:                                 
 2687:     EE3B 96 C1                  DOYNOI  LDAA AMODE
 2688:     EE3D 81 00                          CMPA #IMMED
 2689:     EE3F 26 03                          BNE  DOYLI
 2690:     EE41 86 01                          LDAA #$1     ;"immediate mode illegal"
 2691:     EE43 39                             RTS
 2692:                                 
 2693:                                 *  case YLIMM: if (amode == INDY) yflag = 1;/* cpy, ldy */
 2694:                                 *              if(amode == IMMED) amode = LIMMED;
 2695:                                 *              dogen(opcode,amode,PAGE2,PAGE3,PAGE2);
 2696:                                 *              return;
 2697:                                 
 2698:     EE44 96 C1                  DOYLI   LDAA AMODE
 2699:     EE46 81 02                          CMPA #INDY
 2700:     EE48 26 03                          BNE  DOYLI1
 2701:     EE4A 7C 00C2                        INC  YFLAG
 2702:     EE4D 81 00                  DOYLI1  CMPA #IMMED
 2703:     EE4F 26 04                          BNE  DOYLI2
 2704:     EE51 86 03                          LDAA #LIMMED
 2705:     EE53 97 C1                          STAA AMODE
 2706:     EE55 86 18                  DOYLI2  LDAA #PAGE2
 2707:     EE57 97 C3                          STAA PNORM
 2708:     EE59 97 B3                          STAA PY
 2709:     EE5B 86 1A                          LDAA #PAGE3
 2710:     EE5D 97 B2                          STAA PX
 2711:     EE5F BD EEFF                        JSR  DOGEN
 2712:     EE62 39                             RTS
 2713:                                 
 2714:                                 *  case BTB:        /* bset, bclr */
 2715:                                 *  case SETCLR: a = bitop(baseop,amode,class);
 2716:                                 *               if(a=0) return(a = 3);
 2717:                                 *               if( amode == INDY )
 2718:                                 *                  emit(PAGE2);
 2719:                                 *                  amode = INDX;
 2720:                                 
 2721:          =0000EE63              DOBTB   EQU  *
 2722:     EE63 BD EED9                DOSET   JSR  BITOP
 2723:     EE66 81 00                          CMPA #$00
 2724:     EE68 26 03                          BNE  DOSET1
 2725:     EE6A 86 03                          LDAA #$3     ;"illegal bit op"
 2726:     EE6C 39                             RTS
 2727:     EE6D 96 C1                  DOSET1  LDAA AMODE
 2728:     EE6F 81 02                          CMPA #INDY
 2729:     EE71 26 09                          BNE  DOSET2
 2730:     EE73 86 18                          LDAA #PAGE2
 2731:     EE75 BD EFEC                        JSR  EMIT
 2732:     EE78 86 01                          LDAA #INDX
 2733:     EE7A 97 C1                          STAA AMODE
 2734:          =0000EE7C              DOSET2  EQU  *
 2735:                                 
 2736:                                 *               emit(baseop);
 2737:                                 *               a = assarg();
 2738:                                 *               if(a = 4) return(a);
 2739:                                 *               emit(index offset);
 2740:                                 *               if( amode == INDX )
 2741:                                 *                  Buffptr += 2;      /* skip ,x or ,y */
 2742:                                 
 2743:     EE7C 96 B4                          LDAA BASEOP
 2744:     EE7E BD EFEC                        JSR  EMIT
 2745:     EE81 BD EFCE                        JSR  ASSARG
 2746:     EE84 81 04                          CMPA #$04
 2747:     EE86 26 01                          BNE  DOSET22    ;     jump if arg ok
 2748:     EE88 39                             RTS
 2749:     EE89 96 97                  DOSET22 LDAA SHFTREG+1   ;    index offset
 2750:     EE8B BD EFEC                        JSR  EMIT
 2751:     EE8E 96 C1                          LDAA AMODE
 2752:     EE90 81 01                          CMPA #INDX
 2753:     EE92 26 06                          BNE  DOSET3
 2754:     EE94 BD E2F8                        JSR  INCBUFF
 2755:     EE97 BD E2F8                        JSR  INCBUFF
 2756:          =0000EE9A              DOSET3  EQU  *
 2757:                                 
 2758:                                 *               a = assarg();
 2759:                                 *               if(a = 4) return(a);
 2760:                                 *               emit(mask);   /* mask */
 2761:                                 *               if( class == SETCLR )
 2762:                                 *                  return;
 2763:                                 
 2764:     EE9A BD EFCE                        JSR  ASSARG
 2765:     EE9D 81 04                          CMPA #$04
 2766:     EE9F 26 01                          BNE  DOSET33     ;    jump if arg ok
 2767:     EEA1 39                             RTS
 2768:     EEA2 96 97                  DOSET33 LDAA SHFTREG+1    ;   mask
 2769:     EEA4 BD EFEC                        JSR  EMIT
 2770:     EEA7 96 B5                          LDAA CLASS
 2771:     EEA9 81 14                          CMPA #SETCLR
 2772:     EEAB 26 02                          BNE  DOSET4
 2773:     EEAD 4F                             CLRA
 2774:     EEAE 39                             RTS
 2775:          =0000EEAF              DOSET4  EQU  *
 2776:                                 
 2777:                                 *               a = assarg();
 2778:                                 *               if(a = 4) return(a);
 2779:                                 *               d = (pc+1) - shftreg;
 2780:                                 *               if ($7f >= d >= $ff82)
 2781:                                 *                  return (out of range);
 2782:                                 *               emit(branch offset);
 2783:                                 *               return(0);
 2784:                                 
 2785:     EEAF BD EFCE                        JSR  ASSARG
 2786:     EEB2 81 04                          CMPA #$04
 2787:     EEB4 26 01                          BNE  DOSET5        ;  jump if arg ok
 2788:     EEB6 39                             RTS
 2789:     EEB7 DE B0                  DOSET5  LDX  PC             ; program counter
 2790:     EEB9 08                             INX                  ;point to next inst
 2791:     EEBA DF B8                          STX  BRADDR          ;save pc value
 2792:     EEBC DC 96                          LDD  SHFTREG         ;get branch address
 2793:     EEBE 93 B8                          SUBD BRADDR          ;calculate offset
 2794:     EEC0 1A83 007F                      CPD #$7F
 2795:     EEC4 23 0D                          BLS  DOSET6          ;jump if in range
 2796:     EEC6 1A83 FF80                      CPD #$FF80
 2797:     EECA 24 07                          BHS  DOSET6          ;jump if in range
 2798:     EECC 4F                             CLRA
 2799:     EECD BD EFEC                        JSR  EMIT
 2800:     EED0 86 09                          LDAA #$09            ;'out of range'
 2801:     EED2 39                             RTS
 2802:     EED3 17                     DOSET6  TBA                  ;offset
 2803:     EED4 BD EFEC                        JSR  EMIT
 2804:     EED7 4F                             CLRA
 2805:     EED8 39                             RTS
 2806:                                 
 2807:                                 
 2808:                                 **********
 2809:                                 **   bitop(baseop,amode,class) --- adjust opcode on bit
 2810:                                 **       manipulation instructions.  Returns opcode in a
 2811:                                 **       or a = 0 if error
 2812:                                 **********
 2813:                                 *if( amode == INDX || amode == INDY ) return(op);
 2814:                                 *if( class == SETCLR ) return(op-8);
 2815:                                 *else if(class==BTB) return(op-12);
 2816:                                 *else fatal("bitop");
 2817:                                 
 2818:          =0000EED9              BITOP   EQU  *
 2819:     EED9 96 C1                          LDAA AMODE
 2820:     EEDB D6 B5                          LDAB CLASS
 2821:     EEDD 81 01                          CMPA #INDX
 2822:     EEDF 26 01                          BNE  BITOP1
 2823:     EEE1 39                             RTS
 2824:     EEE2 81 02                  BITOP1  CMPA #INDY
 2825:     EEE4 26 01                          BNE  BITOP2  ;jump not indexed
 2826:     EEE6 39                             RTS
 2827:     EEE7 C1 14                  BITOP2  CMPB #SETCLR
 2828:     EEE9 26 07                          BNE  BITOP3  ;jump not bset,bclr
 2829:     EEEB 96 B4                          LDAA BASEOP  ;get opcode
 2830:     EEED 80 08                          SUBA #8
 2831:     EEEF 97 B4                          STAA BASEOP
 2832:     EEF1 39                             RTS
 2833:     EEF2 C1 13                  BITOP3  CMPB #BTB
 2834:     EEF4 26 07                          BNE  BITOP4  ;jump not bit branch
 2835:     EEF6 96 B4                          LDAA BASEOP  ;get opcode
 2836:     EEF8 80 0C                          SUBA #12
 2837:     EEFA 97 B4                          STAA BASEOP
 2838:     EEFC 39                             RTS
 2839:     EEFD 4F                     BITOP4  CLRA         ;0 = fatal bitop
 2840:     EEFE 39                             RTS
 2841:                                 
 2842:                                 **********
 2843:                                 **   dogen(baseop,mode,pnorm,px,py) - process
 2844:                                 ** general addressing modes. Returns a = error #.
 2845:                                 **********
 2846:                                 *pnorm = page for normal addressing modes: IMM,DIR,EXT
 2847:                                 *px = page for INDX addressing
 2848:                                 *py = page for INDY addressing
 2849:                                 *switch(amode)
 2850:     EEFF 96 C1                  DOGEN   LDAA AMODE
 2851:     EF01 81 03                          CMPA #LIMMED
 2852:     EF03 27 13                          BEQ  DOGLIM
 2853:     EF05 81 00                          CMPA #IMMED
 2854:     EF07 27 2C                          BEQ  DOGIMM
 2855:     EF09 81 02                          CMPA #INDY
 2856:     EF0B 27 41                          BEQ  DOGINDY
 2857:     EF0D 81 01                          CMPA #INDX
 2858:     EF0F 27 4C                          BEQ  DOGINDX
 2859:     EF11 81 04                          CMPA #OTHER
 2860:     EF13 27 57                          BEQ  DOGOTH
 2861:                                 
 2862:                                 *default: error("Unknown Addressing Mode");
 2863:                                 
 2864:     EF15 86 06                  DOGDEF  LDAA #$06     ;   unknown addre...
 2865:     EF17 39                             RTS
 2866:                                 
 2867:                                 *case LIMMED: epage(pnorm);
 2868:                                 *             emit(baseop);
 2869:                                 *             a = assarg();
 2870:                                 *             if(a = 4) return(a);
 2871:                                 *             emit(2 bytes);
 2872:                                 *             return(0);
 2873:                                 
 2874:     EF18 96 C3                  DOGLIM  LDAA PNORM
 2875:     EF1A BD EFE4                        JSR  EPAGE
 2876:     EF1D 96 B4                  DOGLIM1 LDAA BASEOP
 2877:     EF1F BD EFEC                        JSR  EMIT
 2878:     EF22 BD EFCE                        JSR  ASSARG   ;get next argument
 2879:     EF25 81 04                          CMPA #$04
 2880:     EF27 26 01                          BNE  DOGLIM2   ;jump if arg ok
 2881:     EF29 39                             RTS
 2882:     EF2A DC 96                  DOGLIM2 LDD  SHFTREG
 2883:     EF2C BD EFEC                        JSR  EMIT
 2884:     EF2F 17                             TBA
 2885:     EF30 BD EFEC                        JSR  EMIT
 2886:     EF33 4F                             CLRA
 2887:     EF34 39                             RTS
 2888:                                 
 2889:                                 *case IMMED: epage(pnorm);
 2890:                                 *            emit(baseop);
 2891:                                 *            a = assarg();
 2892:                                 *            if(a = 4) return(a);
 2893:                                 *            emit(lobyte);
 2894:                                 *            return(0);
 2895:                                 
 2896:     EF35 96 C3                  DOGIMM  LDAA PNORM
 2897:     EF37 BD EFE4                        JSR  EPAGE
 2898:     EF3A 96 B4                          LDAA BASEOP
 2899:     EF3C BD EFEC                        JSR  EMIT
 2900:     EF3F BD EFCE                        JSR  ASSARG
 2901:     EF42 81 04                          CMPA #$04
 2902:     EF44 26 01                          BNE  DOGIMM1   ;jump if arg ok
 2903:     EF46 39                             RTS
 2904:     EF47 96 97                  DOGIMM1 LDAA SHFTREG+1
 2905:     EF49 BD EFEC                        JSR  EMIT
 2906:     EF4C 4F                             CLRA
 2907:     EF4D 39                             RTS
 2908:                                 
 2909:                                 *case INDY: epage(py);
 2910:                                 *           a=doindex(op+0x20);
 2911:                                 *           return(a);
 2912:                                 
 2913:     EF4E 96 B3                  DOGINDY LDAA PY
 2914:     EF50 BD EFE4                        JSR  EPAGE
 2915:     EF53 96 B4                          LDAA BASEOP
 2916:     EF55 8B 20                          ADDA #$20
 2917:     EF57 97 B4                          STAA BASEOP
 2918:     EF59 BD EF9F                        JSR  DOINDEX
 2919:     EF5C 39                             RTS
 2920:                                 
 2921:                                 *case INDX: epage(px);
 2922:                                 *           a=doindex(op+0x20);
 2923:                                 *           return(a);
 2924:                                 
 2925:     EF5D 96 B2                  DOGINDX LDAA PX
 2926:     EF5F BD EFE4                        JSR  EPAGE
 2927:     EF62 96 B4                          LDAA BASEOP
 2928:     EF64 8B 20                          ADDA #$20
 2929:     EF66 97 B4                          STAA BASEOP
 2930:     EF68 BD EF9F                        JSR  DOINDEX
 2931:     EF6B 39                             RTS
 2932:                                 
 2933:                                 *case OTHER: a = assarg();
 2934:                                 *            if(a = 4) return(a);
 2935:                                 *            epage(pnorm);
 2936:                                 *            if(countu1 <= 2 digits)   /* direct */
 2937:                                 *               emit(op+0x10);
 2938:                                 *               emit(lobyte(Result));
 2939:                                 *               return(0);
 2940:                                 *            else    emit(op+0x30);    /* extended */
 2941:                                 *               eword(Result);
 2942:                                 *               return(0)
 2943:                                 
 2944:     EF6C BD EFCE                DOGOTH  JSR  ASSARG
 2945:     EF6F 81 04                          CMPA #$04
 2946:     EF71 26 01                          BNE  DOGOTH0  ;jump if arg ok
 2947:     EF73 39                             RTS
 2948:     EF74 96 C3                  DOGOTH0 LDAA PNORM
 2949:     EF76 BD EFE4                        JSR  EPAGE
 2950:     EF79 96 A8                          LDAA COUNT
 2951:     EF7B 81 02                          CMPA #$2
 2952:     EF7D 2E 0E                          BGT  DOGOTH1
 2953:     EF7F 96 B4                          LDAA BASEOP
 2954:     EF81 8B 10                          ADDA #$10      ;      direct mode opcode
 2955:     EF83 BD EFEC                        JSR  EMIT
 2956:     EF86 96 97                          LDAA SHFTREG+1
 2957:     EF88 BD EFEC                        JSR  EMIT
 2958:     EF8B 4F                             CLRA
 2959:     EF8C 39                             RTS
 2960:     EF8D 96 B4                  DOGOTH1 LDAA BASEOP
 2961:     EF8F 8B 30                          ADDA #$30       ;     extended mode opcode
 2962:     EF91 BD EFEC                        JSR  EMIT
 2963:     EF94 DC 96                          LDD  SHFTREG
 2964:     EF96 BD EFEC                        JSR  EMIT
 2965:     EF99 17                             TBA
 2966:     EF9A BD EFEC                        JSR  EMIT
 2967:     EF9D 4F                             CLRA
 2968:     EF9E 39                             RTS
 2969:                                 
 2970:                                 **********
 2971:                                 **  doindex(op) --- handle all wierd stuff for
 2972:                                 **   indexed addressing. Returns a = error number.
 2973:                                 **********
 2974:                                 *emit(baseop);
 2975:                                 *a=assarg();
 2976:                                 *if(a = 4) return(a);
 2977:                                 *if( a != ',' ) return("Syntax");
 2978:                                 *buffptr++
 2979:                                 *a=readbuff()
 2980:                                 *if( a != 'x' &&  != 'y') warn("Ind Addr Assumed");
 2981:                                 *emit(lobyte);
 2982:                                 *return(0);
 2983:                                 
 2984:     EF9F 96 B4                  DOINDEX LDAA BASEOP
 2985:     EFA1 BD EFEC                        JSR  EMIT
 2986:     EFA4 BD EFCE                        JSR  ASSARG
 2987:     EFA7 81 04                          CMPA #$04
 2988:     EFA9 26 01                          BNE  DOINDX0    ; jump if arg ok
 2989:     EFAB 39                             RTS
 2990:     EFAC 81 2C                  DOINDX0 CMPA #','
 2991:     EFAE 27 03                          BEQ  DOINDX1
 2992:     EFB0 86 08                          LDAA #$08        ;"syntax error"
 2993:     EFB2 39                             RTS
 2994:     EFB3 BD E2F8                DOINDX1 JSR  INCBUFF
 2995:     EFB6 BD E2F1                        JSR  READBUFF
 2996:     EFB9 81 59                          CMPA #'Y'
 2997:     EFBB 27 0A                          BEQ  DOINDX2
 2998:     EFBD 81 58                          CMPA #'X'
 2999:     EFBF 27 06                          BEQ  DOINDX2
 3000:     EFC1 FE EAE8                        LDX  MSGA7       ;"index addr assumed"
 3001:     EFC4 BD E518                        JSR  OUTSTRG
 3002:     EFC7 96 97                  DOINDX2 LDAA SHFTREG+1
 3003:     EFC9 BD EFEC                        JSR  EMIT
 3004:     EFCC 4F                             CLRA
 3005:     EFCD 39                             RTS
 3006:                                 
 3007:                                 **********
 3008:                                 **   assarg(); - get argument.  Returns a = 4 if bad
 3009:                                 ** argument, else a = first non hex char.
 3010:                                 **********
 3011:                                 *a = buffarg()
 3012:                                 *if(asschk(aa) && countu1 != 0) return(a);
 3013:                                 *return(bad argument);
 3014:                                 
 3015:     EFCE BD E23A                ASSARG  JSR  BUFFARG
 3016:     EFD1 BD EC7A                        JSR  ASSCHEK   ;check for command
 3017:     EFD4 27 05                          BEQ  ASSARG1   ;jump if ok
 3018:     EFD6 BD E316                        JSR  WCHEK     ;check for whitespace
 3019:     EFD9 26 06                          BNE  ASSARG2   ;jump if not ok
 3020:     EFDB 7D 00A8                ASSARG1 TST  COUNT
 3021:     EFDE 27 01                          BEQ  ASSARG2   ;jump if no argument
 3022:     EFE0 39                             RTS
 3023:     EFE1 86 04                  ASSARG2 LDAA #$04      ;bad argument
 3024:     EFE3 39                             RTS
 3025:                                 
 3026:                                 **********
 3027:                                 **  epage(a) --- emit page prebyte
 3028:                                 **********
 3029:                                 *if( a != PAGE1 ) emit(a);
 3030:                                 
 3031:     EFE4 81 00                  EPAGE   CMPA #PAGE1
 3032:     EFE6 27 03                          BEQ  EPAGRT  ;jump if page 1
 3033:     EFE8 BD EFEC                        JSR  EMIT
 3034:     EFEB 39                     EPAGRT  RTS
 3035:                                 
 3036:                                 **********
 3037:                                 *   emit(a) --- emit contents of a
 3038:                                 **********
 3039:     EFEC DE B0                  EMIT    LDX  PC
 3040:     EFEE BD E290                        JSR  WRITE      ;write a to x
 3041:     EFF1 BD E4FF                        JSR  OUT1BSP
 3042:     EFF4 DF B0                          STX  PC
 3043:     EFF6 39                             RTS
 3044:                                 
 3045:                                 *Mnemonic table for hc11 line assembler
 3046:          =00000000              NULL    EQU  $0      ;nothing
 3047:          =00000001              INH     EQU  $1      ;inherent
 3048:          =00000002              P2INH   EQU  $2      ;page 2 inherent
 3049:          =00000003              GEN     EQU  $3      ;general addressing
 3050:          =00000004              GRP2    EQU  $4      ;group 2
 3051:          =00000005              REL     EQU  $5      ;relative
 3052:          =00000006              IMM     EQU  $6      ;immediate
 3053:          =00000007              NIMM    EQU  $7      ;general except for immediate
 3054:          =00000008              LIMM    EQU  $8      ;2 byte immediate
 3055:          =00000009              XLIMM   EQU  $9      ;longimm for x
 3056:          =00000010              XNIMM   EQU  $10     ;no immediate for x
 3057:          =00000011              YLIMM   EQU  $11     ;longimm for y
 3058:          =00000012              YNIMM   EQU  $12     ;no immediate for y
 3059:          =00000013              BTB     EQU  $13     ;bit test and branch
 3060:          =00000014              SETCLR  EQU  $14     ;bit set or clear
 3061:          =00000015              CPD     EQU  $15     ;compare d
 3062:          =00000016              BTBD    EQU  $16     ;bit test and branch direct
 3063:          =00000017              SETCLRD EQU  $17     ;bit set or clear direct
 3064:                                 
 3065:                                 **********
 3066:                                 *   mnetabl - includes all '11 mnemonics, base opcodes,
 3067:                                 * and type of instruction.  The assembler search routine
 3068:                                 *depends on 4 characters for each mnemonic so that 3 char
 3069:                                 *mnemonics are extended with a space and 5 char mnemonics
 3070:                                 *are truncated.
 3071:                                 **********
 3072:                                 
 3073:          =0000EFF7              MNETABL EQU  *
 3074:     EFF7 41 42 41 20                    FCC  'ABA ' ;  Mnemonic
 3075:     EFFB 1B                             FCB  $1B     ;Base opcode
 3076:     EFFC 01                             FCB  INH     ;Class
 3077:     EFFD 41 42 58 20                    FCC  'ABX '
 3078:     F001 3A                             FCB  $3A
 3079:     F002 01                             FCB  INH
 3080:     F003 41 42 59 20                    FCC  'ABY '
 3081:     F007 3A                             FCB  $3A
 3082:     F008 02                             FCB  P2INH
 3083:     F009 41 44 43 41                    FCC  'ADCA'
 3084:     F00D 89                             FCB  $89
 3085:     F00E 03                             FCB  GEN
 3086:     F00F 41 44 43 42                    FCC  'ADCB'
 3087:     F013 C9                             FCB  $C9
 3088:     F014 03                             FCB  GEN
 3089:     F015 41 44 44 41                    FCC  'ADDA'
 3090:     F019 8B                             FCB  $8B
 3091:     F01A 03                             FCB  GEN
 3092:     F01B 41 44 44 42                    FCC  'ADDB'
 3093:     F01F CB                             FCB  $CB
 3094:     F020 03                             FCB  GEN
 3095:     F021 41 44 44 44                    FCC  'ADDD'
 3096:     F025 C3                             FCB  $C3
 3097:     F026 08                             FCB  LIMM
 3098:     F027 41 4E 44 41                    FCC  'ANDA'
 3099:     F02B 84                             FCB  $84
 3100:     F02C 03                             FCB  GEN
 3101:     F02D 41 4E 44 42                    FCC  'ANDB'
 3102:     F031 C4                             FCB  $C4
 3103:     F032 03                             FCB  GEN
 3104:     F033 41 53 4C 20                    FCC  'ASL '
 3105:     F037 68                             FCB  $68
 3106:     F038 04                             FCB  GRP2
 3107:     F039 41 53 4C 41                    FCC  'ASLA'
 3108:     F03D 48                             FCB  $48
 3109:     F03E 01                             FCB  INH
 3110:     F03F 41 53 4C 42                    FCC  'ASLB'
 3111:     F043 58                             FCB  $58
 3112:     F044 01                             FCB  INH
 3113:     F045 41 53 4C 44                    FCC  'ASLD'
 3114:     F049 05                             FCB  $05
 3115:     F04A 01                             FCB  INH
 3116:     F04B 41 53 52 20                    FCC  'ASR '
 3117:     F04F 67                             FCB  $67
 3118:     F050 04                             FCB  GRP2
 3119:     F051 41 53 52 41                    FCC  'ASRA'
 3120:     F055 47                             FCB  $47
 3121:     F056 01                             FCB  INH
 3122:     F057 41 53 52 42                    FCC  'ASRB'
 3123:     F05B 57                             FCB  $57
 3124:     F05C 01                             FCB  INH
 3125:     F05D 42 43 43 20                    FCC  'BCC '
 3126:     F061 24                             FCB  $24
 3127:     F062 05                             FCB  REL
 3128:     F063 42 43 4C 52                    FCC  'BCLR'
 3129:     F067 1D                             FCB  $1D
 3130:     F068 14                             FCB  SETCLR
 3131:     F069 42 43 53 20                    FCC  'BCS '
 3132:     F06D 25                             FCB  $25
 3133:     F06E 05                             FCB  REL
 3134:     F06F 42 45 51 20                    FCC  'BEQ '
 3135:     F073 27                             FCB  $27
 3136:     F074 05                             FCB  REL
 3137:     F075 42 47 45 20                    FCC  'BGE '
 3138:     F079 2C                             FCB  $2C
 3139:     F07A 05                             FCB  REL
 3140:     F07B 42 47 54 20                    FCC  'BGT '
 3141:     F07F 2E                             FCB  $2E
 3142:     F080 05                             FCB  REL
 3143:     F081 42 48 49 20                    FCC  'BHI '
 3144:     F085 22                             FCB  $22
 3145:     F086 05                             FCB  REL
 3146:     F087 42 48 53 20                    FCC  'BHS '
 3147:     F08B 24                             FCB  $24
 3148:     F08C 05                             FCB  REL
 3149:     F08D 42 49 54 41                    FCC  'BITA'
 3150:     F091 85                             FCB  $85
 3151:     F092 03                             FCB  GEN
 3152:     F093 42 49 54 42                    FCC  'BITB'
 3153:     F097 C5                             FCB  $C5
 3154:     F098 03                             FCB  GEN
 3155:     F099 42 4C 45 20                    FCC  'BLE '
 3156:     F09D 2F                             FCB  $2F
 3157:     F09E 05                             FCB  REL
 3158:     F09F 42 4C 4F 20                    FCC  'BLO '
 3159:     F0A3 25                             FCB  $25
 3160:     F0A4 05                             FCB  REL
 3161:     F0A5 42 4C 53 20                    FCC  'BLS '
 3162:     F0A9 23                             FCB  $23
 3163:     F0AA 05                             FCB  REL
 3164:     F0AB 42 4C 54 20                    FCC  'BLT '
 3165:     F0AF 2D                             FCB  $2D
 3166:     F0B0 05                             FCB  REL
 3167:     F0B1 42 4D 49 20                    FCC  'BMI '
 3168:     F0B5 2B                             FCB  $2B
 3169:     F0B6 05                             FCB  REL
 3170:     F0B7 42 4E 45 20                    FCC  'BNE '
 3171:     F0BB 26                             FCB  $26
 3172:     F0BC 05                             FCB  REL
 3173:     F0BD 42 50 4C 20                    FCC  'BPL '
 3174:     F0C1 2A                             FCB  $2A
 3175:     F0C2 05                             FCB  REL
 3176:     F0C3 42 52 41 20                    FCC  'BRA '
 3177:     F0C7 20                             FCB  $20
 3178:     F0C8 05                             FCB  REL
 3179:     F0C9 42 52 43 4C                    FCC  'BRCL'   ;    (BRCLR)
 3180:     F0CD 1F                             FCB  $1F
 3181:     F0CE 13                             FCB  BTB
 3182:     F0CF 42 52 4E 20                    FCC  'BRN '
 3183:     F0D3 21                             FCB  $21
 3184:     F0D4 05                             FCB  REL
 3185:     F0D5 42 52 53 45                    FCC  'BRSE'    ;   (BRSET)
 3186:     F0D9 1E                             FCB  $1E
 3187:     F0DA 13                             FCB  BTB
 3188:     F0DB 42 53 45 54                    FCC  'BSET'
 3189:     F0DF 1C                             FCB  $1C
 3190:     F0E0 14                             FCB  SETCLR
 3191:     F0E1 42 53 52 20                    FCC  'BSR '
 3192:     F0E5 8D                             FCB  $8D
 3193:     F0E6 05                             FCB  REL
 3194:     F0E7 42 56 43 20                    FCC  'BVC '
 3195:     F0EB 28                             FCB  $28
 3196:     F0EC 05                             FCB  REL
 3197:     F0ED 42 56 53 20                    FCC  'BVS '
 3198:     F0F1 29                             FCB  $29
 3199:     F0F2 05                             FCB  REL
 3200:     F0F3 43 42 41 20                    FCC  'CBA '
 3201:     F0F7 11                             FCB  $11
 3202:     F0F8 01                             FCB  INH
 3203:     F0F9 43 4C 43 20                    FCC  'CLC '
 3204:     F0FD 0C                             FCB  $0C
 3205:     F0FE 01                             FCB  INH
 3206:     F0FF 43 4C 49 20                    FCC  'CLI '
 3207:     F103 0E                             FCB  $0E
 3208:     F104 01                             FCB  INH
 3209:     F105 43 4C 52 20                    FCC  'CLR '
 3210:     F109 6F                             FCB  $6F
 3211:     F10A 04                             FCB  GRP2
 3212:     F10B 43 4C 52 41                    FCC  'CLRA'
 3213:     F10F 4F                             FCB  $4F
 3214:     F110 01                             FCB  INH
 3215:     F111 43 4C 52 42                    FCC  'CLRB'
 3216:     F115 5F                             FCB  $5F
 3217:     F116 01                             FCB  INH
 3218:     F117 43 4C 56 20                    FCC  'CLV '
 3219:     F11B 0A                             FCB  $0A
 3220:     F11C 01                             FCB  INH
 3221:     F11D 43 4D 50 41                    FCC  'CMPA'
 3222:     F121 81                             FCB  $81
 3223:     F122 03                             FCB  GEN
 3224:     F123 43 4D 50 42                    FCC  'CMPB'
 3225:     F127 C1                             FCB  $C1
 3226:     F128 03                             FCB  GEN
 3227:     F129 43 4F 4D 20                    FCC  'COM '
 3228:     F12D 63                             FCB  $63
 3229:     F12E 04                             FCB  GRP2
 3230:     F12F 43 4F 4D 41                    FCC  'COMA'
 3231:     F133 43                             FCB  $43
 3232:     F134 01                             FCB  INH
 3233:     F135 43 4F 4D 42                    FCC  'COMB'
 3234:     F139 53                             FCB  $53
 3235:     F13A 01                             FCB  INH
 3236:     F13B 43 50 44 20                    FCC  'CPD '
 3237:     F13F 83                             FCB  $83
 3238:     F140 15                             FCB  CPD
 3239:     F141 43 50 58 20                    FCC  'CPX '
 3240:     F145 8C                             FCB  $8C
 3241:     F146 09                             FCB  XLIMM
 3242:     F147 43 50 59 20                    FCC  'CPY '
 3243:     F14B 8C                             FCB  $8C
 3244:     F14C 11                             FCB  YLIMM
 3245:     F14D 44 41 41 20                    FCC  'DAA '
 3246:     F151 19                             FCB  $19
 3247:     F152 01                             FCB  INH
 3248:     F153 44 45 43 20                    FCC  'DEC '
 3249:     F157 6A                             FCB  $6A
 3250:     F158 04                             FCB  GRP2
 3251:     F159 44 45 43 41                    FCC  'DECA'
 3252:     F15D 4A                             FCB  $4A
 3253:     F15E 01                             FCB  INH
 3254:     F15F 44 45 43 42                    FCC  'DECB'
 3255:     F163 5A                             FCB  $5A
 3256:     F164 01                             FCB  INH
 3257:     F165 44 45 53 20                    FCC  'DES '
 3258:     F169 34                             FCB  $34
 3259:     F16A 01                             FCB  INH
 3260:     F16B 44 45 58 20                    FCC  'DEX '
 3261:     F16F 09                             FCB  $09
 3262:     F170 01                             FCB  INH
 3263:     F171 44 45 59 20                    FCC  'DEY '
 3264:     F175 09                             FCB  $09
 3265:     F176 02                             FCB  P2INH
 3266:     F177 45 4F 52 41                    FCC  'EORA'
 3267:     F17B 88                             FCB  $88
 3268:     F17C 03                             FCB  GEN
 3269:     F17D 45 4F 52 42                    FCC  'EORB'
 3270:     F181 C8                             FCB  $C8
 3271:     F182 03                             FCB  GEN
 3272:     F183 46 44 49 56                    FCC  'FDIV'
 3273:     F187 03                             FCB  $03
 3274:     F188 01                             FCB  INH
 3275:     F189 49 44 49 56                    FCC  'IDIV'
 3276:     F18D 02                             FCB  $02
 3277:     F18E 01                             FCB  INH
 3278:     F18F 49 4E 43 20                    FCC  'INC '
 3279:     F193 6C                             FCB  $6C
 3280:     F194 04                             FCB  GRP2
 3281:     F195 49 4E 43 41                    FCC  'INCA'
 3282:     F199 4C                             FCB  $4C
 3283:     F19A 01                             FCB  INH
 3284:     F19B 49 4E 43 42                    FCC  'INCB'
 3285:     F19F 5C                             FCB  $5C
 3286:     F1A0 01                             FCB  INH
 3287:     F1A1 49 4E 53 20                    FCC  'INS '
 3288:     F1A5 31                             FCB  $31
 3289:     F1A6 01                             FCB  INH
 3290:     F1A7 49 4E 58 20                    FCC  'INX '
 3291:     F1AB 08                             FCB  $08
 3292:     F1AC 01                             FCB  INH
 3293:     F1AD 49 4E 59 20                    FCC  'INY '
 3294:     F1B1 08                             FCB  $08
 3295:     F1B2 02                             FCB  P2INH
 3296:     F1B3 4A 4D 50 20                    FCC  'JMP '
 3297:     F1B7 6E                             FCB  $6E
 3298:     F1B8 04                             FCB  GRP2
 3299:     F1B9 4A 53 52 20                    FCC  'JSR '
 3300:     F1BD 8D                             FCB  $8D
 3301:     F1BE 07                             FCB  NIMM
 3302:     F1BF 4C 44 41 41                    FCC  'LDAA'
 3303:     F1C3 86                             FCB  $86
 3304:     F1C4 03                             FCB  GEN
 3305:     F1C5 4C 44 41 42                    FCC  'LDAB'
 3306:     F1C9 C6                             FCB  $C6
 3307:     F1CA 03                             FCB  GEN
 3308:     F1CB 4C 44 44 20                    FCC  'LDD '
 3309:     F1CF CC                             FCB  $CC
 3310:     F1D0 08                             FCB  LIMM
 3311:     F1D1 4C 44 53 20                    FCC  'LDS '
 3312:     F1D5 8E                             FCB  $8E
 3313:     F1D6 08                             FCB  LIMM
 3314:     F1D7 4C 44 58 20                    FCC  'LDX '
 3315:     F1DB CE                             FCB  $CE
 3316:     F1DC 09                             FCB  XLIMM
 3317:     F1DD 4C 44 59 20                    FCC  'LDY '
 3318:     F1E1 CE                             FCB  $CE
 3319:     F1E2 11                             FCB  YLIMM
 3320:     F1E3 4C 53 4C 20                    FCC  'LSL '
 3321:     F1E7 68                             FCB  $68
 3322:     F1E8 04                             FCB  GRP2
 3323:     F1E9 4C 53 4C 41                    FCC  'LSLA'
 3324:     F1ED 48                             FCB  $48
 3325:     F1EE 01                             FCB  INH
 3326:     F1EF 4C 53 4C 42                    FCC  'LSLB'
 3327:     F1F3 58                             FCB  $58
 3328:     F1F4 01                             FCB  INH
 3329:     F1F5 4C 53 4C 44                    FCC  'LSLD'
 3330:     F1F9 05                             FCB  $05
 3331:     F1FA 01                             FCB  INH
 3332:     F1FB 4C 53 52 20                    FCC  'LSR '
 3333:     F1FF 64                             FCB  $64
 3334:     F200 04                             FCB  GRP2
 3335:     F201 4C 53 52 41                    FCC  'LSRA'
 3336:     F205 44                             FCB  $44
 3337:     F206 01                             FCB  INH
 3338:     F207 4C 53 52 42                    FCC  'LSRB'
 3339:     F20B 54                             FCB  $54
 3340:     F20C 01                             FCB  INH
 3341:     F20D 4C 53 52 44                    FCC  'LSRD'
 3342:     F211 04                             FCB  $04
 3343:     F212 01                             FCB  INH
 3344:     F213 4D 55 4C 20                    FCC  'MUL '
 3345:     F217 3D                             FCB  $3D
 3346:     F218 01                             FCB  INH
 3347:     F219 4E 45 47 20                    FCC  'NEG '
 3348:     F21D 60                             FCB  $60
 3349:     F21E 04                             FCB  GRP2
 3350:     F21F 4E 45 47 41                    FCC  'NEGA'
 3351:     F223 40                             FCB  $40
 3352:     F224 01                             FCB  INH
 3353:     F225 4E 45 47 42                    FCC  'NEGB'
 3354:     F229 50                             FCB  $50
 3355:     F22A 01                             FCB  INH
 3356:     F22B 4E 4F 50 20                    FCC  'NOP '
 3357:     F22F 01                             FCB  $01
 3358:     F230 01                             FCB  INH
 3359:     F231 4F 52 41 41                    FCC  'ORAA'
 3360:     F235 8A                             FCB  $8A
 3361:     F236 03                             FCB  GEN
 3362:     F237 4F 52 41 42                    FCC  'ORAB'
 3363:     F23B CA                             FCB  $CA
 3364:     F23C 03                             FCB  GEN
 3365:     F23D 50 53 48 41                    FCC  'PSHA'
 3366:     F241 36                             FCB  $36
 3367:     F242 01                             FCB  INH
 3368:     F243 50 53 48 42                    FCC  'PSHB'
 3369:     F247 37                             FCB  $37
 3370:     F248 01                             FCB  INH
 3371:     F249 50 53 48 58                    FCC  'PSHX'
 3372:     F24D 3C                             FCB  $3C
 3373:     F24E 01                             FCB  INH
 3374:     F24F 50 53 48 59                    FCC  'PSHY'
 3375:     F253 3C                             FCB  $3C
 3376:     F254 02                             FCB  P2INH
 3377:     F255 50 55 4C 41                    FCC  'PULA'
 3378:     F259 32                             FCB  $32
 3379:     F25A 01                             FCB  INH
 3380:     F25B 50 55 4C 42                    FCC  'PULB'
 3381:     F25F 33                             FCB  $33
 3382:     F260 01                             FCB  INH
 3383:     F261 50 55 4C 58                    FCC  'PULX'
 3384:     F265 38                             FCB  $38
 3385:     F266 01                             FCB  INH
 3386:     F267 50 55 4C 59                    FCC  'PULY'
 3387:     F26B 38                             FCB  $38
 3388:     F26C 02                             FCB  P2INH
 3389:     F26D 52 4F 4C 20                    FCC  'ROL '
 3390:     F271 69                             FCB  $69
 3391:     F272 04                             FCB  GRP2
 3392:     F273 52 4F 4C 41                    FCC  'ROLA'
 3393:     F277 49                             FCB  $49
 3394:     F278 01                             FCB  INH
 3395:     F279 52 4F 4C 42                    FCC  'ROLB'
 3396:     F27D 59                             FCB  $59
 3397:     F27E 01                             FCB  INH
 3398:     F27F 52 4F 52 20                    FCC  'ROR '
 3399:     F283 66                             FCB  $66
 3400:     F284 04                             FCB  GRP2
 3401:     F285 52 4F 52 41                    FCC  'RORA'
 3402:     F289 46                             FCB  $46
 3403:     F28A 01                             FCB  INH
 3404:     F28B 52 4F 52 42                    FCC  'RORB'
 3405:     F28F 56                             FCB  $56
 3406:     F290 01                             FCB  INH
 3407:     F291 52 54 49 20                    FCC  'RTI '
 3408:     F295 3B                             FCB  $3B
 3409:     F296 01                             FCB  INH
 3410:     F297 52 54 53 20                    FCC  'RTS '
 3411:     F29B 39                             FCB  $39
 3412:     F29C 01                             FCB  INH
 3413:     F29D 53 42 41 20                    FCC  'SBA '
 3414:     F2A1 10                             FCB  $10
 3415:     F2A2 01                             FCB  INH
 3416:     F2A3 53 42 43 41                    FCC  'SBCA'
 3417:     F2A7 82                             FCB  $82
 3418:     F2A8 03                             FCB  GEN
 3419:     F2A9 53 42 43 42                    FCC  'SBCB'
 3420:     F2AD C2                             FCB  $C2
 3421:     F2AE 03                             FCB  GEN
 3422:     F2AF 53 45 43 20                    FCC  'SEC '
 3423:     F2B3 0D                             FCB  $0D
 3424:     F2B4 01                             FCB  INH
 3425:     F2B5 53 45 49 20                    FCC  'SEI '
 3426:     F2B9 0F                             FCB  $0F
 3427:     F2BA 01                             FCB  INH
 3428:     F2BB 53 45 56 20                    FCC  'SEV '
 3429:     F2BF 0B                             FCB  $0B
 3430:     F2C0 01                             FCB  INH
 3431:     F2C1 53 54 41 41                    FCC  'STAA'
 3432:     F2C5 87                             FCB  $87
 3433:     F2C6 07                             FCB  NIMM
 3434:     F2C7 53 54 41 42                    FCC  'STAB'
 3435:     F2CB C7                             FCB  $C7
 3436:     F2CC 07                             FCB  NIMM
 3437:     F2CD 53 54 44 20                    FCC  'STD '
 3438:     F2D1 CD                             FCB  $CD
 3439:     F2D2 07                             FCB  NIMM
 3440:     F2D3 53 54 4F 50                    FCC  'STOP'
 3441:     F2D7 CF                             FCB  $CF
 3442:     F2D8 01                             FCB  INH
 3443:     F2D9 53 54 53 20                    FCC  'STS '
 3444:     F2DD 8F                             FCB  $8F
 3445:     F2DE 07                             FCB  NIMM
 3446:     F2DF 53 54 58 20                    FCC  'STX '
 3447:     F2E3 CF                             FCB  $CF
 3448:     F2E4 10                             FCB  XNIMM
 3449:     F2E5 53 54 59 20                    FCC  'STY '
 3450:     F2E9 CF                             FCB  $CF
 3451:     F2EA 12                             FCB  YNIMM
 3452:     F2EB 53 55 42 41                    FCC  'SUBA'
 3453:     F2EF 80                             FCB  $80
 3454:     F2F0 03                             FCB  GEN
 3455:     F2F1 53 55 42 42                    FCC  'SUBB'
 3456:     F2F5 C0                             FCB  $C0
 3457:     F2F6 03                             FCB  GEN
 3458:     F2F7 53 55 42 44                    FCC  'SUBD'
 3459:     F2FB 83                             FCB  $83
 3460:     F2FC 08                             FCB  LIMM
 3461:     F2FD 53 57 49 20                    FCC  'SWI '
 3462:     F301 3F                             FCB  $3F
 3463:     F302 01                             FCB  INH
 3464:     F303 54 41 42 20                    FCC  'TAB '
 3465:     F307 16                             FCB  $16
 3466:     F308 01                             FCB  INH
 3467:     F309 54 41 50 20                    FCC  'TAP '
 3468:     F30D 06                             FCB  $06
 3469:     F30E 01                             FCB  INH
 3470:     F30F 54 42 41 20                    FCC  'TBA '
 3471:     F313 17                             FCB  $17
 3472:     F314 01                             FCB  INH
 3473:     F315 54 50 41 20                    FCC  'TPA '
 3474:     F319 07                             FCB  $07
 3475:     F31A 01                             FCB  INH
 3476:     F31B 54 45 53 54                    FCC  'TEST'
 3477:     F31F 00                             FCB  $00
 3478:     F320 01                             FCB  INH
 3479:     F321 54 53 54 20                    FCC  'TST '
 3480:     F325 6D                             FCB  $6D
 3481:     F326 04                             FCB  GRP2
 3482:     F327 54 53 54 41                    FCC  'TSTA'
 3483:     F32B 4D                             FCB  $4D
 3484:     F32C 01                             FCB  INH
 3485:     F32D 54 53 54 42                    FCC  'TSTB'
 3486:     F331 5D                             FCB  $5D
 3487:     F332 01                             FCB  INH
 3488:     F333 54 53 58 20                    FCC  'TSX '
 3489:     F337 30                             FCB  $30
 3490:     F338 01                             FCB  INH
 3491:     F339 54 53 59 20                    FCC  'TSY '
 3492:     F33D 30                             FCB  $30
 3493:     F33E 02                             FCB  P2INH
 3494:     F33F 54 58 53 20                    FCC  'TXS '
 3495:     F343 35                             FCB  $35
 3496:     F344 01                             FCB  INH
 3497:     F345 54 59 53 20                    FCC  'TYS '
 3498:     F349 35                             FCB  $35
 3499:     F34A 02                             FCB  P2INH
 3500:     F34B 57 41 49 20                    FCC  'WAI '
 3501:     F34F 3E                             FCB  $3E
 3502:     F350 01                             FCB  INH
 3503:     F351 58 47 44 58                    FCC  'XGDX'
 3504:     F355 8F                             FCB  $8F
 3505:     F356 01                             FCB  INH
 3506:     F357 58 47 44 59                    FCC  'XGDY'
 3507:     F35B 8F                             FCB  $8F
 3508:     F35C 02                             FCB  P2INH
 3509:     F35D 42 52 53 45                    FCC  'BRSE'     ;   bit direct modes for
 3510:     F361 12                             FCB  $12         ;    disassembler.
 3511:     F362 16                             FCB  BTBD
 3512:     F363 42 52 43 4C                    FCC  'BRCL'
 3513:     F367 13                             FCB  $13
 3514:     F368 16                             FCB  BTBD
 3515:     F369 42 53 45 54                    FCC  'BSET'
 3516:     F36D 14                             FCB  $14
 3517:     F36E 17                             FCB  SETCLRD
 3518:     F36F 42 43 4C 52                    FCC  'BCLR'
 3519:     F373 15                             FCB  $15
 3520:     F374 17                             FCB  SETCLRD
 3521:     F375 04                             FCB  EOT          ;   End of table
 3522:                                 
 3523:                                 **********************************************
 3524:          =00000000              PG1     EQU     $0
 3525:          =00000001              PG2     EQU     $1
 3526:          =00000002              PG3     EQU     $2
 3527:          =00000003              PG4     EQU     $3
 3528:                                 
 3529:                                 ******************
 3530:                                 *disassem() - disassemble the opcode.
 3531:                                 ******************
 3532:                                 *(check for page prebyte)
 3533:                                 *baseop=pc[0];
 3534:                                 *pnorm=PG1;
 3535:                                 *if(baseop==$18) pnorm=PG2;
 3536:                                 *if(baseop==$1A) pnorm=PG3;
 3537:                                 *if(baseop==$CD) pnorm=PG4;
 3538:                                 *if(pnorm != PG1) dispc=pc+1;
 3539:                                 *else dispc=pc; (dispc points to next byte)
 3540:                                 
 3541:          =0000F376              DISASSM EQU  *
 3542:     F376 DE B0                          LDX  PC      ;   address
 3543:     F378 A6 00                          LDAA 0,X      ;  opcode
 3544:     F37A C6 00                          LDAB #PG1
 3545:     F37C 81 18                          CMPA #$18
 3546:     F37E 27 0A                          BEQ  DISP2     ; jump if page2
 3547:     F380 81 1A                          CMPA #$1A
 3548:     F382 27 05                          BEQ  DISP3      ;jump if page3
 3549:     F384 81 CD                          CMPA #$CD
 3550:     F386 26 04                          BNE  DISP1      ;jump if not page4
 3551:     F388 5C                     DISP4   INCB            ;set up page value
 3552:     F389 5C                     DISP3   INCB
 3553:     F38A 5C                     DISP2   INCB
 3554:     F38B 08                             INX
 3555:     F38C DF B6                  DISP1   STX  DISPC      ;point to opcode
 3556:     F38E D7 C3                          STAB PNORM      ;save page
 3557:                                 
 3558:                                 *If(opcode == ($00-$5F or $8D or $8F or $CF))
 3559:                                 *  if(pnorm == (PG3 or PG4))
 3560:                                 *      disillop(); return();
 3561:                                 *  b=disrch(opcode,NULL);
 3562:                                 *  if(b==0) disillop(); return();
 3563:                                 
 3564:     F390 A6 00                          LDAA 0,X  ;get current opcode
 3565:     F392 97 B4                          STAA BASEOP
 3566:     F394 08                             INX
 3567:     F395 DF B6                          STX  DISPC      ;point to next byte
 3568:     F397 81 5F                          CMPA #$5F
 3569:     F399 23 0F                          BLS  DIS1       ;jump if in range
 3570:     F39B 81 8D                          CMPA #$8D
 3571:     F39D 27 0B                          BEQ  DIS1       ;jump if bsr
 3572:     F39F 81 8F                          CMPA #$8F
 3573:     F3A1 27 07                          BEQ  DIS1       ;jump if xgdx
 3574:     F3A3 81 CF                          CMPA #$CF
 3575:     F3A5 27 03                          BEQ  DIS1       ;jump if stop
 3576:     F3A7 7E F441                        JMP  DISGRP     ;try next part of map
 3577:     F3AA D6 C3                  DIS1    LDAB PNORM
 3578:     F3AC C1 02                          CMPB #PG3
 3579:     F3AE 25 04                          BLO  DIS2       ;jump if page 1 or 2
 3580:     F3B0 BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3581:     F3B3 39                             RTS
 3582:     F3B4 D6 B4                  DIS2    LDAB BASEOP     ;opcode
 3583:     F3B6 5F                             CLRB            ;class=null
 3584:     F3B7 BD F52A                        JSR  DISRCH
 3585:     F3BA 5D                             TSTB
 3586:     F3BB 26 04                          BNE  DISPEC     ;jump if opcode found
 3587:     F3BD BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3588:     F3C0 39                             RTS
 3589:                                 
 3590:                                 *   if(opcode==$8D) dissrch(opcode,REL);
 3591:                                 *   if(opcode==($8F or $CF)) disrch(opcode,INH);
 3592:                                 
 3593:     F3C1 96 B4                  DISPEC  LDAA BASEOP
 3594:     F3C3 81 8D                          CMPA #$8D
 3595:     F3C5 26 04                          BNE  DISPEC1
 3596:     F3C7 C6 05                          LDAB #REL
 3597:     F3C9 20 0A                          BRA  DISPEC3    ;look for BSR opcode
 3598:     F3CB 81 8F                  DISPEC1 CMPA #$8F
 3599:     F3CD 27 04                          BEQ  DISPEC2    ;jump if XGDX opcode
 3600:     F3CF 81 CF                          CMPA #$CF
 3601:     F3D1 26 05                          BNE  DISINH     ;jump not STOP opcode
 3602:     F3D3 C6 01                  DISPEC2 LDAB #INH
 3603:     F3D5 BD F52A                DISPEC3 JSR  DISRCH     ;find other entry in table
 3604:                                 
 3605:                                 *   if(class==INH)           /* INH */
 3606:                                 *      if(pnorm==PG2)
 3607:                                 *         b=disrch(baseop,P2INH);
 3608:                                 *         if(b==0) disillop(); return();
 3609:                                 *      prntmne();
 3610:                                 *      return();
 3611:                                 
 3612:          =0000F3D8              DISINH  EQU  *
 3613:     F3D8 D6 B5                          LDAB CLASS
 3614:     F3DA C1 01                          CMPB #INH
 3615:     F3DC 26 18                          BNE  DISREL     ;jump if not inherent
 3616:     F3DE D6 C3                          LDAB PNORM
 3617:     F3E0 C1 00                          CMPB #PG1
 3618:     F3E2 27 0E                          BEQ  DISINH1    ;jump if page1
 3619:     F3E4 96 B4                          LDAA BASEOP     ;get opcode
 3620:     F3E6 C6 02                          LDAB #P2INH     ;class=p2inh
 3621:     F3E8 BD F52A                        JSR  DISRCH
 3622:     F3EB 5D                             TSTB
 3623:     F3EC 26 04                          BNE  DISINH1    ;jump if found
 3624:     F3EE BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3625:     F3F1 39                             RTS
 3626:     F3F2 BD F54D                DISINH1 JSR  PRNTMNE
 3627:     F3F5 39                             RTS
 3628:                                 
 3629:                                 *   elseif(class=REL)       /* REL */
 3630:                                 *      if(pnorm != PG1)
 3631:                                 *         disillop(); return();
 3632:                                 *      prntmne();
 3633:                                 *      disrelad();
 3634:                                 *      return();
 3635:                                 
 3636:          =0000F3F6              DISREL  EQU  *
 3637:     F3F6 D6 B5                          LDAB CLASS
 3638:     F3F8 C1 05                          CMPB #REL
 3639:     F3FA 26 10                          BNE  DISBTD
 3640:     F3FC 7D 00C3                        TST  PNORM
 3641:     F3FF 27 04                          BEQ  DISREL1    ;jump if page1
 3642:     F401 BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3643:     F404 39                             RTS
 3644:     F405 BD F54D                DISREL1 JSR  PRNTMNE    ;output mnemonic
 3645:     F408 BD F583                        JSR  DISRELAD   ;compute relative address
 3646:     F40B 39                             RTS
 3647:                                 
 3648:                                 *   else           /* SETCLR,SETCLRD,BTB,BTBD */
 3649:                                 *      if(class == (SETCLRD or BTBD))
 3650:                                 *         if(pnorm != PG1)
 3651:                                 *            disillop(); return();   /* illop */
 3652:                                 *         prntmne();           /* direct */
 3653:                                 *         disdir();           /* output $byte */
 3654:                                 *      else (class == (SETCLR or BTB))
 3655:                                 *         prntmne();           /* indexed */
 3656:                                 *         disindx();
 3657:                                 *      outspac();
 3658:                                 *      disdir();
 3659:                                 *      outspac();
 3660:                                 *      if(class == (BTB or BTBD))
 3661:                                 *         disrelad();
 3662:                                 *   return();
 3663:                                 
 3664:          =0000F40C              DISBTD  EQU  *
 3665:     F40C D6 B5                          LDAB CLASS
 3666:     F40E C1 17                          CMPB #SETCLRD
 3667:     F410 27 04                          BEQ  DISBTD1
 3668:     F412 C1 16                          CMPB #BTBD
 3669:     F414 26 11                          BNE  DISBIT     ;jump not direct bitop
 3670:     F416 7D 00C3                DISBTD1 TST  PNORM
 3671:     F419 27 04                          BEQ  DISBTD2    ;jump if page 1
 3672:     F41B BD F5FB                        JSR  DISILLOP
 3673:     F41E 39                             RTS
 3674:     F41F BD F54D                DISBTD2 JSR  PRNTMNE
 3675:     F422 BD F5DB                        JSR  DISDIR     ;operand(direct)
 3676:     F425 20 06                          BRA  DISBIT1
 3677:          =0000F427              DISBIT  EQU  *
 3678:     F427 BD F54D                        JSR  PRNTMNE
 3679:     F42A BD F567                        JSR  DISINDX    ;operand(indexed)
 3680:     F42D BD E502                DISBIT1 JSR  OUTSPAC
 3681:     F430 BD F5DB                        JSR  DISDIR     ;mask
 3682:     F433 D6 B5                          LDAB CLASS
 3683:     F435 C1 13                          CMPB #BTB
 3684:     F437 27 04                          BEQ  DISBIT2    ;jump if btb
 3685:     F439 C1 16                          CMPB #BTBD
 3686:     F43B 26 03                          BNE  DISBIT3    ;jump if not bit branch
 3687:     F43D BD F583                DISBIT2 JSR  DISRELAD   ;relative address
 3688:     F440 39                     DISBIT3 RTS
 3689:                                 
 3690:                                 
 3691:                                 *Elseif($60 <= opcode <= $7F)  /*  GRP2 */
 3692:                                 *   if(pnorm == (PG3 or PG4))
 3693:                                 *      disillop(); return();
 3694:                                 *   if((pnorm==PG2) and (opcode != $6x))
 3695:                                 *      disillop(); return();
 3696:                                 *   b=disrch(baseop & $6F,NULL);
 3697:                                 *   if(b==0) disillop(); return();
 3698:                                 *   prntmne();
 3699:                                 *   if(opcode == $6x)
 3700:                                 *      disindx();
 3701:                                 *   else
 3702:                                 *      disext();
 3703:                                 *   return();
 3704:                                 
 3705:          =0000F441              DISGRP  EQU  *
 3706:     F441 81 7F                          CMPA #$7F       ;a=opcode
 3707:     F443 22 2A                          BHI  DISNEXT    ;try next part of map
 3708:     F445 D6 C3                          LDAB PNORM
 3709:     F447 C1 02                          CMPB #PG3
 3710:     F449 25 04                          BLO  DISGRP2    ;jump if page 1 or 2
 3711:     F44B BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3712:     F44E 39                             RTS
 3713:     F44F 84 6F                  DISGRP2 ANDA #$6F       ;mask bit 4
 3714:     F451 5F                             CLRB            ;class=null
 3715:     F452 BD F52A                        JSR  DISRCH
 3716:     F455 5D                             TSTB
 3717:     F456 26 04                          BNE  DISGRP3    ;jump if found
 3718:     F458 BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3719:     F45B 39                             RTS
 3720:     F45C BD F54D                DISGRP3 JSR  PRNTMNE
 3721:     F45F 96 B4                          LDAA BASEOP     ;get opcode
 3722:     F461 84 F0                          ANDA #$F0
 3723:     F463 81 60                          CMPA #$60
 3724:     F465 26 04                          BNE  DISGRP4    ;jump if not 6x
 3725:     F467 BD F567                        JSR  DISINDX    ;operand(indexed)
 3726:     F46A 39                             RTS
 3727:     F46B BD F5E8                DISGRP4 JSR  DISEXT     ;operand(extended)
 3728:     F46E 39                             RTS
 3729:                                 
 3730:                                 *Else  ($80 <= opcode <= $FF)
 3731:                                 *   if(opcode == ($87 or $C7))
 3732:                                 *      disillop(); return();
 3733:                                 *   b=disrch(opcode&$CF,NULL);
 3734:                                 *   if(b==0) disillop(); return();
 3735:                                 
 3736:          =0000F46F              DISNEXT EQU  *
 3737:     F46F 81 87                          CMPA #$87       ;a=opcode
 3738:     F471 27 04                          BEQ  DISNEX1
 3739:     F473 81 C7                          CMPA #$C7
 3740:     F475 26 04                          BNE  DISNEX2
 3741:     F477 BD F5FB                DISNEX1 JSR  DISILLOP   ;"illegal opcode"
 3742:     F47A 39                             RTS
 3743:     F47B 84 CF                  DISNEX2 ANDA #$CF
 3744:     F47D 5F                             CLRB            ;class=null
 3745:     F47E BD F52A                        JSR  DISRCH
 3746:     F481 5D                             TSTB
 3747:     F482 26 04                          BNE  DISNEW     ;jump if mne found
 3748:     F484 BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3749:     F487 39                             RTS
 3750:                                 
 3751:                                 *   if(opcode&$CF==$8D) disrch(baseop,NIMM; (jsr)
 3752:                                 *   if(opcode&$CF==$8F) disrch(baseop,NIMM; (sts)
 3753:                                 *   if(opcode&$CF==$CF) disrch(baseop,XNIMM; (stx)
 3754:                                 *   if(opcode&$CF==$83) disrch(baseop,LIMM); (subd)
 3755:                                 
 3756:     F488 96 B4                  DISNEW  LDAA BASEOP
 3757:     F48A 84 CF                          ANDA #$CF
 3758:     F48C 81 8D                          CMPA #$8D
 3759:     F48E 26 04                          BNE  DISNEW1    ;jump not jsr
 3760:     F490 C6 07                          LDAB #NIMM
 3761:     F492 20 16                          BRA  DISNEW4
 3762:     F494 81 8F                  DISNEW1 CMPA #$8F
 3763:     F496 26 04                          BNE  DISNEW2    ;jump not sts
 3764:     F498 C6 07                          LDAB #NIMM
 3765:     F49A 20 0E                          BRA  DISNEW4
 3766:     F49C 81 CF                  DISNEW2 CMPA #$CF
 3767:     F49E 26 04                          BNE  DISNEW3    ;jump not stx
 3768:     F4A0 C6 10                          LDAB #XNIMM
 3769:     F4A2 20 06                          BRA  DISNEW4
 3770:     F4A4 81 83                  DISNEW3 CMPA #$83
 3771:     F4A6 26 0C                          BNE  DISGEN     ;jump not subd
 3772:     F4A8 C6 08                          LDAB #LIMM
 3773:     F4AA BD F52A                DISNEW4 JSR  DISRCH
 3774:     F4AD 5D                             TSTB
 3775:     F4AE 26 04                          BNE  DISGEN     ;jump if found
 3776:     F4B0 BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3777:     F4B3 39                             RTS
 3778:                                 
 3779:                                 *   if(class == (GEN or NIMM or LIMM   ))   /* GEN,NIMM,LIMM,CPD */
 3780:                                 *      if(opcode&$CF==$83)
 3781:                                 *         if(pnorm==(PG3 or PG4)) disrch(opcode#$CF,CPD)
 3782:                                 *         class=LIMM;
 3783:                                 *      if((pnorm == (PG2 or PG4) and (opcode != ($Ax or $Ex)))
 3784:                                 *         disillop(); return();
 3785:                                 *      disgenrl();
 3786:                                 *      return();
 3787:                                 
 3788:     F4B4 D6 B5                  DISGEN  LDAB CLASS      ;get class
 3789:     F4B6 C1 03                          CMPB #GEN
 3790:     F4B8 27 08                          BEQ  DISGEN1
 3791:     F4BA C1 07                          CMPB #NIMM
 3792:     F4BC 27 04                          BEQ  DISGEN1
 3793:     F4BE C1 08                          CMPB #LIMM
 3794:     F4C0 26 31                          BNE  DISXLN     ;jump if other class
 3795:     F4C2 96 B4                  DISGEN1 LDAA BASEOP
 3796:     F4C4 84 CF                          ANDA #$CF
 3797:     F4C6 81 83                          CMPA #$83
 3798:     F4C8 26 0F                          BNE  DISGEN3    ;jump if not #$83
 3799:     F4CA D6 C3                          LDAB PNORM
 3800:     F4CC C1 02                          CMPB #PG3
 3801:     F4CE 25 09                          BLO  DISGEN3    ;jump not pg3 or 4
 3802:     F4D0 C6 15                          LDAB #CPD
 3803:     F4D2 BD F52A                        JSR  DISRCH     ;look for cpd mne
 3804:     F4D5 C6 08                          LDAB #LIMM
 3805:     F4D7 D7 B5                          STAB CLASS      ;set class to limm
 3806:     F4D9 D6 C3                  DISGEN3 LDAB PNORM
 3807:     F4DB C1 01                          CMPB #PG2
 3808:     F4DD 27 04                          BEQ  DISGEN4    ;jump if page 2
 3809:     F4DF C1 03                          CMPB #PG4
 3810:     F4E1 26 0C                          BNE  DISGEN5   ;jump not page 2 or 4
 3811:     F4E3 96 B4                  DISGEN4 LDAA BASEOP
 3812:     F4E5 84 B0                          ANDA #$B0       ;mask bits 6,3-0
 3813:     F4E7 81 A0                          CMPA #$A0
 3814:     F4E9 27 04                          BEQ  DISGEN5     ;jump if $Ax or $Ex
 3815:     F4EB BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3816:     F4EE 39                             RTS
 3817:     F4EF BD F5A5                DISGEN5 JSR  DISGENRL   ;process general class
 3818:     F4F2 39                             RTS
 3819:                                 
 3820:                                 *   else       /* XLIMM,XNIMM,YLIMM,YNIMM */
 3821:                                 *      if(pnorm==(PG2 or PG3))
 3822:                                 *         if(class==XLIMM) disrch(opcode&$CF,YLIMM);
 3823:                                 *         else disrch(opcode&$CF,YNIMM);
 3824:                                 *      if((pnorm == (PG3 or PG4))
 3825:                                 *         if(opcode != ($Ax or $Ex))
 3826:                                 *            disillop(); return();
 3827:                                 *      class=LIMM;
 3828:                                 *      disgen();
 3829:                                 *   return();
 3830:                                 
 3831:     F4F3 D6 C3                  DISXLN  LDAB PNORM
 3832:     F4F5 C1 01                          CMPB #PG2
 3833:     F4F7 27 04                          BEQ  DISXLN1    ;jump if page2
 3834:     F4F9 C1 02                          CMPB #PG3
 3835:     F4FB 26 13                          BNE  DISXLN4    ;jump not page3
 3836:     F4FD 96 B4                  DISXLN1 LDAA BASEOP
 3837:     F4FF 84 CF                          ANDA #$CF
 3838:     F501 D6 B5                          LDAB CLASS
 3839:     F503 C1 09                          CMPB #XLIMM
 3840:     F505 26 04                          BNE  DISXLN2
 3841:     F507 C6 11                          LDAB #YLIMM
 3842:     F509 20 02                          BRA  DISXLN3    ;look for ylimm
 3843:     F50B C6 12                  DISXLN2 LDAB #YNIMM     ;look for ynimm
 3844:     F50D BD F52A                DISXLN3 JSR  DISRCH
 3845:     F510 D6 C3                  DISXLN4 LDAB PNORM
 3846:     F512 C1 02                          CMPB #PG3
 3847:     F514 25 0C                          BLO  DISXLN5    ;jump if page 1 or 2
 3848:     F516 96 B4                          LDAA BASEOP     ;get opcode
 3849:     F518 84 B0                          ANDA #$B0       ;mask bits 6,3-0
 3850:     F51A 81 A0                          CMPA #$A0
 3851:     F51C 27 04                          BEQ  DISXLN5    ;jump opcode = $Ax or $Ex
 3852:     F51E BD F5FB                        JSR  DISILLOP   ;"illegal opcode"
 3853:     F521 39                             RTS
 3854:     F522 C6 08                  DISXLN5 LDAB #LIMM
 3855:     F524 D7 B5                          STAB CLASS
 3856:     F526 BD F5A5                        JSR  DISGENRL   ;process general class
 3857:     F529 39                             RTS
 3858:                                 
 3859:                                 
 3860:                                 ******************
 3861:                                 *disrch(a=opcode,b=class)
 3862:                                 *return b=0 if not found
 3863:                                 *  else mneptr=points to mnemonic
 3864:                                 *        class=class of opcode
 3865:                                 ******************
 3866:                                 *x=#MNETABL
 3867:                                 *while(x[0] != eot)
 3868:                                 *   if((opcode==x[4]) && ((class=NULL) || (class=x[5])))
 3869:                                 *      mneptr=x;
 3870:                                 *      class=x[5];
 3871:                                 *      return(1);
 3872:                                 *   x += 6;
 3873:                                 *return(0);      /* not found */
 3874:                                 
 3875:          =0000F52A              DISRCH  EQU  *
 3876:     F52A CE EFF7                        LDX  #MNETABL   ;point to top of table
 3877:     F52D A1 04                  DISRCH1 CMPA 4,X        ;test opcode
 3878:     F52F 26 0F                          BNE  DISRCH3    ;jump not this entry
 3879:     F531 5D                             TSTB
 3880:     F532 27 04                          BEQ  DISRCH2    ;jump if class=null
 3881:     F534 E1 05                          CMPB 5,X        ;test class
 3882:     F536 26 08                          BNE  DISRCH3    ;jump not this entry
 3883:     F538 E6 05                  DISRCH2 LDAB 5,X
 3884:     F53A D7 B5                          STAB CLASS
 3885:     F53C DF BA                          STX  MNEPTR     ;return ptr to mnemonic
 3886:     F53E 5C                             INCB
 3887:     F53F 39                             RTS             ;return found
 3888:     F540 37                     DISRCH3 PSHB            ;save class
 3889:     F541 C6 06                          LDAB #6
 3890:     F543 3A                             ABX
 3891:     F544 E6 00                          LDAB 0,X
 3892:     F546 C1 04                          CMPB #EOT       ;test end of table
 3893:     F548 33                             PULB
 3894:     F549 26 E2                          BNE  DISRCH1
 3895:     F54B 5F                             CLRB
 3896:     F54C 39                             RTS             ;return not found
 3897:                                 
 3898:                                 ******************
 3899:                                 *prntmne() - output the mnemonic pointed
 3900:                                 *at by mneptr.
 3901:                                 ******************
 3902:                                 *outa(mneptr[0-3]);
 3903:                                 *outspac;
 3904:                                 *return();
 3905:                                 
 3906:          =0000F54D              PRNTMNE EQU  *
 3907:     F54D DE BA                          LDX  MNEPTR
 3908:     F54F A6 00                          LDAA 0,X
 3909:     F551 BD E4EC                        JSR  OUTA       ;output char1
 3910:     F554 A6 01                          LDAA 1,X
 3911:     F556 BD E4EC                        JSR  OUTA       ;output char2
 3912:     F559 A6 02                          LDAA 2,X
 3913:     F55B BD E4EC                        JSR  OUTA       ;output char3
 3914:     F55E A6 03                          LDAA 3,X
 3915:     F560 BD E4EC                        JSR  OUTA       ;output char4
 3916:     F563 BD E502                        JSR  OUTSPAC
 3917:     F566 39                             RTS
 3918:                                 
 3919:                                 ******************
 3920:                                 *disindx() - process indexed mode
 3921:                                 ******************
 3922:                                 *disdir();
 3923:                                 *outa(',');
 3924:                                 *if(pnorm == (PG2 or PG4)) outa('Y');
 3925:                                 *else outa('X');
 3926:                                 *return();
 3927:                                 
 3928:          =0000F567              DISINDX EQU  *
 3929:     F567 BD F5DB                        JSR  DISDIR     ;output $byte
 3930:     F56A 86 2C                          LDAA #','
 3931:     F56C BD E4EC                        JSR  OUTA       ;output ,
 3932:     F56F D6 C3                          LDAB PNORM
 3933:     F571 C1 01                          CMPB #PG2
 3934:     F573 27 04                          BEQ  DISIND1    ;jump if page2
 3935:     F575 C1 03                          CMPB #PG4
 3936:     F577 26 04                          BNE  DISIND2    ;jump if not page4
 3937:     F579 86 59                  DISIND1 LDAA #'Y'
 3938:     F57B 20 02                          BRA DISIND3
 3939:     F57D 86 58                  DISIND2 LDAA #'X'
 3940:     F57F BD E4EC                DISIND3 JSR  OUTA       ;output x or y
 3941:     F582 39                             RTS
 3942:                                 
 3943:                                 ******************
 3944:                                 *disrelad() - compute and output relative address.
 3945:                                 ******************
 3946:                                 * braddr = dispc[0] + (dispc++);( 2's comp arith)
 3947:                                 *outa('$');
 3948:                                 *out2bsp(braddr);
 3949:                                 *return();
 3950:                                 
 3951:          =0000F583              DISRELAD EQU *
 3952:     F583 DE B6                          LDX  DISPC
 3953:     F585 E6 00                          LDAB 0,X        ;get relative offset
 3954:     F587 08                             INX
 3955:     F588 DF B6                          STX  DISPC
 3956:     F58A 5D                             TSTB
 3957:     F58B 2B 03                          BMI  DISRLD1    ;jump if negative
 3958:     F58D 3A                             ABX
 3959:     F58E 20 04                          BRA  DISRLD2
 3960:     F590 09                     DISRLD1 DEX
 3961:     F591 5C                             INCB
 3962:     F592 26 FC                          BNE  DISRLD1    ;subtract
 3963:     F594 DF B8                  DISRLD2 STX  BRADDR     ;save address
 3964:     F596 BD E502                        JSR  OUTSPAC
 3965:     F599 86 24                          LDAA #'$'
 3966:     F59B BD E4EC                        JSR  OUTA
 3967:     F59E CE 00B8                        LDX  #BRADDR
 3968:     F5A1 BD E4FC                        JSR  OUT2BSP    ;output address
 3969:     F5A4 39                             RTS
 3970:                                 
 3971:                                 
 3972:                                 ******************
 3973:                                 *disgenrl() - output data for the general cases which
 3974:                                 *includes immediate, direct, indexed, and extended modes.
 3975:                                 ******************
 3976:                                 *prntmne();
 3977:                                 *if(baseop == ($8x or $Cx))   /* immediate */
 3978:                                 *   outa('#');
 3979:                                 *   disdir();
 3980:                                 *   if(class == LIMM)
 3981:                                 *      out1byt(dispc++);
 3982:                                 *elseif(baseop == ($9x or $Dx))  /* direct */
 3983:                                 *   disdir();
 3984:                                 *elseif(baseop == ($Ax or $Ex)) /* indexed */
 3985:                                 *   disindx();
 3986:                                 *else  (baseop == ($Bx or $Fx)) /* extended */
 3987:                                 *   disext();
 3988:                                 *return();
 3989:                                 
 3990:          =0000F5A5              DISGENRL EQU *
 3991:     F5A5 BD F54D                        JSR  PRNTMNE    ;print mnemonic
 3992:     F5A8 96 B4                          LDAA BASEOP     ;get opcode
 3993:     F5AA 84 B0                          ANDA #$B0       ;mask bits 6,3-0
 3994:     F5AC 81 80                          CMPA #$80
 3995:     F5AE 26 17                          BNE  DISGRL2   ;jump if not immed
 3996:     F5B0 86 23                          LDAA #'#'       ;do immediate
 3997:     F5B2 BD E4EC                        JSR  OUTA
 3998:     F5B5 BD F5DB                        JSR  DISDIR
 3999:     F5B8 D6 B5                          LDAB CLASS
 4000:     F5BA C1 08                          CMPB #LIMM
 4001:     F5BC 27 01                          BEQ  DISGRL1   ;jump class = limm
 4002:     F5BE 39                             RTS
 4003:     F5BF DE B6                  DISGRL1 LDX  DISPC
 4004:     F5C1 BD E4F0                        JSR  OUT1BYT
 4005:     F5C4 DF B6                          STX  DISPC
 4006:     F5C6 39                             RTS
 4007:     F5C7 81 90                  DISGRL2 CMPA #$90
 4008:     F5C9 26 04                          BNE  DISGRL3    ;jump not direct
 4009:     F5CB BD F5DB                        JSR  DISDIR     ;do direct
 4010:     F5CE 39                             RTS
 4011:     F5CF 81 A0                  DISGRL3 CMPA #$A0
 4012:     F5D1 26 04                          BNE  DISGRL4    ;jump not indexed
 4013:     F5D3 BD F567                        JSR  DISINDX    ;do extended
 4014:     F5D6 39                             RTS
 4015:     F5D7 BD F5E8                DISGRL4 JSR  DISEXT     ;do extended
 4016:     F5DA 39                             RTS
 4017:                                 
 4018:                                 *****************
 4019:                                 *disdir() - output "$ next byte"
 4020:                                 *****************
 4021:          =0000F5DB              DISDIR  EQU  *
 4022:     F5DB 86 24                          LDAA #'$'
 4023:     F5DD BD E4EC                        JSR  OUTA
 4024:     F5E0 DE B6                          LDX  DISPC
 4025:     F5E2 BD E4F0                        JSR  OUT1BYT
 4026:     F5E5 DF B6                          STX  DISPC
 4027:     F5E7 39                             RTS
 4028:                                 
 4029:                                 *****************
 4030:                                 *disext() - output "$ next 2 bytes"
 4031:                                 *****************
 4032:          =0000F5E8              DISEXT  EQU  *
 4033:     F5E8 86 24                          LDAA #'$'
 4034:     F5EA BD E4EC                        JSR  OUTA
 4035:     F5ED DE B6                          LDX  DISPC
 4036:     F5EF BD E4FC                        JSR  OUT2BSP
 4037:     F5F2 DF B6                          STX  DISPC
 4038:     F5F4 39                             RTS
 4039:                                 
 4040:                                 
 4041:                                 *****************
 4042:                                 *disillop() - output "illegal opcode"
 4043:                                 *****************
 4044:     F5F5 49 4C 4C 4F 50         DISMSG1 FCC  'ILLOP'
 4045:     F5FA 04                             FCB  EOT
 4046:          =0000F5FB              DISILLOP EQU *
 4047:     F5FB 3C                             PSHX
 4048:     F5FC CE F5F5                        LDX  #DISMSG1
 4049:     F5FF BD E51B                        JSR  OUTSTRG0   ;no cr
 4050:     F602 38                             PULX
 4051:     F603 39                             RTS
 4052:                                 
 4053:                                 
 4054:                                 
 4055:                                 **********
 4056:                                 *   help  -  List buffalo commands to terminal.
 4057:                                 **********
 4058:          =0000F604              HELP     EQU  *
 4059:     F604 CE F60B                         LDX  #HELPMSG1
 4060:     F607 BD E518                         JSR  OUTSTRG    ;print help screen
 4061:     F60A 39                              RTS
 4062:                                 
 4063:          =0000F60B              HELPMSG1 EQU  *
 4064:     F60B 41 53 4D 20 5B 3C               FCC  'ASM [<addr>]  Line asm/disasm'
           F611 61 64 64 72 3E 5D 
           F617 20 20 4C 69 6E 65 
           F61D 20 61 73 6D 2F 64 
           F623 69 73 61 73 6D 
 4065:     F628 0D                              FCB  $0D
 4066:     F629 20 20 5B 2F 2C 3D               FCC  '  [/,=]  Same addr,       [^,-]  Prev addr,       [+,CTLJ] Next addr'
           F62F 5D 20 20 53 61 6D 
           F635 65 20 61 64 64 72 
           F63B 2C 20 20 20 20 20 
           F641 20 20 5B 5E 2C 2D 
           F647 5D 20 20 50 72 65 
           F64D 76 20 61 64 64 72 
           F653 2C 20 20 20 20 20 
           F659 20 20 5B 2B 2C 43 
           F65F 54 4C 4A 5D 20 4E 
           F665 65 78 74 20 61 64 
           F66B 64 72 
 4067:     F66D 0D                              FCB  $0D
 4068:     F66E 20 20 5B 43 52 5D               FCC  '  [CR]  Next opcode,                              [CTLA,.]  Quit'
           F674 20 20 4E 65 78 74 
           F67A 20 6F 70 63 6F 64 
           F680 65 2C 20 20 20 20 
           F686 20 20 20 20 20 20 
           F68C 20 20 20 20 20 20 
           F692 20 20 20 20 20 20 
           F698 20 20 20 20 20 20 
           F69E 20 20 5B 43 54 4C 
           F6A4 41 2C 2E 5D 20 20 
           F6AA 51 75 69 74 
 4069:     F6AE 0D                              FCB  $0D
 4070:     F6AF 42 46 20 3C 61 64               FCC  'BF <addr1> <addr2> [<data>]  Block fill memory'
           F6B5 64 72 31 3E 20 3C 
           F6BB 61 64 64 72 32 3E 
           F6C1 20 5B 3C 64 61 74 
           F6C7 61 3E 5D 20 20 42 
           F6CD 6C 6F 63 6B 20 66 
           F6D3 69 6C 6C 20 6D 65 
           F6D9 6D 6F 72 79 
 4071:     F6DD 0D                              FCB  $0D
 4072:     F6DE 42 52 20 5B 2D 5D               FCC  'BR [-][<addr>] Set up bkpt table'
           F6E4 5B 3C 61 64 64 72 
           F6EA 3E 5D 20 53 65 74 
           F6F0 20 75 70 20 62 6B 
           F6F6 70 74 20 74 61 62 
           F6FC 6C 65 
 4073:     F6FE 0D                              FCB  $0D
 4074:     F6FF 42 55 4C 4B 20 20               FCC  'BULK  Erase EEPROM,                 BULKALL  Erase EEPROM and CONFIG'
           F705 45 72 61 73 65 20 
           F70B 45 45 50 52 4F 4D 
           F711 2C 20 20 20 20 20 
           F717 20 20 20 20 20 20 
           F71D 20 20 20 20 20 20 
           F723 42 55 4C 4B 41 4C 
           F729 4C 20 20 45 72 61 
           F72F 73 65 20 45 45 50 
           F735 52 4F 4D 20 61 6E 
           F73B 64 20 43 4F 4E 46 
           F741 49 47 
 4075:     F743 0D                              FCB  $0D
 4076:     F744 43 41 4C 4C 20 5B               FCC  'CALL [<addr>] Call subroutine'
           F74A 3C 61 64 64 72 3E 
           F750 5D 20 43 61 6C 6C 
           F756 20 73 75 62 72 6F 
           F75C 75 74 69 6E 65 
 4077:     F761 0D                              FCB  $0D
 4078:     F762 47 4F 20 5B 3C 61               FCC  'GO [<addr>] Execute code at addr,        PROCEED  Continue execution'
           F768 64 64 72 3E 5D 20 
           F76E 45 78 65 63 75 74 
           F774 65 20 63 6F 64 65 
           F77A 20 61 74 20 61 64 
           F780 64 72 2C 20 20 20 
           F786 20 20 20 20 20 50 
           F78C 52 4F 43 45 45 44 
           F792 20 20 43 6F 6E 74 
           F798 69 6E 75 65 20 65 
           F79E 78 65 63 75 74 69 
           F7A4 6F 6E 
 4079:     F7A6 0D                              FCB  $0D
 4080:     F7A7 45 45 4D 4F 44 20               FCC  'EEMOD [<addr> [<addr>]] Modify EEPROM range'
           F7AD 5B 3C 61 64 64 72 
           F7B3 3E 20 5B 3C 61 64 
           F7B9 64 72 3E 5D 5D 20 
           F7BF 4D 6F 64 69 66 79 
           F7C5 20 45 45 50 52 4F 
           F7CB 4D 20 72 61 6E 67 
           F7D1 65 
 4081:     F7D2 0D                              FCB  $0D
 4082:     F7D3 4C 4F 41 44 2C 20               FCC  'LOAD, VERIFY [T] <host dwnld command>  Load or verify S-records'
           F7D9 56 45 52 49 46 59 
           F7DF 20 5B 54 5D 20 3C 
           F7E5 68 6F 73 74 20 64 
           F7EB 77 6E 6C 64 20 63 
           F7F1 6F 6D 6D 61 6E 64 
           F7F7 3E 20 20 4C 6F 61 
           F7FD 64 20 6F 72 20 76 
           F803 65 72 69 66 79 20 
           F809 53 2D 72 65 63 6F 
           F80F 72 64 73 
 4083:     F812 0D                              FCB  $0D
 4084:     F813 4D 44 20 5B 3C 61               FCC  'MD [<addr1> [<addr2>]]  Memory dump'
           F819 64 64 72 31 3E 20 
           F81F 5B 3C 61 64 64 72 
           F825 32 3E 5D 5D 20 20 
           F82B 4D 65 6D 6F 72 79 
           F831 20 64 75 6D 70 
 4085:     F836 0D                              FCB  $0D
 4086:     F837 4D 4D 20 5B 3C 61               FCC  'MM [<addr>] or [<addr>]/  Memory Modify'
           F83D 64 64 72 3E 5D 20 
           F843 6F 72 20 5B 3C 61 
           F849 64 64 72 3E 5D 2F 
           F84F 20 20 4D 65 6D 6F 
           F855 72 79 20 4D 6F 64 
           F85B 69 66 79 
 4087:     F85E 0D                              FCB  $0D
 4088:     F85F 20 20 5B 2F 2C 3D               FCC  '  [/,=]  Same addr,  [^,-,CTLH] Prev addr,  [+,CTLJ,SPACE] Next addr'
           F865 5D 20 20 53 61 6D 
           F86B 65 20 61 64 64 72 
           F871 2C 20 20 5B 5E 2C 
           F877 2D 2C 43 54 4C 48 
           F87D 5D 20 50 72 65 76 
           F883 20 61 64 64 72 2C 
           F889 20 20 5B 2B 2C 43 
           F88F 54 4C 4A 2C 53 50 
           F895 41 43 45 5D 20 4E 
           F89B 65 78 74 20 61 64 
           F8A1 64 72 
 4089:     F8A3 0D                              FCB  $0D
 4090:     F8A4 20 20 3C 61 64 64               FCC  '  <addr>O Compute offset,                   [CR]  Quit'
           F8AA 72 3E 4F 20 43 6F 
           F8B0 6D 70 75 74 65 20 
           F8B6 6F 66 66 73 65 74 
           F8BC 2C 20 20 20 20 20 
           F8C2 20 20 20 20 20 20 
           F8C8 20 20 20 20 20 20 
           F8CE 20 20 5B 43 52 5D 
           F8D4 20 20 51 75 69 74 
 4091:     F8DA 0D                              FCB  $0D
 4092:     F8DB 4D 4F 56 45 20 3C               FCC  'MOVE <s1> <s2> [<d>]  Block move'
           F8E1 73 31 3E 20 3C 73 
           F8E7 32 3E 20 5B 3C 64 
           F8ED 3E 5D 20 20 42 6C 
           F8F3 6F 63 6B 20 6D 6F 
           F8F9 76 65 
 4093:     F8FB 0D                              FCB  $0D
 4094:     F8FC 4F 46 46 53 45 54               FCC  'OFFSET [-]<arg>  Offset for download'
           F902 20 5B 2D 5D 3C 61 
           F908 72 67 3E 20 20 4F 
           F90E 66 66 73 65 74 20 
           F914 66 6F 72 20 64 6F 
           F91A 77 6E 6C 6F 61 64 
 4095:     F920 0D                              FCB  $0D
 4096:     F921 52 4D 20 5B 50 2C               FCC  'RM [P,Y,X,A,B,C,S]  Register modify'
           F927 59 2C 58 2C 41 2C 
           F92D 42 2C 43 2C 53 5D 
           F933 20 20 52 65 67 69 
           F939 73 74 65 72 20 6D 
           F93F 6F 64 69 66 79 
 4097:     F944 0D                              FCB  $0D
 4098:     F945 53 54 4F 50 41 54               FCC  'STOPAT <addr>  Trace until addr'
           F94B 20 3C 61 64 64 72 
           F951 3E 20 20 54 72 61 
           F957 63 65 20 75 6E 74 
           F95D 69 6C 20 61 64 64 
           F963 72 
 4099:     F964 0D                              FCB  $0D
 4100:     F965 54 20 5B 3C 6E 3E               FCC  'T [<n>]  Trace n instructions'
           F96B 5D 20 20 54 72 61 
           F971 63 65 20 6E 20 69 
           F977 6E 73 74 72 75 63 
           F97D 74 69 6F 6E 73 
 4101:     F982 0D                              FCB  $0D
 4102:     F983 54 4D 20 20 54 72               FCC  'TM  Transparent mode (CTLA = exit, CTLB = send brk)'
           F989 61 6E 73 70 61 72 
           F98F 65 6E 74 20 6D 6F 
           F995 64 65 20 28 43 54 
           F99B 4C 41 20 3D 20 65 
           F9A1 78 69 74 2C 20 43 
           F9A7 54 4C 42 20 3D 20 
           F9AD 73 65 6E 64 20 62 
           F9B3 72 6B 29 
 4103:     F9B6 0D                              FCB  $0D
 4104:     F9B7 5B 43 54 4C 57 5D               FCC  '[CTLW]  Wait,          [CTLX,DEL] Abort         [CR] Repeat last cmd'
           F9BD 20 20 57 61 69 74 
           F9C3 2C 20 20 20 20 20 
           F9C9 20 20 20 20 20 5B 
           F9CF 43 54 4C 58 2C 44 
           F9D5 45 4C 5D 20 41 62 
           F9DB 6F 72 74 20 20 20 
           F9E1 20 20 20 20 20 20 
           F9E7 5B 43 52 5D 20 52 
           F9ED 65 70 65 61 74 20 
           F9F3 6C 61 73 74 20 63 
           F9F9 6D 64 
 4105:     F9FB 0D                              FCB  $0D
 4106:     F9FC 04                              FCB  4
 4107:                                 
 4108:                                 
 4109:                                 
 4110:                                 **********
 4111:                                 *   call [<addr>] - Execute a jsr to <addr> or user
 4112:                                 *pc value.  Return to monitor via  rts or breakpoint.
 4113:                                 **********
 4114:                                 *a = wskip();
 4115:                                 *if(a != cr)
 4116:                                 *     a = buffarg();
 4117:                                 *     a = wskip();
 4118:                                 *     if(a != cr) return(bad argument)
 4119:                                 *     pc = shftreg;
 4120:     F9FD BD E306                CALL     JSR  WSKIP
 4121:     FA00 27 13                           BEQ  CALL3       ;jump if no arg
 4122:     FA02 BD E23A                         JSR  BUFFARG
 4123:     FA05 BD E306                         JSR  WSKIP
 4124:     FA08 27 07                           BEQ  CALL2       ;jump if cr
 4125:     FA0A CE E6AB                         LDX  #MSG9       ;"bad argument"
 4126:     FA0D BD E518                         JSR  OUTSTRG
 4127:     FA10 39                              RTS
 4128:     FA11 DE 96                  CALL2    LDX  SHFTREG
 4129:     FA13 DF 60                           STX  REGS        ;pc = <addr>
 4130:                                 
 4131:                                 *put return address on user stack
 4132:                                 *setbps();
 4133:                                 *restack();     /* restack and go*/
 4134:     FA15 DE 69                  CALL3    LDX  SP
 4135:     FA17 09                              DEX              ;user stack pointer
 4136:     FA18 CC FA29                         LDD  #RETURN     ;return address
 4137:     FA1B ED 00                           STD  0,X
 4138:     FA1D 09                              DEX
 4139:     FA1E DF 69                           STX  SP          ;new user stack pointer
 4140:     FA20 BD FA9A                         JSR  SETBPS
 4141:     FA23 7F 00C1                         CLR  TMP2        ;1=go, 0=call
 4142:     FA26 7E FB89                         JMP  RESTACK     ;go to user code
 4143:                                 
 4144:                                 **********
 4145:                                 *   return() - Return here from rts after
 4146:                                 *call command.
 4147:                                 **********
 4148:     FA29 36                     RETURN   PSHA             ;save a register
 4149:     FA2A 07                              TPA
 4150:     FA2B 97 68                           STAA REGS+8      ;cc register
 4151:     FA2D 0F                              SEI              ;mask interrupts
 4152:     FA2E 32                              PULA
 4153:     FA2F DD 66                           STD  REGS+6      ;a and b registers
 4154:     FA31 DF 64                           STX  REGS+4      ;x register
 4155:     FA33 18DF 62                         STY  REGS+2      ;y register
 4156:     FA36 9F 69                           STS  SP          ;user stack pointer
 4157:     FA38 9E B2                           LDS  PTR2        ;monitor stack pointer
 4158:     FA3A BD FAC7                         JSR  REMBPS      ;remove breakpoints
 4159:     FA3D BD E508                         JSR  OUTCRLF
 4160:     FA40 BD E1F9                         JSR  RPRINT      ;print user registers
 4161:     FA43 39                              RTS
 4162:                                 
 4163:                                 
 4164:                                 **********
 4165:                                 *   proceed - Same as go except it ignores
 4166:                                 *a breakpoint at the first opcode.  Calls
 4167:                                 *runone for the first instruction only.
 4168:                                 **********
 4169:          =0000FA44              PROCEED  EQU  *
 4170:     FA44 BD FB69                         JSR  RUNONE      ;run one instruction
 4171:     FA47 BD E329                         JSR  CHKABRT     ;check for abort
 4172:     FA4A 7F 00C1                         CLR  TMP2        ;flag for breakpoints
 4173:     FA4D 7C 00C1                         INC  TMP2        ;  1=go 0=call
 4174:     FA50 BD FA9A                         JSR  SETBPS
 4175:     FA53 7E FB89                         JMP  RESTACK     ;go execute
 4176:                                 
 4177:                                 **********
 4178:                                 *   go [<addr>] - Execute starting at <addr> or
 4179:                                 *user's pc value.  Executes an rti to user code.
 4180:                                 *Returns to monitor via an swi through swiin.
 4181:                                 **********
 4182:                                 *a = wskip();
 4183:                                 *if(a != cr)
 4184:                                 *     a = buffarg();
 4185:                                 *     a = wskip();
 4186:                                 *     if(a != cr) return(bad argument)
 4187:                                 *     pc = shftreg;
 4188:                                 *setbps();
 4189:                                 *restack();     /* restack and go*/
 4190:     FA56 BD E306                GO       JSR  WSKIP
 4191:     FA59 27 13                           BEQ  GO2         ;jump if no arg
 4192:     FA5B BD E23A                         JSR  BUFFARG
 4193:     FA5E BD E306                         JSR  WSKIP
 4194:     FA61 27 07                           BEQ  GO1         ;jump if cr
 4195:     FA63 CE E6AB                         LDX  #MSG9       ;"bad argument"
 4196:     FA66 BD E518                         JSR  OUTSTRG
 4197:     FA69 39                              RTS
 4198:     FA6A DE 96                  GO1      LDX  SHFTREG
 4199:     FA6C DF 60                           STX  REGS        ;pc = <addr>
 4200:     FA6E 7F 00C1                GO2      CLR  TMP2
 4201:     FA71 7C 00C1                         INC  TMP2        ;1=go, 0=call
 4202:     FA74 BD FA9A                         JSR  SETBPS
 4203:     FA77 7E FB89                         JMP  RESTACK     ;go to user code
 4204:                                 
 4205:                                 *****
 4206:                                 ** SWIIN - Breakpoints from go or call commands enter here.
 4207:                                 *Remove breakpoints, save user registers, return
 4208:          =0000FA7A              SWIIN    EQU  *        ;swi entry point
 4209:     FA7A 30                              TSX           ;user sp -> x
 4210:     FA7B 9E B2                           LDS  PTR2     ;restore monitor sp
 4211:     FA7D BD FBA8                         JSR  SAVSTACK ;save user regs
 4212:     FA80 BD FAC7                         JSR  REMBPS   ;remove breakpoints from code
 4213:     FA83 DE 60                           LDX  REGS
 4214:     FA85 09                              DEX
 4215:     FA86 DF 60                           STX  REGS     ;save user pc value
 4216:                                 
 4217:                                 *if(call command) remove call return addr from user stack;
 4218:     FA88 7D 00C1                         TST  TMP2     ;1=go, 0=call
 4219:     FA8B 26 06                           BNE  GO3      ;jump if go command
 4220:     FA8D DE 69                           LDX  SP       ;remove return address
 4221:     FA8F 08                              INX            ; user stack pointer
 4222:     FA90 08                              INX
 4223:     FA91 DF 69                           STX  SP
 4224:     FA93 BD E508                GO3      JSR  OUTCRLF  ;print register values
 4225:     FA96 BD E1F9                         JSR  RPRINT
 4226:     FA99 39                              RTS           ;done
 4227:                                 
 4228:                                 **********
 4229:                                 *  setbps - Replace user code with swi's at
 4230:                                 *breakpoint addresses.
 4231:                                 **********
 4232:                                 *for(b=0; b=6; b =+ 2)
 4233:                                 *     x = brktabl[b];
 4234:                                 *     if(x != 0)
 4235:                                 *          optabl[b] = x[0];
 4236:                                 *          x[0] = $3F;
 4237:                                 *Put monitor SWI vector into jump table
 4238:                                 
 4239:     FA9A 5F                     SETBPS   CLRB
 4240:     FA9B CE 009C                SETBPS1  LDX  #BRKTABL
 4241:     FA9E 18CE 00B6                       LDY  #PTR4
 4242:     FAA2 3A                              ABX
 4243:     FAA3 183A                            ABY
 4244:     FAA5 EE 00                           LDX  0,X         ;breakpoint table entry
 4245:     FAA7 27 0A                           BEQ  SETBPS2     ;jump if 0
 4246:     FAA9 A6 00                           LDAA 0,X         ;save user opcode
 4247:     FAAB 18A7 00                         STAA 0,Y
 4248:     FAAE 86 3F                           LDAA #SWI
 4249:     FAB0 BD E290                         JSR  WRITE       ;insert swi into code
 4250:     FAB3 CB 02                  SETBPS2  ADDB #$2
 4251:     FAB5 C1 06                           CMPB #$6
 4252:     FAB7 2F E2                           BLE  SETBPS1     ;loop 4 times
 4253:     FAB9 DE F5                           LDX  JSWI+1
 4254:     FABB DF B4                           STX  PTR3        ;save user swi vector
 4255:     FABD 86 7E                           LDAA #$7E        ;jmp opcode
 4256:     FABF 97 F4                           STAA JSWI
 4257:     FAC1 CE FA7A                         LDX  #SWIIN
 4258:     FAC4 DF F5                           STX  JSWI+1      ;monitor swi vector
 4259:     FAC6 39                              RTS
 4260:                                 
 4261:                                 **********
 4262:                                 *   rembps - Remove breakpoints from user code.
 4263:                                 **********
 4264:                                 *for(b=0; b=6; b =+ 2)
 4265:                                 *     x = brktabl[b];
 4266:                                 *     if(x != 0)
 4267:                                 *          x[0] = optabl[b];
 4268:                                 *Replace user's SWI vector
 4269:     FAC7 5F                     REMBPS   CLRB
 4270:     FAC8 CE 009C                REMBPS1  LDX  #BRKTABL
 4271:     FACB 18CE 00B6                       LDY  #PTR4
 4272:     FACF 3A                              ABX
 4273:     FAD0 183A                            ABY
 4274:     FAD2 EE 00                           LDX  0,X         ;breakpoint table entry
 4275:     FAD4 27 06                           BEQ  REMBPS2     ;jump if 0
 4276:     FAD6 18A6 00                         LDAA 0,Y
 4277:     FAD9 BD E290                         JSR  WRITE       ;restore user opcode
 4278:     FADC CB 02                  REMBPS2  ADDB #$2
 4279:     FADE C1 06                           CMPB #$6
 4280:     FAE0 2F E6                           BLE  REMBPS1     ;loop 4 times
 4281:     FAE2 DE B4                           LDX  PTR3        ;restore user swi vector
 4282:     FAE4 DF F5                           STX  JSWI+1
 4283:     FAE6 39                              RTS
 4284:                                 
 4285:                                 
 4286:                                 **********
 4287:                                 *   trace <n> - Trace n instructions starting
 4288:                                 *at user's pc value. n is a hex number less than
 4289:                                 *$FF (defaults to 1).
 4290:                                 **********
 4291:                                 *a = wskip();
 4292:                                 *if(a != cr)
 4293:                                 *     a = buffarg(); a = wskip();
 4294:                                 *     if(a != cr) return(bad argument);
 4295:                                 *     countt1 = n
 4296:     FAE7 7F 00C3                TRACE    CLR  TMP4
 4297:     FAEA 7C 00C3                         INC  TMP4        ;default count=1
 4298:     FAED 7F 00A9                         CLR  CHRCNT      ;set up for display
 4299:     FAF0 BD E306                         JSR  WSKIP
 4300:     FAF3 27 13                           BEQ  TRACE2      ;jump if cr
 4301:     FAF5 BD E23A                         JSR  BUFFARG
 4302:     FAF8 BD E306                         JSR  WSKIP
 4303:     FAFB 27 07                           BEQ  TRACE1      ;jump if cr
 4304:     FAFD CE E6AB                         LDX  #MSG9       ;"bad argument"
 4305:     FB00 BD E518                         JSR  OUTSTRG
 4306:     FB03 39                              RTS
 4307:     FB04 96 97                  TRACE1   LDAA SHFTREG+1   ;n
 4308:     FB06 97 C3                           STAA TMP4
 4309:                                 
 4310:                                 *Disassemble the line about to be traced
 4311:          =0000FB08              TRACE2   EQU  *
 4312:     FB08 D6 C3                           LDAB TMP4
 4313:     FB0A 37                              PSHB
 4314:     FB0B DE 60                           LDX  REGS
 4315:     FB0D DF B0                           STX  PTR1        ;pc value for disass
 4316:     FB0F BD F376                         JSR  DISASSM
 4317:     FB12 33                              PULB
 4318:     FB13 D7 C3                           STAB TMP4
 4319:                                 
 4320:                                 *run one instruction
 4321:                                 *rprint();
 4322:                                 *while(count > 0) continue trace;
 4323:     FB15 BD FB69                         JSR  RUNONE
 4324:     FB18 BD E329                         JSR  CHKABRT     ;check for abort
 4325:     FB1B BD E538                         JSR  TABTO       ;print registers for
 4326:     FB1E BD E1F9                         JSR  RPRINT       ;   result of trace
 4327:     FB21 7A 00C3                         DEC  TMP4
 4328:     FB24 27 05                           BEQ  TRACDON     ;quit if count=0
 4329:     FB26 BD E508                TRACE3   JSR  OUTCRLF
 4330:     FB29 20 DD                           BRA  TRACE2
 4331:     FB2B 39                     TRACDON  RTS
 4332:                                 
 4333:                                 
 4334:                                 **********
 4335:                                 *   stopat <addr> - Trace instructions until <addr>
 4336:                                 *is reached.
 4337:                                 **********
 4338:                                 *if((a=wskip) != cr)
 4339:                                 *     a = buffarg(); a = wskip();
 4340:                                 *     if(a != cr) return(bad argument);
 4341:                                 *else return(bad argument);
 4342:          =0000FB2C              STOPAT   EQU  *
 4343:     FB2C BD E306                         JSR  WSKIP
 4344:     FB2F 27 18                           BEQ  STOPGO    ;jump if cr - no argument
 4345:     FB31 BD E23A                         JSR  BUFFARG
 4346:     FB34 BD E306                         JSR  WSKIP
 4347:     FB37 27 07                           BEQ  STOPAT1   ;jump if cr
 4348:     FB39 CE E6AB                         LDX  #MSG9     ;"bad argument"
 4349:     FB3C BD E518                         JSR  OUTSTRG
 4350:     FB3F 39                              RTS
 4351:     FB40 7D 00A8                STOPAT1  TST  COUNT
 4352:     FB43 27 04                           BEQ  STOPGO    ;jump if no argument
 4353:     FB45 DE 96                           LDX  SHFTREG
 4354:     FB47 DF AA                           STX  PTRMEM    ;update "current location"
 4355:                                 
 4356:                                 *while(!(ptrmem <= userpc < ptrmem+10)) runone();
 4357:                                 *rprint();
 4358:     FB49 DC 60                  STOPGO   LDD  REGS      ;userpc
 4359:     FB4B 1A93 AA                         CPD  PTRMEM
 4360:     FB4E 25 0A                           BLO  STOPNEXT  ;if(userpc < ptrmem) runone
 4361:     FB50 DC AA                           LDD  PTRMEM
 4362:     FB52 C3 000A                         ADDD #10
 4363:     FB55 1A93 60                         CPD  REGS
 4364:     FB58 22 08                           BHI  STOPDON   ;quit if ptrmem+10 > userpc
 4365:     FB5A BD FB69                STOPNEXT JSR  RUNONE
 4366:     FB5D BD E329                         JSR  CHKABRT   ;check for abort
 4367:     FB60 20 E7                           BRA  STOPGO
 4368:     FB62 BD E508                STOPDON  JSR  OUTCRLF
 4369:     FB65 BD E1F9                         JSR  RPRINT    ;result of trace
 4370:     FB68 39                              RTS            ;done
 4371:                                 
 4372:                                 
 4373:                                 *************************
 4374:                                 * runone - This routine is used by the trace and
 4375:                                 * execute commands to run one only one user instruction.
 4376:                                 *   Control is passed to the user code via an RTI.  OC5
 4377:                                 * is then used to trigger an XIRQ as soon as the first user
 4378:                                 * opcode is fetched.  Control then returns to the monitor
 4379:                                 * through XIRQIN.
 4380:                                 *  Externally, the OC5 pin must be wired to the XIRQ pin.
 4381:                                 ************************
 4382:                                 * Disable oc5 interrupts
 4383:                                 * Put monitor XIRQ vector into jump table
 4384:                                 * Unmask x bit in user ccr
 4385:                                 * Setup OC5 to go low when first user instruction executed
 4386:          =0000FB69              RUNONE  EQU  *
 4387:     FB69 86 7E                          LDAA #$7E        ;put "jmp xirqin" in jump table
 4388:     FB6B 97 D3                          STAA JTOC5
 4389:     FB6D CE FBA5                        LDX  #XIRQIN
 4390:     FB70 DF F2                          STX  JXIRQ+1
 4391:     FB72 96 68                          LDAA REGS+8      ;x bit will be cleared when
 4392:     FB74 84 BF                          ANDA #$BF         ;   rti is executed below
 4393:     FB76 97 68                          STAA REGS+8
 4394:     FB78 C6 57                          LDAB #87        ;cycles to end of rti
 4395:     FB7A FE 100E                        LDX  TCNT
 4396:     FB7D 3A                             ABX             ;                        3~ \
 4397:     FB7E FF 101E                        STX  TOC5       ;oc5 match register      5~  \
 4398:     FB81 B6 1020                        LDAA TCTL1      ;                        4~   \
 4399:     FB84 84 FE                          ANDA #$FE       ;set up oc5 low on match 2~    \
 4400:     FB86 B7 1020                        STAA TCTL1      ;enable oc5 interrupt    4~    / 86~
 4401:                                 
 4402:                                 ** RESTACK - Restore user stack and RTI to user code.
 4403:                                 * This code is the pathway to execution of user code.
 4404:                                 *(Force extended addressing to maintain cycle count)
 4405:                                 *Restore user stack and rti to user code
 4406:          =0000FB89              RESTACK EQU  *                                 ;68~
 4407:     FB89 BF 00B2                        STS  >PTR2      ;save monitor sp
 4408:     FB8C BE 0069                        LDS  >SP        ;user stack pointer
 4409:     FB8F FE 0060                        LDX  >REGS
 4410:     FB92 3C                             PSHX            ;pc
 4411:     FB93 FE 0062                        LDX  >REGS+2
 4412:     FB96 3C                             PSHX            ;y
 4413:     FB97 FE 0064                        LDX  >REGS+4
 4414:     FB9A 3C                             PSHX            ;x
 4415:     FB9B FC 0066                        LDD  >REGS+6
 4416:     FB9E 36                             PSHA            ;a
 4417:     FB9F 37                             PSHB            ;b
 4418:     FBA0 B6 0068                        LDAA >REGS+8
 4419:     FBA3 36                             PSHA            ;ccr
 4420:     FBA4 3B                             RTI
 4421:                                 
 4422:                                 ** Return here from run one line of user code.
 4423:          =0000FBA5              XIRQIN  EQU  *
 4424:     FBA5 30                             TSX             ;user sp -> x
 4425:     FBA6 9E B2                          LDS  PTR2       ;restore monitor sp
 4426:                                 
 4427:                                 ** SAVSTACK - Save user's registers.
 4428:                                 * On entry - x points to top of user stack.
 4429:          =0000FBA8              SAVSTACK EQU *
 4430:     FBA8 A6 00                          LDAA 0,X
 4431:     FBAA 97 68                          STAA REGS+8      ;user ccr
 4432:     FBAC EC 01                          LDD  1,X
 4433:     FBAE 97 67                          STAA REGS+7      ;b
 4434:     FBB0 D7 66                          STAB REGS+6      ;a
 4435:     FBB2 EC 03                          LDD  3,X
 4436:     FBB4 DD 64                          STD  REGS+4      ;x
 4437:     FBB6 EC 05                          LDD  5,X
 4438:     FBB8 DD 62                          STD  REGS+2      ;y
 4439:     FBBA EC 07                          LDD  7,X
 4440:     FBBC DD 60                          STD  REGS        ;pc
 4441:     FBBE C6 08                          LDAB #8
 4442:     FBC0 3A                             ABX
 4443:     FBC1 DF 69                          STX  SP          ;user stack pointer
 4444:     FBC3 B6 1020                        LDAA TCTL1       ;force oc5 pin high which
 4445:     FBC6 8A 03                          ORAA #$03        ;  is tied to xirq line
 4446:     FBC8 B7 1020                        STAA TCTL1
 4447:     FBCB 86 08                          LDAA #$08
 4448:     FBCD B7 100B                        STAA CFORC
 4449:     FBD0 39                             RTS
 4450:                                 
 4451:                                 
 4452:                                 **********
 4453:                                 *   HOST() - Establishes transparent link between
 4454:                                 *       terminal and host.  Port used for host is
 4455:                                 *       determined in the reset initialization routine
 4456:                                 *       and stored in HOSTDEV.
 4457:                                 *          To exit type control A.
 4458:                                 *          To send break to host type control B.
 4459:                                 *if(no external device) return;
 4460:                                 *initialize host port;
 4461:                                 *While( !(control A))
 4462:                                 *     input(terminal); output(host);
 4463:                                 *     input(host); output(terminal);
 4464:                                 
 4465:     FBD1 96 A6                  HOST      LDAA EXTDEV
 4466:     FBD3 26 07                            BNE  HOST0    ;jump if host port avail.
 4467:     FBD5 CE E6B8                          LDX  #MSG10   ;"no host port avail"
 4468:     FBD8 BD E518                          JSR  OUTSTRG
 4469:     FBDB 39                               RTS
 4470:     FBDC 7F 00A4                HOST0     CLR  AUTOLF    ;turn off autolf
 4471:     FBDF BD E347                          JSR  HOSTCO    ;connect sci (evb board)
 4472:     FBE2 BD FC41                          JSR  HOSTINIT  ;initialize host port
 4473:     FBE5 BD E39E                HOST1     JSR  INPUT     ;read terminal
 4474:     FBE8 4D                               TSTA
 4475:     FBE9 27 10                            BEQ  HOST3     ;jump if no char
 4476:     FBEB 81 01                            CMPA #CTLA
 4477:     FBED 27 17                            BEQ  HOSTEND   ;jump if control a
 4478:     FBEF 81 02                            CMPA #CTLB
 4479:     FBF1 26 05                            BNE  HOST2     ;jump if not control b
 4480:     FBF3 BD FC0D                          JSR  TXBREAK   ;send break to host
 4481:     FBF6 20 03                            BRA  HOST3
 4482:     FBF8 BD FC59                HOST2     JSR  HOSTOUT   ;echo to host
 4483:     FBFB BD FC4D                HOST3     JSR  HOSTIN    ;read host
 4484:     FBFE 4D                               TSTA
 4485:     FBFF 27 E4                            BEQ  HOST1     ;jump if no char
 4486:     FC01 BD E3CA                          JSR  OUTPUT    ;echo to terminal
 4487:     FC04 20 DF                            BRA  HOST1
 4488:     FC06 7C 00A4                HOSTEND   INC  AUTOLF    ;turn on autolf
 4489:     FC09 BD E34F                          JSR  TARGCO    ;disconnect sci (evb board)
 4490:     FC0C 39                               RTS            ;return
 4491:                                 
 4492:                                 **********
 4493:                                 * txbreak() - transmit break to host port.
 4494:                                 * The duration of the transmitted break is
 4495:                                 * approximately 200,000 E-clock cycles, or
 4496:                                 * 100ms at 2.0 MHz.
 4497:                                 ***********
 4498:          =0000FC0D              TXBREAK   EQU  *
 4499:     FC0D 96 A7                            LDAA HOSTDEV
 4500:     FC0F 81 03                            CMPA #$03
 4501:     FC11 27 0D                            BEQ  TXBDU    ;jump if duartb is host
 4502:                                 
 4503:     FC13 CE 102D                TXBSCI    LDX  #SCCR2   ;sci is host
 4504:     FC16 1C 00 01                         BSET 0,X,#01  ;set send break bit
 4505:     FC19 8D 1D                            BSR  TXBWAIT
 4506:     FC1B 1D 00 01                         BCLR 0,X,#01  ;clear send break bit
 4507:     FC1E 20 0D                            BRA TXB1
 4508:                                 
 4509:     FC20 CE D008                TXBDU     LDX  #PORTB   ;duart host port
 4510:     FC23 86 60                            LDAA #$60     ;start break cmd
 4511:     FC25 A7 02                            STAA 2,X      ;port b command register
 4512:     FC27 8D 0F                            BSR  TXBWAIT
 4513:     FC29 86 70                            LDAA #$70     ;stop break cmd
 4514:     FC2B A7 02                            STAA 2,X      ;port b command register
 4515:                                 
 4516:     FC2D 86 0D                  TXB1      LDAA #$0D
 4517:     FC2F BD FC59                          JSR  HOSTOUT  ;send carriage return
 4518:     FC32 86 0A                            LDAA #$0A
 4519:     FC34 BD FC59                          JSR  HOSTOUT  ;send linefeed
 4520:     FC37 39                               RTS
 4521:                                 
 4522:     FC38 18CE 6F9B              TXBWAIT   LDY  #$6F9B   ;loop count = 28571
 4523:     FC3C 1809                   TXBWAIT1  DEY           ;7 cycle loop
 4524:     FC3E 26 FC                            BNE  TXBWAIT1
 4525:     FC40 39                               RTS
 4526:                                 
 4527:                                 
 4528:                                 **********
 4529:                                 *   hostinit(), hostin(), hostout() - host i/o
 4530:                                 *routines.  Restores original terminal device.
 4531:                                 **********
 4532:     FC41 D6 A5                  HOSTINIT  LDAB IODEV    ;save terminal
 4533:     FC43 37                               PSHB
 4534:     FC44 D6 A7                            LDAB HOSTDEV
 4535:     FC46 D7 A5                            STAB IODEV    ;point to host
 4536:     FC48 BD E378                          JSR  INIT     ;initialize host
 4537:     FC4B 20 16                            BRA  TERMRES  ;restore terminal
 4538:     FC4D D6 A5                  HOSTIN    LDAB IODEV    ;save terminal
 4539:     FC4F 37                               PSHB
 4540:     FC50 D6 A7                            LDAB HOSTDEV
 4541:     FC52 D7 A5                            STAB IODEV    ;point to host
 4542:     FC54 BD E39E                          JSR  INPUT    ;read host
 4543:     FC57 20 0A                            BRA  TERMRES  ;restore terminal
 4544:     FC59 D6 A5                  HOSTOUT   LDAB IODEV    ;save terminal
 4545:     FC5B 37                               PSHB
 4546:     FC5C D6 A7                            LDAB HOSTDEV
 4547:     FC5E D7 A5                            STAB IODEV    ;point to host
 4548:     FC60 BD E3CA                          JSR  OUTPUT   ;write to host
 4549:     FC63 33                     TERMRES   PULB          ;restore terminal device
 4550:     FC64 D7 A5                            STAB IODEV
 4551:     FC66 39                               RTS
 4552:                                 
 4553:                                 
 4554:                                 **********
 4555:                                 *   load(ptrbuff[]) - Load s1/s9 records from
 4556:                                 *host to memory.  Ptrbuff[] points to string in
 4557:                                 *input buffer which is a command to output s1/s9
 4558:                                 *records from the host ("cat filename" for unix).
 4559:                                 *    Returns error and address if it can't write
 4560:                                 *to a particular location.
 4561:                                 **********
 4562:                                 *   verify(ptrbuff[]) - Verify memory from load
 4563:                                 *command.  Ptrbuff[] is same as for load.
 4564:                                 * tmp3 is used as an error indication, 0=no errors,
 4565:                                 * 1=receiver, 2=rom error, 3=checksum error.
 4566:                                 **********
 4567:     FC67 7F 00C1                VERIFY    CLR  TMP2
 4568:     FC6A 7C 00C1                          INC  TMP2      ;TMP2=1=verify
 4569:     FC6D 20 03                            BRA  LOAD1
 4570:     FC6F 7F 00C1                LOAD      CLR  TMP2       ;    0=load
 4571:                                 
 4572:                                 *a=wskip();
 4573:                                 *if(a = cr) goto transparent mode;
 4574:                                 *if(t option) hostdev = iodev;
 4575:          =0000FC72              LOAD1     EQU  *
 4576:     FC72 7F 00C2                          CLR  TMP3      ;clear error flag
 4577:     FC75 BD E306                          JSR  WSKIP
 4578:     FC78 26 03                            BNE  LOAD2
 4579:     FC7A 7E FBD1                          JMP  HOST      ;go to host if no args
 4580:     FC7D BD E1AD                LOAD2     JSR  UPCASE
 4581:     FC80 81 54                            CMPA #'T'      ;look for t option
 4582:     FC82 26 16                            BNE  LOAD3     ;jump not t option
 4583:     FC84 BD E2F8                          JSR  INCBUFF
 4584:     FC87 BD E2F1                          JSR  READBUFF  ;get next character
 4585:     FC8A BD E2FE                          JSR  DECBUFF
 4586:     FC8D 81 0D                            CMPA #$0D
 4587:     FC8F 26 09                            BNE  LOAD3     ;jump if not t option
 4588:     FC91 7F 00A4                          CLR  AUTOLF
 4589:     FC94 96 A5                            LDAA IODEV
 4590:     FC96 97 A7                            STAA HOSTDEV   ;set host port = terminal
 4591:     FC98 20 1B                            BRA  LOAD10    ;go wait for s1 records
 4592:                                 
 4593:                                 *else while(not cr)
 4594:                                 *     read character from input buffer;
 4595:                                 *     send character to host;
 4596:     FC9A 7F 00A4                LOAD3     CLR  AUTOLF
 4597:     FC9D BD E347                          JSR  HOSTCO    ;connect sci (evb board)
 4598:     FCA0 BD FC41                          JSR  HOSTINIT  ;initialize host port
 4599:     FCA3 BD E2F1                LOAD4     JSR  READBUFF  ;get next char
 4600:     FCA6 BD E2F8                          JSR  INCBUFF
 4601:     FCA9 36                               PSHA           ;save char
 4602:     FCAA BD FC59                          JSR  HOSTOUT   ;output to host
 4603:     FCAD BD E3CA                          JSR  OUTPUT    ;echo to terminal
 4604:     FCB0 32                               PULA
 4605:     FCB1 81 0D                            CMPA #$0D
 4606:     FCB3 26 EE                            BNE  LOAD4     ;jump if not cr
 4607:                                 
 4608:                                 *repeat:                           /* look for s records */
 4609:                                 *      if(hostdev != iodev) check abort;
 4610:                                 *      a = hostin();
 4611:                                 *      if(a = 'S')
 4612:                                 *          a = hostin;
 4613:                                 *          if(a = '1')
 4614:                                 *              checksum = 0;
 4615:                                 *              get byte count in b;
 4616:                                 *              get base address in x;
 4617:                                 *              while(byte count > 0)
 4618:                                 *                  byte();
 4619:                                 *                  x++; b--;
 4620:                                 *                  if(tmp3=0)           /* no error */
 4621:                                 *                      if(load) x[0] = shftreg+1;
 4622:                                 *                      if(x[0] != shftreg+1)
 4623:                                 *                          tmp3 = 2;    /* rom error */
 4624:                                 *                          ptr3 = x;    /* save address */
 4625:                                 *              if(tmp3 = 0) do checksum;
 4626:                                 *              if(checksum err) tmp3 = 3; /* checksum error */
 4627:                                 ** Look for s-record header
 4628:          =0000FCB5              LOAD10    EQU  *
 4629:     FCB5 96 A7                            LDAA HOSTDEV
 4630:     FCB7 91 A5                            CMPA IODEV
 4631:     FCB9 27 03                            BEQ  LOAD11    ;jump if hostdev=iodev
 4632:     FCBB BD E329                          JSR  CHKABRT   ;check for abort
 4633:     FCBE BD FC4D                LOAD11    JSR  HOSTIN    ;read host
 4634:     FCC1 4D                               TSTA
 4635:     FCC2 27 F1                            BEQ  LOAD10    ;jump if no input
 4636:     FCC4 81 53                            CMPA #'S'
 4637:     FCC6 26 ED                            BNE  LOAD10    ;jump if not S
 4638:     FCC8 BD FC4D                LOAD12    JSR  HOSTIN    ;read host
 4639:     FCCB 4D                               TSTA
 4640:     FCCC 27 FA                            BEQ  LOAD12    ;jump if no input
 4641:     FCCE 81 39                            CMPA #'9'
 4642:     FCD0 27 4E                            BEQ  LOAD90    ;jump if S9 record
 4643:     FCD2 81 31                            CMPA #'1'
 4644:     FCD4 26 DF                            BNE  LOAD10    ;jump if not S1
 4645:     FCD6 7F 00C3                          CLR  TMP4      ;clear checksum
 4646:                                 ** Get Byte Count and Starting Address
 4647:     FCD9 BD FD66                          JSR  BYTE
 4648:     FCDC D6 97                            LDAB SHFTREG+1
 4649:     FCDE C0 02                            SUBB #$2       ;b = byte count
 4650:     FCE0 BD FD66                          JSR  BYTE
 4651:     FCE3 BD FD66                          JSR  BYTE
 4652:     FCE6 37                               PSHB           ;save byte count
 4653:     FCE7 DC 96                            LDD  SHFTREG
 4654:     FCE9 D3 AC                            ADDD LDOFFST   ;add offset
 4655:     FCEB 8F                               XGDX           ;x = address+offset
 4656:     FCEC 33                               PULB           ;restore byte count
 4657:     FCED 09                               DEX            ;condition for loop
 4658:                                 ** Get and Store Incoming Data Byte
 4659:     FCEE BD FD66                LOAD20    JSR  BYTE      ;get next byte
 4660:     FCF1 08                               INX
 4661:     FCF2 5A                               DECB           ;check byte count
 4662:     FCF3 27 1B                            BEQ  LOAD30    ;if b=0, go do checksum
 4663:     FCF5 7D 00C2                          TST  TMP3
 4664:     FCF8 26 BB                            BNE  LOAD10    ;jump if error flagged
 4665:     FCFA 7D 00C1                          TST  TMP2
 4666:     FCFD 26 05                            BNE  LOAD21    ;jump if verify
 4667:     FCFF 96 97                            LDAA SHFTREG+1
 4668:     FD01 BD E290                          JSR  WRITE     ;load only
 4669:     FD04 A1 00                  LOAD21    CMPA 0,X       ;verify ram location
 4670:     FD06 27 E6                            BEQ  LOAD20    ;jump if ram ok
 4671:     FD08 86 02                            LDAA #$02
 4672:     FD0A 97 C2                            STAA TMP3      ;indicate rom error
 4673:     FD0C DF B4                            STX  PTR3      ;save error address
 4674:     FD0E 20 DE                            BRA  LOAD20    ;finish download
 4675:                                 ** Get and Test Checksum
 4676:     FD10 7D 00C2                LOAD30    TST  TMP3
 4677:     FD13 26 A0                            BNE  LOAD10    ;jump if error already
 4678:     FD15 96 C3                            LDAA TMP4
 4679:     FD17 4C                               INCA           ;do checksum
 4680:     FD18 27 9B                            BEQ  LOAD10    ;jump if s1 record okay
 4681:     FD1A 86 03                            LDAA #$03
 4682:     FD1C 97 C2                            STAA TMP3      ;indicate checksum error
 4683:     FD1E 20 95                            BRA  LOAD10
 4684:                                 
 4685:                                 *          if(a = '9')
 4686:                                 *              read rest of record;
 4687:                                 *              if(tmp3=2) return("[ptr3]");
 4688:                                 *              if(tmp3=1) return("rcv error");
 4689:                                 *              if(tmp3=3) return("checksum err");
 4690:                                 *              else return("done");
 4691:     FD20 BD FD66                LOAD90    JSR  BYTE
 4692:     FD23 D6 97                            LDAB SHFTREG+1 ;b = byte count
 4693:     FD25 BD FD66                LOAD91    JSR  BYTE
 4694:     FD28 5A                               DECB
 4695:     FD29 26 FA                            BNE  LOAD91    ;loop until end of record
 4696:     FD2B C6 64                            LDAB #$64
 4697:     FD2D BD E2E5                LOAD91A   JSR  DLY10MS   ;delay 1 sec -let host finish
 4698:     FD30 5A                               DECB
 4699:     FD31 26 FA                            BNE  LOAD91A
 4700:     FD33 BD E39E                          JSR  INPUT     ;clear comm device
 4701:     FD36 CC 7E0D                          LDD  #$7E0D    ;put dummy command in inbuff
 4702:     FD39 DD 6B                            STD  INBUFF
 4703:     FD3B 7C 00A4                          INC  AUTOLF    ;turn on autolf
 4704:     FD3E BD E34F                          JSR  TARGCO    ;disconnect sci (evb)
 4705:     FD41 CE E6C5                          LDX  #MSG11    ;"done" default msg
 4706:     FD44 96 C2                            LDAA TMP3
 4707:     FD46 81 02                            CMPA #$02
 4708:     FD48 26 08                            BNE  LOAD92    ;jump not rom error
 4709:     FD4A CE 00B4                          LDX  #PTR3
 4710:     FD4D BD E4FC                          JSR  OUT2BSP   ;address of rom error
 4711:     FD50 20 13                            BRA  LOAD95
 4712:     FD52 81 01                  LOAD92    CMPA #$01
 4713:     FD54 26 05                            BNE  LOAD93    ;jump not rcv error
 4714:     FD56 CE E6E3                          LDX  #MSG14    ;"rcv error"
 4715:     FD59 20 07                            BRA  LOAD94
 4716:     FD5B 81 03                  LOAD93    CMPA #$03
 4717:     FD5D 26 03                            BNE  LOAD94    ;jump not checksum error
 4718:     FD5F CE E6CA                          LDX  #MSG12    ;"checksum error"
 4719:     FD62 BD E518                LOAD94    JSR  OUTSTRG
 4720:     FD65 39                     LOAD95    RTS
 4721:                                 
 4722:                                 
 4723:                                 **********
 4724:                                 *  byte() -  Read 2 ascii bytes from host and
 4725:                                 *convert to one hex byte.  Returns byte
 4726:                                 *shifted into shftreg and added to tmp4.
 4727:                                 **********
 4728:     FD66 37                     BYTE      PSHB
 4729:     FD67 3C                               PSHX
 4730:     FD68 BD FC4D                BYTE0     JSR  HOSTIN    ;read host (1st byte)
 4731:     FD6B 4D                               TSTA
 4732:     FD6C 27 FA                            BEQ  BYTE0     ;loop until input
 4733:     FD6E BD E207                          JSR  HEXBIN
 4734:     FD71 BD FC4D                BYTE1     JSR  HOSTIN    ;read host (2nd byte)
 4735:     FD74 4D                               TSTA
 4736:     FD75 27 FA                            BEQ  BYTE1     ;loop until input
 4737:     FD77 BD E207                          JSR  HEXBIN
 4738:     FD7A 96 97                            LDAA SHFTREG+1
 4739:     FD7C 9B C3                            ADDA TMP4
 4740:     FD7E 97 C3                            STAA TMP4      ;add to checksum
 4741:     FD80 38                               PULX
 4742:     FD81 33                               PULB
 4743:     FD82 39                               RTS
 4744:                                 
 4745:                                 
 4746:                                 **********
 4747:                                 *   offset [<addr>]
 4748:                                 * Specify offset to be added to s-record address when
 4749:                                 * downloading from the host.
 4750:                                 *  OFFSET                -show the current offset
 4751:                                 *  OFFSET <data>         -current offset = data
 4752:                                 *  OFFSET -<data>        -current offset = 0 - data
 4753:                                 **********
 4754:                                 *if(<data>) then offset = data;
 4755:                                 *print(offset);
 4756:          =0000FD83              OFFSET   EQU  *
 4757:     FD83 7F 00C3                         CLR  TMP4      ;minus indicator
 4758:     FD86 BD E306                         JSR  WSKIP
 4759:     FD89 27 28                           BEQ  OFFST3    ;jump if cr (no argument)
 4760:     FD8B 81 2D                           CMPA #'-'
 4761:     FD8D 26 09                           BNE  OFFST1    ;jump not -
 4762:     FD8F 7C 00C3                         INC  TMP4      ;set minus sign flag
 4763:     FD92 BD E2F8                         JSR  INCBUFF   ;move buffer pointer
 4764:     FD95 BD E306                         JSR  WSKIP
 4765:     FD98 BD E23A                OFFST1   JSR  BUFFARG   ;read argument
 4766:     FD9B 7D 00A8                         TST  COUNT
 4767:     FD9E 27 1D                           BEQ  OFFSTER  ;jump if bad argument
 4768:     FDA0 BD E306                         JSR  WSKIP
 4769:     FDA3 26 18                           BNE  OFFSTER   ;jump if not cr
 4770:     FDA5 DC 96                           LDD  SHFTREG   ;get offset value
 4771:     FDA7 7D 00C3                         TST  TMP4
 4772:     FDAA 27 05                           BEQ  OFFST2    ;jump if positive
 4773:     FDAC CC 0000                         LDD  #$0000    ;negative - sub from 0
 4774:     FDAF 93 96                           SUBD SHFTREG
 4775:     FDB1 DD AC                  OFFST2   STD  LDOFFST
 4776:     FDB3 BD E508                OFFST3   JSR  OUTCRLF   ;display current offset
 4777:     FDB6 CE 00AC                         LDX  #LDOFFST
 4778:     FDB9 BD E4FC                         JSR  OUT2BSP
 4779:     FDBC 39                              RTS
 4780:                                 
 4781:     FDBD CE E6AB                OFFSTER  LDX  #MSG9     ;"bad argument"
 4782:     FDC0 BD E518                         JSR  OUTSTRG
 4783:     FDC3 39                              RTS
 4784:                                 
 4785:                                 
 4786:                                 
 4787:                                 
 4788:                                 
 4789:                                 **********
 4790:                                 *   register [<name>]  - prints the user regs
 4791:                                 *and opens them for modification.  <name> is
 4792:                                 *the first register opened (default = P).
 4793:                                 *   Subcommands:
 4794:                                 * [<nn>]<space>  Opens the next register.
 4795:                                 * [<nn>]<cr>     Return.
 4796:                                 *    The register value is only changed if
 4797:                                 *    <nn> is entered before the subcommand.
 4798:                                 **********
 4799:                                 *x[] = reglist
 4800:                                 *a = wskip(); a = upcase(a);
 4801:                                 *if(a != cr)
 4802:                                 *     while( a != x[0] )
 4803:                                 *          if( x[0] = "s") return(bad argument);
 4804:                                 *          x[]++;
 4805:                                 *     incbuff(); a = wskip();
 4806:                                 *     if(a != cr) return(bad argument);
 4807:                                 
 4808:     FDC4 CE E1C4                REGISTER LDX  #REGLIST
 4809:     FDC7 BD E306                         JSR  WSKIP      ; a = first char of arg
 4810:     FDCA BD E1AD                         JSR  UPCASE      ;convert to upper case
 4811:     FDCD 81 0D                           CMPA #$D
 4812:     FDCF 27 1C                           BEQ  REG4        ;jump if no argument
 4813:     FDD1 A1 00                  REG1     CMPA 0,X
 4814:     FDD3 27 0E                           BEQ  REG3
 4815:     FDD5 E6 00                           LDAB 0,X
 4816:     FDD7 08                              INX
 4817:     FDD8 C1 53                           CMPB #'S'
 4818:     FDDA 26 F5                           BNE  REG1        ;jump if not "s"
 4819:     FDDC CE E6AB                REG2     LDX  #MSG9       ;"bad argument"
 4820:     FDDF BD E518                         JSR  OUTSTRG
 4821:     FDE2 39                              RTS
 4822:     FDE3 3C                     REG3     PSHX
 4823:     FDE4 BD E2F8                         JSR  INCBUFF
 4824:     FDE7 BD E306                         JSR  WSKIP       ;next char after arg
 4825:     FDEA 38                              PULX
 4826:     FDEB 26 EF                           BNE  REG2        ;jump if not cr
 4827:                                 
 4828:                                 *rprint();
 4829:                                 *     while(x[0] != "s")
 4830:                                 *          rprnt1(x);
 4831:                                 *          a = termarg();    /* read from terminal */
 4832:                                 *          if( ! dchek(a) ) return(bad argument);
 4833:                                 *          if(countu1 != 0)
 4834:                                 *               if(x[14] = 1)
 4835:                                 *                    regs[x[7]++ = shftreg;
 4836:                                 *               regs[x[7]] = shftreg+1;
 4837:                                 *          if(a = cr) break;
 4838:                                 *return;
 4839:                                 
 4840:     FDED BD E1F9                REG4     JSR  RPRINT      ;print all registers
 4841:     FDF0 BD E508                REG5     JSR  OUTCRLF
 4842:     FDF3 BD E1D9                         JSR  RPRNT1      ;print reg name
 4843:     FDF6 7F 0096                         CLR  SHFTREG
 4844:     FDF9 7F 0097                         CLR  SHFTREG+1
 4845:     FDFC BD E25D                         JSR  TERMARG     ;read subcommand
 4846:     FDFF BD E321                         JSR  DCHEK
 4847:     FE02 27 07                           BEQ  REG6        ;jump if delimeter
 4848:     FE04 CE E6AB                         LDX  #MSG9       ;"bad argument"
 4849:     FE07 BD E518                         JSR  OUTSTRG
 4850:     FE0A 39                              RTS
 4851:     FE0B 36                     REG6     PSHA
 4852:     FE0C 3C                              PSHX
 4853:     FE0D 7D 00A8                         TST  COUNT
 4854:     FE10 27 14                           BEQ  REG8        ;jump if no input
 4855:     FE12 E6 07                           LDAB 7,X         ;get reg offset
 4856:     FE14 A6 0E                           LDAA 14,X        ;byte size
 4857:     FE16 CE 0060                         LDX  #REGS       ;user registers
 4858:     FE19 3A                              ABX
 4859:     FE1A 4D                              TSTA
 4860:     FE1B 27 05                           BEQ  REG7        ;jump if 1 byte reg
 4861:     FE1D 96 96                           LDAA SHFTREG
 4862:     FE1F A7 00                           STAA 0,X         ;put in top byte
 4863:     FE21 08                              INX
 4864:     FE22 96 97                  REG7     LDAA SHFTREG+1
 4865:     FE24 A7 00                           STAA 0,X         ;put in bottom byte
 4866:     FE26 38                     REG8     PULX
 4867:     FE27 32                              PULA
 4868:     FE28 E6 00                           LDAB 0,X         ;CHECK FOR REGISTER S
 4869:     FE2A C1 53                           CMPB #'S'
 4870:     FE2C 27 05                           BEQ  REG9        ;jump if "s"
 4871:     FE2E 08                              INX              ;point to next register
 4872:     FE2F 81 0D                           CMPA #$D
 4873:     FE31 26 BD                           BNE  REG5        ;jump if not cr
 4874:     FE33 39                     REG9     RTS
 4875:                                 
 4876:                                 
 4877:                                 * Equates
 4878:          =00000008              JPORTD  EQU   $08
 4879:          =00000009              JDDRD   EQU   $09
 4880:          =0000002B              JBAUD   EQU   $2B
 4881:          =0000002C              JSCCR1  EQU   $2C
 4882:          =0000002D              JSCCR2  EQU   $2D
 4883:          =0000002E              JSCSR   EQU   $2E
 4884:          =0000002F              JSCDAT  EQU   $2F
 4885:                                 *
 4886:                                 
 4887:                                 ************
 4888:                                 *  xboot [<addr1> [<addr2>]] - Use SCI to talk to an 'hc11 in
 4889:                                 * boot mode.  Downloads bytes from addr1 thru addr2.
 4890:                                 * Default addr1 = $C000 and addr2 = $C0ff.
 4891:                                 *
 4892:                                 * IMPORTANT:
 4893:                                 * if talking to an 'A8 or 'A2: use either default addresses or ONLY
 4894:                                 *    addr1 - this sends 256 bytes
 4895:                                 * if talking to an 'E9: include BOTH addr1 and addr2 for variable
 4896:                                 *    length
 4897:                                 ************
 4898:                                 
 4899:                                 *Get arguments
 4900:                                 *If no args, default $C000
 4901:     FE34 BD E306                BOOT    JSR   WSKIP
 4902:     FE37 26 0B                          BNE   BOT1       ;jump if arguments
 4903:     FE39 CE C0FF                        LDX   #$C0FF     ;addr2 default
 4904:     FE3C DF B8                          STX   PTR5
 4905:     FE3E 18CE C000                      LDY   #$C000     ;addr1 default
 4906:     FE42 20 36                          BRA   BOT2       ;go - use default address
 4907:                                 
 4908:                                 *Else get arguments
 4909:     FE44 BD E23A                BOT1    JSR   BUFFARG
 4910:     FE47 7D 00A8                        TST   COUNT
 4911:     FE4A 27 27                          BEQ   BOTERR    ;jump if no address
 4912:     FE4C 18DE 96                        LDY   SHFTREG   ;start address (addr1)
 4913:     FE4F BD E306                        JSR   WSKIP
 4914:     FE52 26 0C                          BNE   BOT1A     ;go get addr2
 4915:     FE54 18DF B8                        STY   PTR5      ;default addr2...
 4916:     FE57 DC B8                          LDD   PTR5      ;...by taking addr1...
 4917:     FE59 C3 00FF                        ADDD  #$FF      ;...and adding 255 to it...
 4918:     FE5C DD B8                          STD   PTR5      ;...for a total download of 256
 4919:     FE5E 20 1A                          BRA   BOT2      ;continue
 4920:                                 *
 4921:     FE60 BD E23A                BOT1A   JSR   BUFFARG
 4922:     FE63 7D 00A8                        TST   COUNT
 4923:     FE66 27 0B                          BEQ   BOTERR    ;jump if no address
 4924:     FE68 DE 96                          LDX   SHFTREG   ;end address (addr2)
 4925:     FE6A DF B8                          STX   PTR5
 4926:     FE6C BD E306                        JSR   WSKIP
 4927:     FE6F 26 02                          BNE   BOTERR    ;go use addr1 and addr2
 4928:     FE71 20 07                          BRA   BOT2
 4929:                                 
 4930:                                 *
 4931:     FE73 CE E6AB                BOTERR  LDX   #MSG9     ;"bad argument"
 4932:     FE76 BD E518                        JSR   OUTSTRG
 4933:     FE79 39                             RTS
 4934:                                 
 4935:                                 *Boot routine
 4936:     FE7A C6 FF                  BOT2    LDAB  #$FF       ;control character ($ff -> download)
 4937:     FE7C BD FE92                        JSR   BTSUB      ;set up SCI and send control char
 4938:                                 *                        initializes X as register pointer
 4939:                                 *Download block
 4940:     FE7F 18A6 00                BLOP    LDAA  0,Y
 4941:     FE82 A7 2F                          STAA  JSCDAT,X   ;write to transmitter
 4942:     FE84 1F 2E 50 FC                    BRCLR JSCSR,X,#80,*      ;wait for TDRE
 4943:     FE88 189C B8                        CPY   PTR5       ;if last...
 4944:     FE8B 27 04                          BEQ   BTDONE      ;    ...quit
 4945:     FE8D 1808                           INY              ;else...
 4946:     FE8F 20 EE                          BRA   BLOP        ;    ...send next
 4947:     FE91 39                     BTDONE  RTS
 4948:                                 
 4949:                                 ************************************************
 4950:                                 *Subroutine
 4951:                                 *  btsub   - sets up SCI and outputs control character
 4952:                                 * On entry, B = control character
 4953:                                 * On exit,  X = $1000
 4954:                                 *           A = $0C
 4955:                                 ***************************
 4956:                                 
 4957:          =0000FE92              BTSUB   EQU   *
 4958:     FE92 CE 1000                        LDX   #$1000    ;to use indexed addressing
 4959:     FE95 86 02                          LDAA  #$02
 4960:     FE97 A7 08                          STAA  JPORTD,X  ;drive transmitter line
 4961:     FE99 A7 09                          STAA  JDDRD,X   ;  high
 4962:     FE9B 6F 2D                          CLR   JSCCR2,X  ;turn off XMTR and RCVR
 4963:     FE9D 86 22                          LDAA  #$22      ;BAUD = /16
 4964:     FE9F A7 2B                          STAA  JBAUD,X
 4965:     FEA1 86 0C                          LDAA  #$0C      ;TURN ON XMTR & RCVR
 4966:     FEA3 A7 2D                          STAA  JSCCR2,X
 4967:     FEA5 E7 2F                          STAB  JSCDAT,X
 4968:     FEA7 1F 2E 50 FC                    BRCLR JSCSR,X,#80,*   ;wait for TDRE
 4969:     FEAB 39                             RTS
 4970:                                 
 4971:                                 
 4972:                                 ***********
 4973:                                 * TILDE - This command is put into the combuff by the
 4974:                                 * load command so that extraneous carriage returns after
 4975:                                 * the load will not hang up.
 4976:     FEAC 39                     TILDE   RTS
 4977:                                 
 4978:                                 ******************
 4979:                                 *
 4980:                                 *       EVBTEST - This routine makes it a little easier
 4981:                                 *       on us to test this board.
 4982:                                 *
 4983:                                 ******************
 4984:                                 
 4985:     FEAD 86 FF                  EVBTEST  LDAA  #$FF
 4986:     FEAF B7 1000                         STAA  $1000    ;Write ones to port A
 4987:     FEB2 7F 00A4                         CLR  AUTOLF    ;Turn off auto lf
 4988:     FEB5 BD E347                         JSR  HOSTCO    ;Connect host
 4989:     FEB8 BD FC41                         JSR  HOSTINIT  ;Initialize host
 4990:     FEBB 86 7F                           LDAA #$7f
 4991:     FEBD BD FC59                         JSR  HOSTOUT   ;Send Delete to Altos
 4992:     FEC0 86 0D                           LDAA #$0d
 4993:     FEC2 BD FC59                         JSR  HOSTOUT   ;Send <CR>
 4994:     FEC5 7C 00A4                         INC  AUTOLF    ;Turn on Auto LF
 4995:     FEC8 CE 0070                         LDX  #INBUFF+5 ;Point at Load message
 4996:     FECB DF AE                           STX  PTR0      ;Set pointer for load command
 4997:     FECD 18CE FEEB                       LDY  #MSGEVB   ;Point at cat line
 4998:     FED1 18A6 00                LOOP     LDAA 0,Y       ;Loop to xfer command line
 4999:     FED4 81 04                           CMPA #04       ;Into buffalo line buffer
 5000:     FED6 27 07                           BEQ  DONE      ;Quit on $04
 5001:     FED8 A7 00                           STAA 0,X
 5002:     FEDA 08                              INX            ;next character
 5003:     FEDB 1808                            INY
 5004:     FEDD 20 F2                           BRA  LOOP
 5005:     FEDF 7F 00C1                DONE     CLR  TMP2      ;Set load vs. verify
 5006:     FEE2 BD FC9A                         JSR  LOAD3     ;Jmp into middle of load
 5007:     FEE5 8E 005F                         LDS  #STACK    ;Reset Stack
 5008:     FEE8 7E C0B3                         JMP  $C0B3     ;Jump to Downloaded code
 5009:                                 
 5010:     FEEB 63 61 74 20 65 76      MSGEVB   FCC  /cat evbtest.out/
           FEF1 62 74 65 73 74 2E 
           FEF7 6F 75 74 
 5011:     FEFA 0D                              FCB  $0D
 5012:     FEFB 04                              FCB  $04
 5013:                                 
 5014:                                 
 5015:                                 
 5016:                                 *** Jump table ***
 5017:          =0000FF7C                      ORG     ROMBS+$1F7C
 5018:     FF7C 7E E0CE                .WARMST JMP     MAIN        ;warm start
 5019:     FF7F 7E E1B8                .BPCLR  JMP     BPCLR       ;clear breakpoint table
 5020:     FF82 7E E1F9                .RPRINT JMP     RPRINT      ;display user registers
 5021:     FF85 7E E207                .HEXBIN JMP     HEXBIN      ;convert ascii hex char to binary
 5022:     FF88 7E E23A                .BUFFAR JMP     BUFFARG     ;build hex argument from buffer
 5023:     FF8B 7E E25D                .TERMAR JMP     TERMARG     ;read hex argument from terminal
 5024:     FF8E 7E E285                .CHGBYT JMP     CHGBYT      ;modify memory at address in x
 5025:     FF91 7E E2F1                .READBU JMP     READBUFF    ;read character from buffer
 5026:     FF94 7E E2F8                .INCBUF JMP     INCBUFF     ;increment buffer pointer
 5027:     FF97 7E E2FE                .DECBUF JMP     DECBUFF     ;decrement buffer pointer
 5028:     FF9A 7E E306                .WSKIP  JMP     WSKIP       ;find non-whitespace char in buffer
 5029:     FF9D 7E E329                .CHKABR JMP     CHKABRT     ;check for abort from terminal
 5030:                                 
 5031:          =0000FFA0                      ORG     ROMBS+$1FA0
 5032:     FFA0 7E E1AD                .UPCASE JMP     UPCASE      ;convert to upper case
 5033:     FFA3 7E E316                .WCHEK  JMP     WCHEK       ;check for white space
 5034:     FFA6 7E E321                .DCHEK  JMP     DCHEK       ;check for delimeter
 5035:     FFA9 7E E378                .INIT   JMP     INIT        ;initialize i/o device
 5036:     FFAC 7E E39E                .INPUT  JMP     INPUT       ;low level input routine
 5037:     FFAF 7E E3CA                .OUTPUT JMP     OUTPUT      ;low level output routine
 5038:     FFB2 7E E4DE                .OUTLHL JMP     OUTLHLF     ;display top 4 bits as hex digit
 5039:     FFB5 7E E4E2                .OUTRHL JMP     OUTRHLF     ;display bottom 4 bits as hex digit
 5040:     FFB8 7E E4EC                .OUTA   JMP     OUTA        ;output ascii character in A
 5041:     FFBB 7E E4F0                .OUT1BY JMP     OUT1BYT     ;display the hex value of byte at X
 5042:     FFBE 7E E4FF                .OUT1BS JMP     OUT1BSP     ;out1byt followed by space
 5043:     FFC1 7E E4FC                .OUT2BS JMP     OUT2BSP     ;display 2 hex bytes at x and a space
 5044:     FFC4 7E E508                .OUTCRL JMP     OUTCRLF     ;carriage return, line feed to terminal
 5045:     FFC7 7E E518                .OUTSTR JMP     OUTSTRG     ;display string at X (term with $04)
 5046:     FFCA 7E E51B                .OUTST0 JMP     OUTSTRG0    ;outstrg with no initial carr ret
 5047:     FFCD 7E E544                .INCHAR JMP     INCHAR      ;wait for and input a char from term
 5048:     FFD0 7E E357                .VECINT JMP     VECINIT     ;initialize RAM vector table
 5049:                                 
 5050:          =0000FFD6                       ORG    ROMBS+$1FD6
 5051:                                 *** Vectors ***
 5052:     FFD6 00C4                   VSCI     FDB    JSCI
 5053:     FFD8 00C7                   VSPI     FDB    JSPI
 5054:     FFDA 00CA                   VPAIE    FDB    JPAIE
 5055:     FFDC 00CD                   VPAO     FDB    JPAO
 5056:     FFDE 00D0                   VTOF     FDB    JTOF
 5057:     FFE0 00D3                   VTOC5    FDB    JTOC5
 5058:     FFE2 00D6                   VTOC4    FDB    JTOC4
 5059:     FFE4 00D9                   VTOC3    FDB    JTOC3
 5060:     FFE6 00DC                   VTOC2    FDB    JTOC2
 5061:     FFE8 00DF                   VTOC1    FDB    JTOC1
 5062:     FFEA 00E2                   VTIC3    FDB    JTIC3
 5063:     FFEC 00E5                   VTIC2    FDB    JTIC2
 5064:     FFEE 00E8                   VTIC1    FDB    JTIC1
 5065:     FFF0 00EB                   VRTI     FDB    JRTI
 5066:     FFF2 00EE                   VIRQ     FDB    JIRQ
 5067:     FFF4 00F1                   VXIRQ    FDB    JXIRQ
 5068:     FFF6 00F4                   VSWI     FDB    JSWI
 5069:     FFF8 00F7                   VILLOP   FDB    JILLOP
 5070:     FFFA 00FA                   VCOP     FDB    JCOP
 5071:     FFFC 00FD                   VCLM     FDB    JCLM
 5072:     FFFE E000                   VRST     FDB    BUFFALO
 5073:                                          END
